
Programming and Data Structures Release 0.3 Amir Kamil Sep 08, 2024 CONTENTS I Foundations 2 1 Introduction 3 2 C++ Fundamentals 4 3 Types 9 3.1 Arithmetic and Comparisons .......................................10 3.2 Library Types ...............................................12 4 Control Structures 15 5 Procedural Abstraction 18 5.1 Code Organization in C++ ........................................19 5.2 The Compilation Process .........................................21 5.3 Specification Comments (RMEs) ....................................21 5.4 Properties of Procedural Abstraction ...................................23 6 Testing 24 7 Machine Model I 26 7.1 Pointers ..................................................30 8 Machine Model II 34 8.1 Pointer Errors ...............................................34 8.2 Function Calls and the Call Stack ....................................37 II Data Abstraction 42 9 The constKeyword 43 9.1 References and const...............................
. ..........44 9.2 Pointers and const............................................44 9.3constConversions ............................................45 10 Structs 47 10.1 Compound Objects and const......................................52 11 Abstract Data Types in C 54 11.1 Representation Invariants ........................................58 11.2 Plain Old Data ..............................................59 11.3 Abstraction Layers ............................................60 i 11.4 Testing an ADT ..............................................61 12 Command-Line Arguments 64 13 Input and Output (I/O) 66 13.1 I/O Redirection ..............................................66 13.2 Example: Adding Integers ........................................67 13.3 File I/O ..................................................68 14 More on Streams 72 14.1 String Streams ..............................................73 15 Program Design 75 16 Abstract Data Types in C++ 76 16.1 Implicit this-> ...........
. .................................78 16.2 Member Accessibility ..........................................80 16.3 Constructors ...............................................81 16.4 Default Initialization and Default Constructors .............................83 16.5 Get and Set Functions ..........................................85 16.6 Information Hiding ............................................87 16.7 Testing a C++ ADT ...........................................88 16.8 Member-Initialization Order .......................................89 16.9 Delegating Constructors .........................................89 17 Derived Classes and Inheritance 91 17.1 Ordering of Constructors and Destructors ................................95 17.2 Name Lookup and Hiding ........................................97 18 Polymorphism 100 18.1 Function Overloading ..........................................100 18.2 Subtype Polymorphism ..........................................
101 18.3 Static and Dynamic Binding . ......................................103 18.4dynamic_cast ..............................................104 18.5 Member Lookup Revisited ........................................105 18.6 The override Keyword .........................................107 18.7 Abstract Classes and Interfaces .....................................108 III Containers and Dynamic Memory 110 19 Containers and Iterators 111 19.1 Range-Based For Loops .........................................111 20 Time Complexity 114 21 Arrays 115 21.1 Arrays and Pointers ............................................118 21.2 Pointer Arithmetic ............................................119 21.3 Array Indexing ..............................................120 21.4 More on Array Decay ..........................................122 21.5 The End of an Array ...........................................122 21.6 Array Traversal ..............................................
123 21.7 Arrays and const. ...........................................124 ii 22 Array-based Containers 126 22.1 Set Operations ..............................................126 22.2 Code Example ..............................................127 22.3 Public Interface ..............................................127 22.4staticData Members ..........................................128 22.5 Data Representation ...........................................128 22.6size_t..................................................129 22.7 Implementation ..............................................130 22.8 Sorted Representation ..........................................132 23 Container ADTs and Polymorphism 136 23.1 Operator Overloading ..........................................136 23.2 Parametric Polymorphism ........................................138 23.3 Static vs.Dynamic Polymorphism ....................................146 24 Memory Models and Dynamic Memory 150 24.1 Static Local Variables .....
. ....................................150 24.2 Automatic Storage Duration .......................................151 24.3 Address Space ..............................................152 24.4 The newanddeleteOperators .....................................153 24.5 Dynamic Arrays .............................................155 24.6 Lifetime of Class-Type Objects .....................................156 24.7 Dynamic-Memory Errors ........................................158 24.8 Uses for Dynamic Memory .......................................160 25 Managing Dynamic Memory 161 25.1 RAII ...................................................162 25.2 Growable Set ...............................................164 26 The Big Three 168 26.1 Copy Constructor .............................................169 26.2 Assignment Operator ...........................................170 26.3 Shallow and Deep Copies ........................................171 26.4 The Law of the Big Three ...................
. ....................175 26.5 Example: Calls to the Big Three .....................................175 26.6 Destructors and Polymorphism .....................................177 27 Linked Lists 181 27.1 Traversing a Linked List .........................................188 27.2 Linked List Big Three ..........................................188 27.3 Insertion and Removal at the End ....................................190 27.4 List Template ...............................................191 28 Implementing Iterators 193 28.1 Iterator Definition ............................................196 28.2 Friend Declarations ...........................................201 28.3 Generic Iterator Functions ........................................202 28.4 Iterator Invalidation ...........................................204 28.5 Type Deduction ..............................................205 IV Functional Programming 207 29 Function Objects 208 29.1 Function-Pointer Types ..........................
. ...............211 iii 29.2 Function-Pointer Parameters .......................................212 29.3 Functors .................................................213 29.4 Comparators ...............................................216 29.5 Iterating over a Sequence .........................................218 30 Impostor Syndrome 220 31 Recursion 222 31.1 Tail Recursion ..............................................226 31.2 Kinds of Recursion ............................................228 31.3 Iteration vs.Recursion ..........................................229 32 Structural Recursion 230 32.1 Recursive Lists ..............................................230 32.2 Trees ...................................................232 33 Binary Search Trees (BSTs) 237 33.1 The BinarySearchTree Interface ...................................239 33.2 BST-Based Set ..............................................
242 34 Maps and Pairs 244 V Odds and Ends 247 35 Error Handling and Exceptions 248 35.1 Global Error Codes . ...........................................248 35.2 Object Error States ............................................249 35.3 Return Error Codes ............................................249 35.4 Exceptions ................................................250 35.5 Error Handling vs.Undefined Behavior .................................261 VI Supplemental Material 262 36 Introduction to C++ 263 36.1 A Simple Program ............................................263 36.2 Static Typing ...............................................265 36.3 Compound Data .............................................266 36.4 Value Semantics .............................................268 36.5 Example: Stickman ............................................272 37 Solving Problems with Recursion 288 37.1 Pancake Sort ...............................................288 37.2 Tower of Hanoi .................
. ............................290 37.3 Counting Change .............................................292 38 Containers of Pointers 295 38.1 Sorting Containers of Pointers ......................................300 38.2 Containers of Polymorphic Objects ...................................301 39 C and C++ Strings 302 39.1 C-Style Strings ..............................................302 39.2 C++ Strings ................................................
307 40 About 309 iv Programming and Data Structures, Release 0.3 List of Lectures 1)Introduction and C++ 2)Types, Control Structures, and Procedural Abstraction 3)Machine Model I 4)Machine Model II 5)Const, Structs, and ADTs in C 6)Streams and I/O 7)Program Design 8)Abstract Data Types in C++ 9)Derived Classes and Inheritance 10)Polymorphism 11)Containers and Iterators 12)Time Complexity, Arrays, and Pointer Arithmetic 13)Array-based Containers I 14)Array-based Containers II 15)Memory Models and Dynamic Memory 16)Managing Dynamic Memory 17)The Big Three 18)Linked Lists 19)Implementing Iterators 20)Function Objects and Impostor Syndrome 21)Recursion 22)Structural Recursion 23)Binary Search Trees and Maps 24)Error Handling and Exceptions CONTENTS 1 Part I Foundations 2 CHAPTER ONE INTRODUCTION Welcome to EECS 280: Programming and Introductory Data Structures!
This course covers several fundamental concepts in programming, including basic principles such as procedural and data abstraction, resource management, and basic data structures. The following is the official course description: Techniques and algorithm development and effective programming, top-down analysis, structured pro- gramming, testing, and program correctness.Program language syntax and static and runtime semantics.Scope,procedureinstantiation,recursion,abstractdatatypes,andparameterpassingmethods.Structured data types, pointers, linked data structures, stacks, queues, arrays, records, and trees.
Thiscourse,andComputerScienceingeneral,is notaboutcomputers,asstatedbyHalAbelson,authoroftheseminal textbook Structure and Interpretation of Computer Programs: [Computer science] is not really about computers – and it’s not about computers in the same sense that physics is not really about particle accelerators, and biology is not about microscopes and Petri dishes...and geometry isn’t really about using surveying instruments. Instead, the purpose of this course is to examine the generalizable concepts in programming.To understand what a generalizableconceptis,let’stakeadiversionfromprogrammingandconsideraconceptinbaking.Howmanyeggsdo youputinacake(assumingasingle-layer,eight-inchcake)?Eggsserveseveralfunctionsinacake,includingproviding structure, influencing the texture and smoothness, providing moisture, and contributing to the taste of the cake.
As an experiment,SummerStoneofTheCakeBlogvariedthenumberofeggsinarecipebetweenzeroandfour,findingthe following: •0 eggs: The cake was short and dense, and it fell apart when cut. It also tasted very much like flour.•1 egg: The cake was dense and compact, but held together when cut and had a pleasant taste.•2 eggs: The cake had a greater height and lighter texture and also had a pleasant taste.•3 eggs: The cake was even taller and lighter, with a slightly spongy texture, and still had a pleasant taste.•4 eggs: The cake was short, dense, and rubbery and tasted very much like egg.Thegeneralizableconcepthereisthateggsprovidestructuretoacake,andthatmoreeggsresultsinalightercake,up toapoint.Thus,thestructureandtextureofacakecanbemanipulatedbyvaryingthenumberofeggs,aslongasthere aren’t too few or too many.
The topics that we will cover in this course concern the generalizable concepts in programming, including procedural abstraction, data abstraction, dynamic resource management, object orientation, and many others. We will use C++ as our vehicle for learning these concepts, and we will implement several large programming projects to develop our experience and understanding of the concepts.However, learning C++ and implementing projects aren’t the end goal; rather, they are the mechanisms we use to explore the topics.3 CHAPTER TWO C++ FUNDAMENTALS C++ is a programming language , a language designed for expressing programs at a higher level than machine code , which is what directly runs on a computer’s central processing unit (CPU).
For example, Intel and AMD processors (typically used in Windows machines) implement the x86_64 instruction set architecture (ISA) , which results in ma- chine code that looks like the following: push rbp mov rbp, rsp mov DWORD PTR [rbp-4], 3 mov DWORD PTR [rbp-8], 4 mov edx, DWORD PTR [rbp-4] mov eax, DWORD PTR [rbp-8] add eax, edx Apple CPUs, as well as most mobile processors, implement the AArch64 ISA, with code like: sub sp, sp, #16 mov w0, 3 str w0, [sp, 12] mov w0, 4 str w0, [sp, 8] ldr w1, [sp, 12] ldr w0, [sp, 8] add w0, w1, w0 Machine code is extremely low level, so rather than writing programs in it directly, we prefer to use a higher-level programminglanguagethatallowsustowritemorereadablecodethatcanworkonmanydifferentCPUarchitectures. We can then use a compiler to translate the program into the equivalent machine code to run directly on a CPU.Examples of compilers for C++ include g++(the GNU C++ compiler), Clang, and MSVC (Microsoft Visual C++).
Alternatively,wecanrunahigher-levelprogramthroughan interpreter ,whichratherthantranslatingtheprograminto machine code, directly emulates the behavior of the program. Lobster is an example of an interpreter for (a subset of) C++.To illustrate the compilation process, let’s start with a small C++ program that prints to standard output (typically displaying in a console/terminal): #include <iostream> using namespace std ; intmain() { // print a greeting (continues on next page) 4 Programming and Data Structures, Release 0.3 (continued from previous page) cout << "Hello World!" << endl; // Declare some variables intx = 10 + 5; inty = 0; y = x; x = 20; // Print out the result cout << "x = " << x << ", y = " << y << endl; } Wewillmomentarilydiscusswhateachpartoftheprogrammeans,butfirstlet’scompileandrunthecode.
Assuming that the code is located in the file hello.cpp , we can compile it from the terminal (or command line ) withg++: g++ --std=c++17 hello.cpp -o hello.exe The items following g++arearguments (orcommand-line arguments to be precise) to the compiler: •--std=c++17 tells the compiler to use the C++17 version of the language •hello.cpp is our program •-o hello.exe tells the compiler to name the resulting machine-code file, or executable , ashello.exe After running the above command, we can now run the resulting executable from the command line: ./hello.exe Here,./tellstheterminalthattheexecutableisinthecurrent directory (orfolder). Theterminalrunstheprogramand displays the printed output: Hello World!x = 20, y = 15 Returning to the program source code, the first line ( #include <iostream> ) imports functionality from the C++ standard library, allowing us to write output to the screen and read input from the keyboard.
In particular, it defines cout,whichwecanusewiththe insertionoperator <<toprintvaluestostandardoutput. The coutvariableisactually definedinsidethe std(shortfor“standard”) namespace ,whichisawaytoorganizenamestoavoidconflictswithother libraries.
There are several ways we can use a name defined within a namespace: •with aqualified name that includes the namespace, as in std::cout : #include <iostream> intmain() { // print a greeting std::cout << "Hello World!" << std::endl; } •by first importing each name we want to use directly via using declarations , after which we can use the name without qualification: #include <iostream> (continues on next page) 5 Programming and Data Structures, Release 0.3 (continued from previous page) usingstd::cout; usingstd::endl; intmain() { // print a greeting cout << "Hello World!" << endl; } •by importing all the names from a namespace at once: #include <iostream> using namespace std ; intmain() { // print a greeting cout << "Hello World!" << endl; } Be careful with the last option, as there can be many names defined within a namespace, and importing them all increasesthelikelihoodoftherebeingaconflictwithnamesdefinedoutsideofthenamespace. Forsimplicity,wewill use it here.
After the initial two lines, we have a definition of a main()function, which is the entry point of a C++ program. The function returns an integer, represented by the inttype, and that comes before the function name itself.For now, we definemain()tonottakeanyarguments.(Ifthefunctiontakesarguments,therewouldbe functionparameters between the parentheses; we will return to this later.) Then we have the body of the function, enclosed by a pair of matching curlybraces.Withinthebody,wehaveasequenceof statements ,whichareexecutedinorder.Thefirstlineofthebody is actually a comment rather than a statement: // print a statement This does not do anything, but it serves as documentation for someone reading the code.We can write a comment by startingitwithdoubleslashes,inwhichcasetherestofthelinecomprisesthecomment.
Alternatively,wecanusethe sequence/*to open a comment and */to close it, which allows a comment to span multiple lines or part of a line: intmain() /* a comment here */ { /* here is a multiline comment */ } After the initial comment, we have a statement that prints to standard output: cout << "Hello World!" << endl; We use the insertion operator <<to insert the string"Hello World!" – a string is a sequence of characters, and we can write one directly in our program by enclosing it in double quotes. (Be aware that unlike some other languages, C++ strings cannot span multiple lines in the source code.) After inserting the string, we chainanother insertion of endl,whichisdefinedby <iostream> inthestdnamespace.Inserting endlwritesanewline,anditalso flushesthe output, meaning that it forces the output to appear immediately.
(Without flushing, the output can be buffereduntil a later time, which can result in better performance at the expense of delaying output.) Finally, we end the statement withasemicolon,whichisrequiredattheendofsimplestatementsinC++. UnlikePythonandsomeotherlanguages, 6 Programming and Data Structures, Release 0.3 whitespace is not generally significant in C++ programs, so the end of a line does not automatically end a statement.We can see what happens if we forget a semicolon: #include <iostream> using namespace std ; intmain() { // print a greeting cout << "Hello World!" << endl // oops } Attempting to compile the program results in the following: hello.cpp:7:33: error: expected ';'after expression cout << "Hello World!" << endl // oops ^ ; 1 error generated.This isacompile error , andit isthe compilerinforming usthat wehave amistake inour code.Thecompiler doesnot produce an executable in such a case, and we have to fix our error and recompile.
Continuing where we left off in our program, we have the following line: intx = 10 + 5; This is avariable declaration , which introduces a new variable, and in C++, it has three components: •the type of the variable ( intfor an integer in this case) •the name of the variable ( xhere) •an optional initialization expression (10 + 5above), which specifies the initial value of the variable Unlike languages like Python, C++ is statically typed , meaning that the type of a variable must be known at compile time,generallybyexplicitlyspecifyingthetypeinthevariable’sdeclaration. Andthetypeofthevariableneverchanges – for as long as it exists, it will have the type specified in its declaration.A variable’s initialization is an expression , which is a fragment of code that evaluates to some value.
(An expression may also have a side effect , which modifies the state of the program in some way, such as by printing to the screen or changing the value of an existing variable.) Expressions may be composed of the following elements: •literals, which specify a value directly in source code, such as 42or"Hello World!" •variables •functions calls, such as sqrt(x) •operators such as +and<< Inthecaseofthevariabledeclarationabove,theinitializationexpression 10 + 5evaluatestothevalue15,whichthen becomes the initial value of the variable x. Wewillseelaterwheninitializationexpressionsarerequired.Fornow,wenotethatforavariableoftype int,without an initialization expression, the variable would have an undefined value , which would result in undefined behavior if weweretouseitsvalue.Undefinedbehaviormeansthatwecannotrelyontheoutcome–theprogrammightwork,or it might crash, or it might empty your bank account.Thus, undefined behavior should be avoided at all costs.
Examining the following lines, 7 Programming and Data Structures, Release 0.3 inty = 0; y = x; x = 20; weseethatthevariable yisintroducedwithinitialvalue0. Thenwehavean assignment ,whichcopiesthevaluefrom the right-hand side into the left – in this case, the value of x, which is 15, is copied into y.The next line then assigns the value 20 to x.This, when the last line cout << "x = " << x << ", y = " << y << endl; executes, we see that xhas the value 20 and ythe value 15.A variable can only be used when it is in scope.Ascopeis a region of source code where names are meaningful, and such a region often corresponds to a blockof code delimited by curly braces.A variable is in scope starting at its declaration until the end of the scope region in which it is defined.
For example, consider the following code: intmain() { intx = 5; // x is now in scope cout << y << endl; // COMPILE ERROR -- y is not in scope inty = -3; // y is now in scope if(x > y) { inta = x - y; // a is now in scope cout << a << endl; }// a is no longer in scope cout << a << endl; // COMPILE ERROR -- a is not in scope } Thevariable yisnotinscopeuntilitsdeclaration,soattemptingtouseitinthesecondstatementisanerror. Below,the curly braces associated with the conditional define a new scope region, in which the variable ais introduced.Outside of the curly braces, ais no longer in scope, so using it in the last statement is erroneous.The compiler checks for us whether or not variables are in scope, reporting errors if we try to use one that is not.We have seen a simple program, how to compile and run it, and some fundamental C++ elements.We proceed to discuss more complex C++ features, such as type conversions, standard-library types, functions, and control flow.
8 CHAPTER THREE TYPES Previously, we saw that in C++, a variable is declared with its type, and the remains its type as long as the variable exists. C++hasseveralfundamental(alsocalled primitive oratomic)typesthatarebuilt-intothelanguageandalways available, without any #include lines.The following are a few such types: •intrepresentsa signed(positive,negative,orzero)integer,andinmostimplementations,canrepresentintegers between 2−31and231−1, inclusive intx = 3; •doublerepresents a floating-point number1 doubley = 2.5; •boolrepresents a Boolean value, i.e.true or false boolz = true; •charrepresents a single character (as opposed to a string, which is a sequence of characters), and a character literal is written with single quotes charc = 'w'; As withint, a variable of fundamental type must be explicitly initialized – otherwise its value is undefined.
intx; // undefined value doubley;// undefined value boolz; // undefined value charc; // undefined value The compiler’s type system detects misuse of types. For instance, the following attempts to initialize a doublewith a string literal, which is not a compatible type: doubley = "llama"; // COMPILE ERROR Ontheotherhand,therearesomecombinationsoftypesforwhichC++performsan implicitconversion ,allowingone to be used where the other is expected.For instance, an intcan be converted to a double, and vice versa: intx = 3.1; // narrowing conversion -- truncated to 3 doubley = 42; // widening conversion -- value unchanged Similarly,numerictypescanbeconvertedto bool,withzerovaluesconvertedto falseandnon-zerovaluesto true.1C++ also has a floattype that represents floating-point numbers.A doubletypically uses twice the memory space of a float(hence the name), and it can represent a much larger range of values.
9 Programming and Data Structures, Release 0.3 boola = 3.1; // true boolb = 0; // false Implicit conversions, while often useful, can also be a source of error. Consider the following code, which introduces amax()function that computes the maximum of two values.(We will discuss function definitions shortly.) doublemax( doublex,doubley) { intresult = x; if(y > x) { result = y; } returnresult; } Suppose we have the call max(3.4, 3.1) .The first line of the function implicitly converts the value of x, which is 3.4,toanint,sothatresultcontainsthevalue3.Thenitisthecasethat y,whosevalueis3.1,islargerthan result, soresultisassignedthetruncatedvalueof y,whichagainresultsin3.Thus,thefunctionreturnsthevalue3instead of 3.4.Ratherthanrelyingonimplicitconversions,whichcanbehardtodetectwhenreadingcode,wecanalsodoan explicit conversion viaacast.Dependingonthetypesinvolved,C++mayrequireacast,whileinothercasesitisoptional.
The following is an example of casting a doublevalue to an int: doublex = 4.2; inty = x; // implicit conversion -- easy to miss intz = static_cast <int>(x); // explicit conversion -- obvious in code While there are other kinds of casts, static_cast is the most common and the one we recommend. 3.1 Arithmetic and Comparisons C++supportscommonarithmeticoperations,suchasaddition( +),subtraction( -),multiplication( *),division( /),and modulo(%).Thebehavioroftheseoperatorsdependsonthetypesoftheoperand–forexample,addingtwo intvalues together produces an int, while adding two doublevalues produces a double.
The same holds for division, where dividing two intvaluestruncates the result to produce another intvalue: cout << (1 / 2) << endl; // prints 0 We can obtain a doublevalue by ensuring that one of the operands is a double: cout << (1.0 / 2) << endl; // prints 0.5 cout << (1 / 2.) << endl; // prints 0.5 cout << ( static_cast <double>(1) / 2) << endl; // prints 0.5 When the operand types differ as above, one operand is promoted to the type of the other, generally to the one that allowsformoreprecision. Inthecasesabove,the intoperandispromotedto doubleaspartofthedivisionoperation.The modulo operator requires both operands to be integers.The std::modf() function in the <cmath> library can beusedonfloating-pointoperands.(Similarly,the std::pow() functionin <cmath> doesexponentiation–C++does not have an operator for that.) As an example of modulo, the following functions convert a total number of seconds to whole minutes and leftover seconds, respectively: 3.1.
Arithmetic and Comparisons 10 Programming and Data Structures, Release 0.3 intminutes( intseconds) { returnseconds / 60; } intremaining_seconds( intseconds) { returnseconds % 60; } intmain() { inttotal = 153; intmin = minutes(total); // 2 intsec = remaining_seconds(total); // 33 } We rely on integer division to truncate the result in minutes() , and we use the modulo operator in remaining_seconds() to compute the remainder of the total number of seconds with 60. C++alsohasstandardcomparisonoperators: equality( ==),inequality( !=),less(<),lessorequal( <=),greater( >),and greater or equal ( >=).
However, avoid two pitfalls when using these operators: •Bewaryaboutcomparingfloating-pointnumbersthatresultfromarithmeticoperations–floating-pointnumbers cannot in general be represented exactly on a computer, so we can get unexpected results due to the loss of precision: cout << (0.1 + 0.2 == 0.3) << endl; // typically prints 0 (false) In such cases, values should be compared to within some margin of error rather than exactly: boolalmost_equal( doublex,doubley,doubleepsilon) { returnstd::abs(x - y) < epsilon; } ... cout << almost_equal(0.1 + 0.2, 0.3, 0.00001) << endl; // prints 1 (true) Here,weuse std::abs() tocomputetheabsolutevalueofthedifferencebetweenthetwovalues,thencompare against our margin of epsilon.•C++ does not support Python-style chaining of comparisons: intx = 10; cout << (3 < x < 7) << endl; // prints 1 (true) In this example, 3 < xproduces true, which is then promoted to the integer value of 1 for the subsequent com- parison with 7.Since 1 < 7, the result is true.
Ratherthanchainingcomparisons,weneedtouse Booleanlogic tocombinetheresultsoftwoseparatecompar- isons: cout << (3 < x && x < 7) << endl; // prints 0 (false) More on logical operations below. 3.1.Arithmetic and Comparisons 11 Programming and Data Structures, Release 0.3 3.2 Library Types AsidefromthefundamentaltypesthatarealwaysavailabletoC++programs,individual headersinthestandardlibrary define additional types.For instance, some commonly used types include std::string defined by the <string> header,std::vector defined by the <vector> header, and std::pair defined by the <utility> header.Thestd::string type represents an ordered sequence of characters.Similar to the initial program we saw last time, we first need to import the relevant header to get access to the type.We can then either use the qualified name with thestd::prefix,orincludea usingdeclarationtoallowustouse stringwithoutqualification.
Thefollowingisan example: #include <iostream> #include <string> using namespace std ; intmain() { string str1 = "make a "; string str2 = "wish"; str1 < str2; // true, alphabetic comparison cout << str1.size() << endl; // 7 (includes spaces) string str3 = str1 + str2; // "make a wish" str3[0] = str3[7]; str3[7] = 'f'; cout << str3 << endl; // "wake a fish"; } We start by declaring and initializing two stringvariables. We can compare them with <and other operators – the strings are compared lexicographically , meaning that the characters at each position are compared in order according to the underlying numerical value for the character.In the case above, since 'm'comes before 'w',str1compares less thanstr2.We can obtain the length of a string by calling .size() on it (the dot here is necessary, and we’ll see how this gets implemented later when we discuss classes and member functions).
We can concatenate two strings with the+operator and use square brackets to read or write an individual character in a string. In the code above, we concatenate str1andstr2to produce "make a wish" .Then we copy the character at index 7, which is 'w`, to position 0, resulting in "wake a wish" .Finally, we set the character at index 7 to 'f', which gives us the string "wake a fish" .Aside from characters, we might want to keep track of a sequence of other elements, such as intvalues.A std::vector is agenericsequence type that allows us to specify the type of element it holds.For instance, the following creates both a vector of doublevalues and one that holds stringvalues: #include <vector> using namespace std ; vector< double> nums = {1, 5, 3.5, 6.5}; vector<string> pets = {"cat", "dog", "fish"}; Here, we initialize each vector with an explicit set of values.There are other ways to initialize a vector: 3.2.
Library Types 12 Programming and Data Structures, Release 0.3 vector< int> v; // initialize v to be empty (NOT undefined) vector< int> v(5); // initialize v to contain five zeros vector< int> v(3, 42); // initialize v to contain three 42 's As with a string, we can use square brackets to index into a vector: vector< int> v = {3, 5, 42, 28}; cout << v[0] << endl; v[3] = 7; v[4] = 100; // out of bounds... undefined behavior!Becarefulnottoaccessanindexthatisoutofbounds–suchanaccessresultsinundefinedbehavior.Alternatively,we can use the .at()function, which checks whether we are within the bounds and throws an exception if we are not: vector< int> v = {3, 5, 42, 28}; cout << v[0] << endl; v.at(3) = 7; v.at(4) = 100; // out of bounds...throws an exception Assuming we don’t handle the exception, this causes the program to crash, which is better than undefined behavior – the crash immediately tells us we did something wrong, and we can run the code through a debugger to get more details.
We can also modify the size of a vector by adding and removing elements. In particular, the .push_back() function addsanelementtotheend,andthe .pop_back() functionremovesthelastelement.Wecanalsoremoveallelements with.clear() : vector< int> v; // v contains {} v.push_back(1); v.push_back(2); v.push_back(3); // v contains {1, 2, 3} v.pop_back(); // v contains {1, 2} v.clear(); // v contains {} A few other useful vector functions are the following: •.size() returns the number of elements in the vector •.front() returns a reference to the first element •.back() returns a reference to the last element •.empty() returns whether or not the vector is empty Forbothstringsandvectors, .size() returnsthesizeasthe size_ttype,whichisan unsigned integer,meaningthat it cannot represent negative values.If we compare to a signed integer such as an int, the compiler may warn us that we are comparing a signed and unsigned integer, which might produce surprising results: 3.2.
Library Types 13 Programming and Data Structures, Release 0.3 intx = -3; size_ts = 5; cout << (s > x) << endl; // prints 0 (i.e. false) The following is an example of a compiler warning for this: foo.cpp:9:14: warning: comparison of integers of different signs: 'size_t '(aka 'unsigned long ')and 'int'[-Wsign-compare] cout << (s > x) << endl; ~ ^ ~ 1 warning generated.To avoid this, we can use a cast to ensure that we are comparing values with the same “signedness”: cout << (static_cast<int>(s) > x) << endl; // prints 1 (i.e.true) Onelastlibrarytypeweexaminenowis std::pair ,whichrepresentsapairofvaluesratherthananarbitrarysequence.
The following is an example of using pairs: #include <utility> intmain() { std::pair< int,bool> p1; // initialized to {0, false} std::pair< int,bool> p2 = {-3, true}; p1.first = 7; p1.second = true; // p1 now is {7, true} std::pair<string, double> p3; // initialized to {"", 0.0} std::pair<string, double> p4 = {"hello", 73}; p3 = p4; // copy the values from p4 to p3 // p3 now is {"hello", 73} } 3.2. Library Types 14 CHAPTER FOUR CONTROL STRUCTURES C++isan imperative language,meaningthatwespecifycomputationasasequenceofstatements.Likeotherlanguages, we often organize statements into functions, which we can then use as abstractions; we will return to this shortly.The syntax of a function definition is as follows: <return type> <function name>(<optional parameters>) { <body statements> } The return type is specified first, and it corresponds to the type of value that the function returns.
In some cases, a function does not return a value at all, in which case we use the special type voidto specify that this is the case: voidprint_value( intx) { cout << x << endl; } If a function has a non-void return type, we explicitly provide the return value using a return statement : doublesquare( doublex) { returnx * x; } We need to ensure that every path through a non-void function reaches a return statement that provides a value com- patible with the return type. Otherwise, the behavior of the function is undefined, and the compiler may generate a warning or error.2 After the return type, we specify the name of the function, and if it takes arguments, the function parameters within the following parentheses.A parameter specifies both the type of the value it expects, as well as the name we use to refer to the corresponding argument within the function body.Finally, we have the body consisting of a sequence of statements enclosed by curly braces.
We can specify more complex control flow within a function through the use of compound statements such as condi- tionals and loops. The following demonstrates a conditional: doubleabs( doublex) { if(x < 0) { return-x; }else{ returnx; } } 2The one exception in C++ is the main()function, which implicitly returns the value 0 if no return statement is reached.However, this is not the case for any other function, even if its return type is int.15 Programming and Data Structures, Release 0.3 Weusethe ifkeywordtointroduceaconditional,followedbyatestexpressionwithinparentheses.The“then”branch canbeasinglestatement,oritcanbea blockofstatementsenclosedbycurlybraces.Werecommendusingblocks,as that makes it clear what is part of a branch and what isn’t.For the “else” branch, we use the elsekeyword followed by a statement or block.
We can also chainconditionals using else if: doubledescribe( intx) { if(x < 0) { cout << "negative" << endl; }else if (x > 0) { cout << "positive" << endl; }else{ cout << "zero" << endl; } } At most one branch a conditional chain may execute. Aforstatement can be used to express a loop that repeats until some condition is false.Its syntax is as follows: for (<initialization>; <test>; <update>) { <body statements> } The initialization is run once at the beginning of the loop, and it can introduce new variables – the scope of such a variable is just the loop itself.The test is run before each iteration of the loop – if the test is true, the loop body runs, otherwise the loop exits.The update is run after each loop iteration completes.3As with a conditional, the body may be a single statement or a block – we recommend the latter.
As an example, let’s compute the sum of the elements in a vector: vector< double> values = /* fill with some values */ ; doublesum = 0; for(size_ti = 0; i < values.size(); ++i) { sum += values[i]; } We initialize a new variable iwith value 0, representing the current index into the vector. We declare ito be of typesize_t, so that we don’t get a compiler warning by comparing it against values.size() , which produces a size_t.Weexecutetheloopbodyaslongasourindex iislessthanthesizeofthevector.Aftereachiteration, igets incremented, and the loop exits once its value is equal to values.size() .In addition to for loops, C++ has while loops, which are a simplification of for loops: while (<test>) { <body statements> } Theloopwillexecutethebodyaslongasthetestistrue,anditwillexitwhenthetestbecomesfalse.
Wecantranslate our for loop above to a while loop as follows: size_ti = 0; while(i < values.size()) { sum += values[i]; (continues on next page) 3Any of the initialization, test, or update may be omitted, but the semicolons separating them must still be present. If the test is omitted, it is assumed to always be true.16 Programming and Data Structures, Release 0.3 (continued from previous page) ++i; } Dependingonthecomputation, itmaybemorenaturallyexpressedusingoneloopconstructortheother.Inthiscase, iterating over the elements of a vector arguably is more cleanly expressed with a for loop than a while loop.In addition to the normal behavior of a loop, we further control execution through the loop with return, break, and continue statements.A return statement immediately exits the enclosing function.
A break statement exits the (most inner) loop, proceeding past the loop: // Print elements until the first 0 for(size_ti = 0; i < values.size(); ++i) { if(values[i] == 0) { break; } cout << values[i] << endl; } Acontinue statement skips the rest of the current loop iteration, but does not immediately exit the loop: // Print the square root of non-negative numbers for(size_ti = 0; i < v.size(); ++i) { if(v[i] < 0)) { continue ; } cout << v[i] << endl; } Often,aloopcanberestructuredtoavoidbreakorcontinuestatements,butinothercases,acomputationmaybemore easily expressed using them.
For the second loop above, we can rewrite it as follows: // Print the square root of non-negative numbers for(size_ti = 0; i < v.size(); ++i) { if(v[i] >= 0)) { cout << v[i] << endl; } } For the first loop that uses a break statement, we can use logical operations instead: // Print elements until the first 0 for(size_ti = 0; i < values.size() && values[i] != 0; ++i) { cout << values[i] << endl; } Wecanuseeither &&orandtospecifyaconjunction(an“and”oftwoconditions),either ||ororforadisjunction(an “or” of two conditions), and either !ornotto negate a truth value. Conjunction and disjunction are short-circuiting , meaning that the right-hand side will only be evaluated if necessary to compute the result.In our example here, values[i] != 0 only gets evaluated when i < values.size() – good thing, because otherwise we could access an element past the end of the vector, producing the dreaded undefined behavior.
17 CHAPTER FIVE PROCEDURAL ABSTRACTION Abstraction is the principle of separating whatsomething is or does from howit does it. It is the primary tool for managing complexity in Computer Science and other fields.As a non-programming example, consider the task of making a sandwich.In order to make a sandwich, we don’t need to know how bread is made, nor peanut butter nor jelly.All we need to know is how to put those ingredients together to construct a sandwich.Thus, we rely on the abstractionsofbread,peanutbutter,andjellytomakeasandwich.Similarly,thepersonwhoeatsoursandwichdoesn’t need to know how it’s made – all they need to know is that it is a delicious sandwich.= howwhat = how what what = howwhatwhatwhatwhatHigh Level Low Level whatwhatwhat Figure 5.1: Abstraction layers for making a sandwich.
Inacomplexsystem,therearemultiplelayersofabstraction,eachofwhichreliesonthe“what”knowledgeofthelower layerswithoutneedingtoknowthe“how.”Inthecaseofasandwich,thetoplayeristheconsumerofthesandwich,who onlyneedstoknowthatitisasandwich. Thelayerbelowisthemakerofthesandwich,whoneedstoknowwhatbread, peanut butter, and jelly are and how to combine them into a sandwich.They do not need to know how to make each of the ingredients.The jelly manufacturer needs to know how to combine fruit and other ingredients into a container and apply heat to make jelly.However, they do not need to know how to grow fruit.That’s a farmer’s job, who needs to know how to use plants, water, and pollinators in order to produce fruit.Computer programs are similarly built using layers of abstraction.When it comes to computational procedures, func- tionsareourmechanismfordefining proceduralabstractions .Theuserofafunctionneedonlyknowwhatthefunction doeswithoutcaringabouthowthefunctionaccomplishesitstask.
Specifically,theuserneedstoknowthe interface of the function, including its actual code interface and the documentation of what the function does. The user does not 18 Programming and Data Structures, Release 0.3 need to concern themselves with the implementation of the function, the actual details of how the function works.5.1 Code Organization in C++ In general, we organize a program by decomposing it into independent modules, defined in separate files.In C++, a singlemoduleisfurtherdecomposedintoa headerfileanda sourcefile.Inthiscourse,wewillusethe .hppextension for header files and the .cppextension for source files4.The header contains the interface of the module, while the source file contains the actual implementation.
As an example, the following is a subset of stats.hpp from Project 1: #include <vector> //REQUIRES: v is not empty //EFFECTS: returns the arithmetic mean of the numbers in v doublemean(std::vector< double> v); Only a declaration of the mean()function appears in the header, along with its documentation. The actual definition goes instats.cpp , the source file for the module: #include "stats.hpp" #include "p1_library.hpp" using namespace std ; doublemean(vector< double> v) { returnsum(v) / count(v); } Other source files that use the functions in the stats module need only includethe header file ( stats.hpp ) with the #include directive: #include <iostream> #include "stats.hpp" using namespace std ; intmain() { vector< double> data = { 1, 2, 3 }; cout << mean(data) << endl; } Asourcefilethatusesthestatsmoduleonlyneedstoknowabouttheinterfaceofthemodule.Aslongastheinterface remainsthesame,theimplementationofamodulecanchangearbitrarilywithoutaffectingthebehaviorofasourcefile that uses it.
The#include directive actually pulls in the code from the target into the current file. So the end result is as if the declarations for the stats functions actually were written in this source file as well.We get access to those functions’ declarations without having to manually repeat them.Library modules such as vectorandiostream are surrounded by angle brackets (e.g.#include <vector> ) in a #include directive.Non-library headers that are located in the same directory are surrounded by double quotes (e.g.4The extensions .hxxand.hare other common conventions for header files, and .cxxand.ccare also common for source files.5.1.Code Organization in C++ 19 Programming and Data Structures, Release 0.3 #include "stats.hpp" ).For the purposes of this course, we never #include anything other than header files and standard libraries – we never #include a.cppsource file.Theusing namespace std; directive allows us to refer to standard-library entities without prefixing them with std::.
An alternative is to avoid the prefix for specific entities with individual usingdeclarations: #include <iostream> #include "stats.hpp" usingstd::cout; // allow cout to be used without std:: usingstd::endl; // allow endl to be used without std:: intmain() { // must prefix vector with std:: std::vector< double> data = { 1, 2, 3 }; // can elide std:: with cout and endl cout << mean(data) << endl; } It is considered bad practice among C++ programmers to include a using namespace std; directive, or generally otherusingdeclarations,inaheaderfile–thisforcesthosedirectivesanddeclarationsonanyonewho #include sthe header. On the other hand, they are fine to place in a source file, since source files are generally not #include d.The overall file structure for Project 1 is shown in Figure 5.2, excluding testing modules.p1_library.hpp stats.hpp p1_library.cpp stats.cpp main.cpp Figure 5.2: File structure for Project 1.Arrows are shown between header files and the source files that #include them.
When compiling the project, only source files are passed to the compiler. The header files are folding into the source files through the #include directives: $ g++ --std=c++17 -pedantic -g -Wall -Werror p1_library.cpp stats.cpp main.cpp -o main.˓→exe Any number of source files can be passed to the compiler, but only one of those may contain a main()function.5.1.Code Organization in C++ 20 Programming and Data Structures, Release 0.3 5.2 The Compilation Process Consider the compilation command above.The elements of the command are: •g++is the C++ compiler we are invoking.•The--std=c++17 argument tells it to compile according to the C++17 language standard.•The-pedantic argumenttellsthecompilertoadherestrictlytotheC++standard.Withoutthisflag,compilers often provide extensions or allow behavior that is not permitted by the standard.•The-gargument tells the compiler to produce an executable that facilitates debugging.
•The-Wallargument asks the compiler to generate warnings about possible programming errors. •The-Werror argumentconfiguresthecompilertotreatwarningsaserrors,sothatitdoesnotcompilecodethat has warnings.•The arguments -o main.exe tell the compiler to produce the output file main.exe .•Theremainingthreeargumentsarethesourcefilesforourprogram– p1_library.cpp ,stats.cpp ,andmain.cpp.For the source files, the compiler will compile each of them separately, producing temporary object files .It will then attempt to linkthe object files together into the output executable.The linking step can fail if: •A function is declared and used in the source files, but no definition is found.
For example, if the definition for percentile() is missing, a linker error such as the following results: Undefined symbols for architecture x86_64: "percentile(std::__1::vector<double, std::__1::allocator<double> >, double)",␣ ˓→referenced from: _main in main-dc223c.o ld: symbol(s) not found for architecture x86_64 clang: error: linker command failed with exit code 1 (use -v to see invocation) •Multiple definitions of the same function are found. For example, if we try to compile and link multiple source files that define a main()function, we get a linker error like the following: duplicate symbol _main in: /var/folders/gc/0lqwygqx381fmx9hhvj0373h0000gp/T/main-9eba7c.o /var/folders/gc/0lqwygqx381fmx9hhvj0373h0000gp/T/stats_tests-b74225.o ld: 1 duplicate symbol for architecture x86_64 clang: error: linker command failed with exit code 1 (use -v to see invocation) Upon success, the result of the linking step is the final program executable, main.exe for the compilation command above.
5.3 Specification Comments (RMEs) The interface of a function includes its signature, which consists of the function’s name and parameter types. The return type of the function5is also part of its interface.Another part of a function’s interface is documentation about what it does, as in the following: 5Technically, the return type of a regular (i.e.non-template) function is not part of its signature as defined by the C++ standard (see [defns.signature] in the standard).It is, however, part of the function’s interface.5.2.The Compilation Process 21 Programming and Data Structures, Release 0.3 //REQUIRES: v is not empty //EFFECTS: returns the arithmetic mean of the numbers in v doublemean(std::vector< double> v); This documentation describes the whatof the function, so it is an integral part of what a user of the function needs to know.The documentation format we use in this course is an RME, which consists of a REQUIRES clause, a MODIFIES clause, and an EFFECTS clause.
5.3.1 REQUIRES Clause TheREQUIRES clauselistswhatthefunctionrequiresinordertoaccomplishitstask. Iftherequirementsarenotmet, then the function provides no guarantees – the behavior is undefined , and anything the function does (e.g.crashing your computer, stealing your credit-card info, etc.) is valid.Thus, a user should never call a function with arguments or in a state that violates the REQUIRES clause.Within the function definition, the implementation is allowed to assume that the REQUIRES clause is met – again, a usershouldnevercallthefunctioniftheyareviolated.Agoodpracticeisto assertthattheREQUIRESclauseismet, if it is possible to do so: #include <cassert> #include "stats.hpp" #include "p1_library.hpp" using namespace std ; doublemean(vector< double> v) { assert(!v.empty()); returnsum(v) / count(v); } Inordertouse assert,the<cassert> headermustbeincluded.Thenabooleanexpressioncanbepassedto assert.If the expression evaluates to a true value, execution proceeds normally.
However, if it evaluates to a false value, then the program crashes with a meaningful error message: Assertion failed: (!v.empty()), function mean, file stats.cpp, line 8. Thisismuchmoredesirablethancomputingawronganswer(orstealingyourcredit-cardinfo!),asittellstheuserthey did something wrong and where the requirements were violated.Ifafunctiondoesn’thaveanyrequirements,theREQUIRESclausemaybeelided.Suchafunctioniscalled complete, while one that has requirements is called partial.5.3.Specification Comments (RMEs) 22 Programming and Data Structures, Release 0.3 5.3.2 MODIFIES Clause TheMODIFIES clause specifies the entities outside the function that might be modified by it.This includes pass-by- reference parameters, global variables ( notin this course – only global constants are permitted), and input and output streams (e.g.
cout,cin, a file stream, etc.): //MODIFIES: v //EFFECTS: sorts v in ascending order voidsort(std::vector< double> &v); The MODIFIES clause only specifies what entities may be modified, leaving out any details about what those modifi- cations actually mightbe. The latter is the jobof the EFFECTS clause.Instead, thepurpose of the MODIFIES clause is for the user to quickly tell what items might be modified.If no non-local entities are modified, the MODIFIES clause may be elided.5.3.3 EFFECTS Clause TheEFFECTS clause specifies what the function actually does.This includes details about what modifications are made, if any, as well as what the return value means, if there is one.All functions should have an EFFECTS clause – if a function does nothing, there is no point to writing the function.TheEFFECTSclauseshouldgenerallyonlyindicate whatthefunctiondoeswithoutgettingintoimplementationdetails (thehow).
It is part of the interface of a function, so it should not be affected if the implementation were to change. 5.4 Properties of Procedural Abstraction Asmentionedpreviously,theimplementationofanabstractionshouldbeabletochangewithoutaffectingthewaythe abstraction is used.More formally, abstractions are substitutable – we should be able to swap out an implementation ofanabstractionforadifferentone.Aslongastheinterfaceremainsthesame,codethatusestheabstractionwillstill work.Abstractionsshouldalsobe local,meaningthatitshouldbepossibletounderstandtheimplementationofoneabstrac- tion without knowing anything about the implementation of other abstractions.This implies that the implementation ofoneabstractionshouldnotrelyonimplementationdetailsofanother–instead,theformershouldonlyworkwiththe latter through the interface of the latter.5.4.Properties of Procedural Abstraction 23 CHAPTER SIX TESTING Testing is the primary mechanism we have for determining whether or not code is correct.
Most programs are too complex to formally prove correct with reasonable effort. Instead, thorough testing provides a measure of confidence that the code behaves correctly.Insufficienttestingcanleadtocodethatbreakswhendeployed,withpotentiallydisastrousconsequences.Acanonical example is the Therac-25, a radiation-therapy machine from the 1980s.A combination of poor design and software bugs led to several cases where patients received massive radiation overdoses.Three patients died as a result.A more recent example of software bugs leading to catastrophic failure is Knight Capital Group, a financial-services firm that engagedinhigh-frequencytrading.Lackofregressiontesting,poorsoftwaremaintenance,andamistakeindeployment caused a new version of their software to execute millions of trades that bought shares at high prices and sold them at lower ones – all in a span of just 45 minutes.
The end result was a pre-tax loss of $440 million, and the company was forced to sell itself to a competitor. In this course, the stakes aren’t quite as high as in the cases above.However, it is often the case that the difference between doing poorly on a project and doing well is how well you test your code.Testing is the mechanism for deter- mining whether or not code is buggy.Once a bug has been detected, debugging is the process used to identify and fix the source of the bug.There are two main categories of test cases: •Unit tests test once piece of code at a time, often at the granularity of individual functions or small groups of functions.This helps to find bugs early as well as make them easier to debug, since a failed unit test identifies exactly which function is broken.•System tests test an entire module or program as a whole.
This can identify bugs that occur when integrating multipleunitstogether–it’spossiblethattwounitsappeartoworkindividually,butoneunitmakesanincorrect assumption about the other that only manifests when they are tested together. System tests can also be closer to the real use case of a program, providing a measure of confidence that the program works as a whole.In software development, it is important to maintain a set of regression tests , or tests that are run every time a code changeismade.Thatway,abreakingchangeisidentifiedimmediatelyandcanbefixedbeforethesoftwareisdeployed.Regression tests generally include both unit and system tests.Test-driven development is a common programming practice that integrates writing tests with developing the imple- mentation of a program.Once the interface of a unit has been determined, tests can be written even before the imple- mentation–thatway,oncetheimplementationiswritten,thereareteststhatcanberunimmediately.
Furthermore,the process of writing tests can help inform the right strategy to use in implementation, reducing development time. The implementation in turn inspires new test cases, based on an understanding of what mistakes could have been made in the code.The result is an iterative process: writing tests for a unit, implementing the unit, writing more tests, fixing bugs, and so on until the code has been thoroughly vetted.Only valid test cases should be written.Those that don’t compile are useless, as well as those that result in undefined behavior (e.g.by violating the REQUIRES clause of a function).There are several types of valid test cases: 24 Programming and Data Structures, Release 0.3 •Simpletestcasesareforthe“average”case.Forinstance,intestinga mode()functioninProject1,anexample of a simple test case is one that tests a vector that contains exactly one mode (e.g.{ 1, 2, 3, 2 } ).•Edgecases are those that test special cases in a unit’s behavior.
For instance, the mode()function requires that its argument vector be non-empty. Thus, the smallest vector that can be passed to mode()is one with a single element – this is an edge case.Another special case is when the input has two modes – in this case, the documentationofthefunctionspecifiesthatitreturnsthesmallerone.Soweshouldtestthatthefunctionindeed behaves correctly in this case.•Stresstestsareintensiveteststhatensurethatasystemwillworkunderaheavyload.Forexample,anautograder for a 1000-person course should be able to withstand hundreds of students trying to submit right before the deadline.Thus,itisimportanttotesttheautograderwithlargenumbersofconcurrentrequests.Stresstestswill not be used in this course, since the projects we will focus on are not performance-critical.Test cases should focus on cases that realistically could be erroneous.For example, a malicious programmer could insertabugthatonlyoccursforaspecific,arbitraryinput(e.g.ifthenumber42isintheinput).
However,wegenerally can’ttesteverypossibleinput,sowehavetoconcentrateonthosecaseswhereareasonableprogrammercouldmakea mistake. (Other mechanisms, such as code reviews, are used to guard against malicious programmers.) Thesmall scope hypothesis states that thorough testing with “small” test cases is sufficient to catch most bugs in a system6.Thus, our test cases need not be large – in general, they should be small enough where we can compute the expected results by hand.Similarly, having more test cases is not necessarily better.Fewer test cases that are meaningfully different is more effective than having many, redundant test cases.As an example, the data sets { 1, 1, 2, 2, 2 } and{ 1, 1, 2, 2, 2, 2 } are not meaningfully different for the mode()function – there is no good reason why it would behave differently in the two cases.On the other hand, the data set { 1, 1, 2, 2 } is meaningfully different, since it contains two modes.6SeeEvaluatingthe“SmallScopeHypothesis” byAndonietal.
and OntheSmall-ScopeHypothesisforTestingAnswer-SetPrograms byOetsch et al. for empirical evaluations of the hypothesis.25 CHAPTER SEVEN MACHINE MODEL I A computer program consists of source code that determines what the program does.The program itself is run on a machine, and the program directs the machine on what computation should be preferred.In order to understand a program,itisimportanttohavea machinemodel thathelpsusreasonabouthowthesourcecoderelatestowhathappens at runtime.As an example, consider the following C++ program: intmain() { intx = 3; doubley = 4.1; intz = x; x = 5; } When the program runs, execution starts at main().Each variable in the program is a name that refers to some objectin memory, a region of memory that holds the data value for the variable.The variable’s type determines how muchmemoryisrequired,andhowthedataarerepresented–generally,dataarestoredin bytes,whichthemselvesare sequencesofeight bits,eachofwhichisabinarydigitthatiszeroorone.
Forinstance,intypicalC++implementations, avariableoftype intrequiresfourbytes(32bits)ofstorage,whileoneoftype doublerequireseightbytes(64bits). Itisoftenusefultothinkofmemoryasalarge array,withdatavaluesstoredatdifferent indicesintothearray,asshown in Figure 7.2.Here, the program is using memory index 6 for x, index 2 for y, and index 4 for z.(Later, we will see that a program usesamoresystematic methodforlocatingthelocalvariablesofafunction .) Thecontentsofmemoryillustratedabove areaftertheinitializationof xandybutbeforetheinitializationof z.Thelocationfor xhasarepresentationofthe int value3,thelocationfor yhasarepresentationofthe doublevalue4.1,andthelocationfor zhassomeindeterminate value.When the program proceeds to initialize z, it copies the value 3 from the memory for xinto the memory for z, as demonstrated in Figure 7.3.Finally, the assignment x = 5modifies the value of xto be 5, as Figure 7.4 illustrates.
In order to discuss the conceptual spaces for source code and runtime in more detail, we need some terminology. In source code, a namerefers to some entity such as a variable, function, or type.As mentioned above, a variableis a name that refers to an objectin memory.A name has a scope, which determines what region of code can use that nametorefertoanentity.Forexample,thescopeof yinthecodeabovebeginsatthedeclarationof yandendsatthe end of the function definition for main().Attempting to use youtside this region will result in a compiler error.A declaration is what introduces a name into the program and begins its scope.Atruntime,an objectisapieceofdatainmemory,anditislocatedatsome addressinmemory(correspondingtothe index in our basic machine model above).An object has a lifetimeduring which it is legal to use that object.More specifically, an object is created at some point in time, and at some later point in time it is destroyed.
The storage durationof an object determines its lifetime. There are three options that we will see in C++: 26 Programming and Data Structures, Release 0.3 x y z…00000000000000000000000000000101010000000001000001100110011001100110011001100110011001100110011000000000000000000000000000000011…Memory Figure 7.1: Variables correspond to objects in memory, each of which stores a data value represented in binary.763x54z324.1y10 Figure 7.2: Simplified machine model, with memory as a linear (array) structure with slots for different objects.27 Programming and Data Structures, Release 0.3 763x543z324.1y10 Figure 7.3: Initializing an object as a copy of another.×763 5x543z324.1y10 Figure 7.4: Modifying the value of an object.
28 Programming and Data Structures, Release 0.3 •static: the lifetime is essentially the whole program •automatic (also called local): the lifetime is tied to a particular scope, such as a block of code •dynamic: the object is explicitly created and destroyed by the programmer The former two durations are controlled by the compiler, while the latter is specified by the programmer. We will restrict ourselves to static and automatic storage duration until later in the course .A variable is not the same thing as a memory object: a variable is a concept associated with source code, while an objectisassociatedwiththeruntime.Thesamevariablecanrefertodifferentobjectsatdifferenttimes,suchasalocal variableinafunctionthatiscalledmorethanonce.Anobjectthathasdynamicstoragedurationisnotassociatedwith a variable at all.An important consideration in the design of a language is the semantics of an initialization or assignment of the form x = y.
Doesthischangewhichobject xisreferringto,ordoesitmodifythevalueoftheobjectthat xisreferringto? The first option is known as reference semantics , while the second is value semantics .In C++, the default is value semantics.Consider the following program: intx = 42; // initialize value of x to 42 inty = 99; // initialize value of y to 99 x = y; // assign value of y to value of x Theassignmentinthelastlinecopiesthevaluestoredinthememoryobjectassociatedwith yintothememoryobject forx, as shown in Figure 7.5.42x99y42x99y×99x = y Figure 7.5: Assignment copies a value from the right-hand side into the left-hand-side object.C++ supports reference semantics only when initializing a new variable.Placing an ampersand ( &) to the left of the new variable name causes the name to be associated with an existing object.
The following is an example with a local variable: intx = 42; // initialize value of x to 42 intz = 3; // initialize value of z to 3 int&y = x; // y and x are now names for the same object x = 24; // assigns 24 to object named x/y y = z; // Does NOT re-bind y to a different object // Value semantics used here. The declaration int &y = x; introduces yas a new name for the object associated with x.Any subsequent modifi- cation to this object is reflected through both names, regardless of the name used to perform the modification.Figure 7.6 shows the effects of the assignments in the code above.Since C++ only supports reference semantics in initialization, the association between a variable and a memory object can never be broken , except when the variable goes out of scope.29 Programming and Data Structures, Release 0.3 42x,y3z3z×x = 2442x,y243z×y = z24x,y3 Figure 7.6: A reference is another name for an existing object.
7.1 Pointers Recallthat in C++, an objectis a piece of data in memory, and that it is located at some addressin memory. The compiler and runtime determine the location of an object when it is created; aside from deciding whether an object is in the global segment, on the stack, or in the heap segment (the segment used for dynamic memory), the programmer generally does not control the exact location where an object is placed1.Given the same program and the same inputs tothatprogram,differentsystemswilloftenendupplacingthesameobjectsatdifferentmemorylocations.Infact,in many implementations, running the same program twice on the same system will result in different addresses for the objects.Thoughtheprogrammerdoesnothavecontrolovertheaddressatwhichanobjectislocated,theprogrammerdoeshave theabilitytoquerytheaddressonanobjectonceithasbeencreated.
InC++,the &(usuallypronounced“address-of”) operator can be applied to an object to determine its address: intmain() { intx = 3; doubley = 5.5; cout << &x << endl; // sample output: 0x7ffee0659a2c cout << &y << endl; // sample output: 0x7ffee0659a20 } Addresses are usually written in hexadecimal (base-16) notation, with a leading 0xfollowed by digits in the range 0-9anda-f, witharepresenting the value 10, bthe value 11, and so on. Most modern machines use 64 bits for an address; since each digit in a hexadecimal number represents four bits ( 24= 16values), a 64-bit address requires up to16hexadecimaldigits.Theexamplesaboveuseonly12digits,implyingthattheleadingfourdigitsarezeros.Most examples in this text use fewer digits for conciseness.In addition to being printed, addresses can also be stored in a category of objects called pointers2.
A pointer variable can be declared by placing a *symbol to the left of the variable name in its declaration: intx = 3; int*ptr = &x; cout << ptr << endlt; // sample output: 0x7ffee0659a2c A pointer type consists of two elements: •thetypeoftheobjectswhoseaddressesthepointercanholdasavalue. Forexample,an int *pointercanhold the address of an int, but not that of any other data type.•the*symbol, which indicates that the type is a pointer EachdatatypeinC++hasacorrespondingpointertype.Forinstance, int *isthepointertypecorrespondingto int, 1C++ has placement new, which allows a programmer to initialize a new object in a given memory location.However, even with placement new, the original memory must have been allocated by the programmer, and the programmer does not control the exact address produced by that allocation.2The terms addressandpointerare often used interchangeably.Technically, a pointer is an object that holds an address as its value, while the address is the value itself.7.1.
Pointers 30 Programming and Data Structures, Release 0.3 double * is the pointer type corresponding to double, anddouble ** is the pointer type corresponding to double *. Apointerobjectcanbe dereferenced toobtaintheobjectwhoseaddressthepointerisholdingbyapplyingthe *(usually pronounced “star” or “dereference”) operator: intx = 3; inty = 4; int*ptr = &x; cout << *ptr << endl; // prints 3 ptr = &y; cout << *ptr << endl; // prints 4 Weoftensaythatapointer“pointsto”anobject,andthatthe *operator“follows”thepointertotheobjectitispointing at.Inkeepingwiththisterminology,apointerisoftenpicturedasanarrowfromthepointertotheobjectitispointing at, as shown in Figure 7.7.0x7ffee0659a200x7ffee0659a2cptr0x7ffee0659a284y0x7ffee0659a2c3x Figure 7.7: An arrow indicates the object whose address a pointer holds.Usually, we are not concerned with actual address values – they are implementation-dependent and can vary between program runs.
Instead, we only concern ourselves with which object each pointer is referring to. Thus, we often draw just an arrow to illustrate which object a pointer is pointing to, as in Figure 7.8, without the actual address value.ptr4y3x Figure 7.8: Pointers are often illustrated by just an arrow, without the actual address value.The following is another example of working with a pointer: intmain() { intfoo = 1; int*bar = &foo; foo += 1; *bar += 1; cout << foo << endl; // prints 3 (continues on next page) 7.1.Pointers 31 Programming and Data Structures, Release 0.3 (continued from previous page) cout << bar << endl; // prints address of foo (e.g.0x1000) cout << *bar << endl; // prints 3 } Stackmain0x10001foo0x10040x1000barfoo += 1Stack*bar += 1Stackmain0x10002foo0x10040x1000barmain0x10003foo0x10040x1000bar Figure 7.9: Example of modifying an object through a pointer.The code initializes the pointer barwith the address of foo.
It proceeds to increment foodirectly, then dereferences bartoincrementtheobjectitispointingat. Sinceitispointingattheobjectassociatedwith foo,theresultisthat foo has value 3.The state of memory at each point is shown in Figure 7.9.7.1.1 Pointers and References The*and&symbolsmeandifferentthingswhentheyareusedaspartofatypeandwhentheyareusedinanexpression: •When used in a type, *means that the type is a pointer type, while &means the type is a reference type.•When used as a unary prefix operator in an expression, *is used to dereference a pointer, while &is used to obtain the address of an object.•Whenusedasabinaryinfixoperator, *ismultiplication,while &isabitwiseand operation(whichisoutsidethe scope of this course).The following illustrates some examples: intx = 3; int*ptr = &x; int&ref = *ptr; Inthesecondline, *isusedinatype,so ptrisapointertoan int.Theinitializationisanexpression,sothe &obtains theaddressoftheobjectcorrespondingto x.
Inthethirdline, &isusedaspartofthetype,so refisareferencevariable. Itsinitializationisanexpression,sothe *dereferences ptrtogettotheobjectassociatedwith x.Theresultisthat ref is an alias for the same object as x.Pointers allow us to work indirectly with objects.The following is an implementation of a swap function that uses pointers to refer to the objects whose values to swap: voidswap_pointed( int*x, int*y) { inttmp = *x; *x = *y; *y = tmp; } intmain() { inta = 3; intb = 5; (continues on next page) 7.1.Pointers 32 Programming and Data Structures, Release 0.3 (continued from previous page) swap_pointed(&a, &b); cout << a << endl; // prints 5 cout << b << endl; // prints 3 } Figure 7.10 demonstrates the execution of this code.
Stackmain0x10003a0x10045bswap_pointed0x10100x1004y0x10183tmp0x10080x1000x*x = *yStack*y = tmpStackmain0x10003a0x10045bswap_pointed0x10100x1004y0x10183tmp0x10080x1000x5main0x10005a0x10045bswap_pointed0x10100x1004y0x10183tmp0x10080x1000x3 Figure 7.10: Pointers enable redirection, allowing a function to modify objects in a different scope. Referencescanalsobeusedtoindirectlyrefertootherobjects.However,apointeractuallyholdstheaddressofanother object, while a reference just acts as another name for an existing object.A reference must be initialized to refer to anotherobject,andtheassociationbetweenthereferenceanditsobjectcannotbebroken.Ontheotherhand,apointer need not be initialized to point to an object, and the address value it holds can be later changed to be the address of a different object.A pointer can be null or have an undefined value, so it must be used carefully to avoid undefined behavior.
Ontheotherhand,whileitispossibletoconstructaninvalidreference,itusuallydoesnotoccurinthenormal course of programming in C++. Bothpointersandreferencesallowobjectstobeusedacrossscopes.Theybothenable subtypepolymorphism ,aconcept we will see later in the course.Both can also be used to refer to objects in dynamic memory , as we will also see later.Pointersarestronglyconnectedtoarrays.Indexingintoanarrayactuallyworksthrough pointerarithmetic ,aswewill seelater.7.1.Pointers 33 CHAPTER EIGHT MACHINE MODEL II 8.1 Pointer Errors A pointer is an atomictype, since it cannot be subdivided into smaller objects.
As with other atomic types, a variable of pointer type that isn’t explicitly initialized is default initialized to an undefined value: intx = 3; int*ptr; // undefined value ptr = &x; // well-defined value -- the address of x Dereferencingadefault-initializedpointerresultsinundefinedbehavior–theprogrammaycrash,oritmaynot;reading the dereferenced value can result in zero, or some other random value. Undefined behavior is notoriously difficult to debug,asthebehaviorcanbedifferentondifferentmachinesorindifferentrunsoftheprogramonthesamemachine.Tools like Valgrind or an address sanitizer can help detect undefined behavior.
The following is another example of default initializing pointers: intmain() { int*x; int*y; inta = -1; x = &a; cout << *x << endl; // prints -1 *x = 42; cout << a << endl; // prints 42 *y = 13; // UNDEFINED BEHAVIOR } Stackmain0x1008?y0x1010-1ax = &a0x1000?xStackmain0x1008?y0x1010-1a0x10000x1010x*x = 42*y = 13?Stackmain0x1008?y0x101042a0x10000x1010x Figure 8.1: Dereferencing an uninitialized pointer results in undefined behavior. Figure8.1illustratestheexecutionofthiscode.Both xandyaredefaultinitializedtoindeterminatevalues.Thecode 34 Programming and Data Structures, Release 0.3 proceedstoassigntheaddressof aintox,soxnowhasawell-definedvalue,anditisvalidtodereference x.Assigning totheobjectitispointingatchangesthevalueofthatobject,theonenamedby a.Dereferencing y,ontheotherhand, producesundefinedbehavior,sinceitsvalueisajunkaddress.Theprogrammaycrash,oritmaynot.Itmayoverwrite a memory location that is in use by something else, or some location that is not in use.
With undefined behavior, anything is possible. Anullpointer isapointerthatholdsanaddressvalueof 0x0.Noobjectcanbelocatedatthataddress,makingthenull value a useful value for a pointer that does not point to a valid object.In C++, the nullptr literal represents the null value, and it can be used with any pointer type: int*ptr1 = nullptr; double*ptr2 = nullptr; cout << (ptr1 == nullptr) << endl; // prints 1 (i.e.true) Dereferencinganullpointeralsoresultsinundefinedbehavior.However,inmostimplementations,doingsowillcrash the program, which is generally easier to debug than other forms of undefined behavior.A null pointer is sometimes used to indicate the lack of a value, as in the following: // EFFECTS: Returns a pointer to the first string in vec of the given // length, or a null pointer if no such string is in vec.
string * find_by_length(vector<string> &vec, intlength) { for(size_ti = 0; i < vec.size(); ++i) { if(vec[i].size() == length) { return&vec[i]; } } return nullptr ;// no string of given length } intmain() { vector<string> v = { "hello", "world", "from", "EECS", "280" }; string *found = find_by_length(v, 3); if(found) { // null pointer has false value cout << "found string: " << *found << endl; }else{ cout << "no such string" << endl; } } Inthisexample,the find_by_length() functionreturnsapointertoastringofthegivenlength. However,ifnosuch string exists, the function returns a null pointer to indicate this.The caller must check whether the return value is null before attempting to dereference it.Since a pointer is an object in its own right, it can live past the lifetime of the object it is pointing at.The following is an example: int* get_address( intx) { return&x; } voidprint( intval) { cout << val << endl; } (continues on next page) 8.1.
Pointer Errors 35 Programming and Data Structures, Release 0.3 (continued from previous page) intmain() { inta = 3; int*ptr = get_address(a); print(42); cout << *ptr << endl; // UNDEFINED BEHAVIOR } Stackmain0x10003a0x1004?ptrget_address0x100c3xreturn &xStackmain0x10003a0x10040x100cptrget_address0x100c3xprint(42)Stackprint0x100c42valmain0x10003a0x10040x100cptr Figure 8.2: A pointer may refer to a dead object, in which case dereferencing it produces undefined behavior. In this code, the parameter of the get_address() function is passed by value.So the xparameter is a new object in theactivationrecordfor get_address() ,anditisinitializedasacopyof a.Thefunctionreturnstheaddressof x,and thatvalueisplacedinthe ptrobjectinmain().However, xdiesalongwiththeactivationrecordof get_address() , soptris now pointing at a dead object.The code then calls print(), and it so happens that its activation record is placedinthesamelocationpreviouslyusedby get_address() ,asshowninFigure8.2.
Atthispoint, ptrhappensto pointatthe valobject,whosevalueis42. Whenthe print() functionreturns,itsactivationrecordisalsoreclaimed.Proceeding to dereference ptrproduces undefined behavior.It so happens in this implementation that 42 is printed, but other implementations may have different behavior.We can fix the code above by passing the parameter to get_address() by reference: int* get_address( int&x) { return&x; } voidprint( intval) { cout << val << endl; } intmain() { inta = 3; int*ptr = get_address(a); print(42); cout << *ptr << endl; // prints 3 } Nowxaliasestheobject ainmain(),asshowninFigure8.3.Thus, get_address() returnstheaddressof a,which is still alive when *ptris printed.8.1.Pointer Errors 36 Programming and Data Structures, Release 0.3 Stackmain0x10003a0x1004?ptrget_addressxStackmain0x10003a0x10040x1000ptrget_addressxreturn &x Figure 8.3: Example of taking the address of a reference parameter.
8.2 Function Calls and the Call Stack Previously, we saw a basic machine model in which the program places each object at a different location in mem- ory. We now examine a more structured model, stack-based memory management, that is used by many language implementations.Inmostimplementations,thedataforafunctioncallarecollectivelystoredwithinan activationrecord ,whichcontains space for each of the function’s parameters and local variables, temporary objects, the return address, and other items thatareneededbythefunction.Inthiscourse,wewillgenerallyonlyconsidertheparametersandlocalvariablesinan activation record, ignoring the other pieces of data there.Instack-basedmemorymanagement,activationrecordsarestoredinadatastructurecalleda stack.Astackworksjust likeastackofpancakes: whenanewpancakeismade,itisplacedontopofthestack,andwhenapancakeisremoved fromthestack,itisthetoppancakethatistakenoff.Thus,thelastpancaketobemadeisthefirsttobeeaten,resulting inlast-in, first-out (LIFO) behavior.
Activation records are similarly stored: when an activation record is created, it is placedontopofthestack,andthefirstactivationrecordtobedestroyedisthelastonethatwascreated. Thisgivesrise to an equivalent term stack frame for an activation record.As an example, consider the following program: voidbar() { } voidfoo() { bar(); } intmain() { foo(); } When the program is run, the main()function is called, so an activation record is created and added to the top of the stack.Then main()callsfoo(), which places an activation record for foo()on the top of the stack.Then bar()is called,soitsactivationrecordisputonthestack.When bar()returns,itsactivationrecordisremovedfromthestack.Thenfoo()completes,removingitsactivationrecord.Finally,theactivationrecordfor main()isdestroyedwhenthe function returns.Figure 8.4 shows the state of the stack after each call and return.
In many implementations, the stack is actually stored upside down in memory, so that it grows downward rather than upward as shown in Figure 8.5. However, it still has the same LIFO behavior as a right-side-up stack.As a more complex example, consider the following program: 8.2.Function Calls and the Call Stack 37 Programming and Data Structures, Release 0.3 StackfoomainStackbarfoomainStackfoomainStackmainStackmainStackStackmain()foo()bar()returnreturnreturn Figure 8.4: A stack that stores activation records.Stackmainfoobarmain()foo()bar()returnreturnreturnStackmainfooStackmainfooStackmainStackStackmainStack Figure 8.5: A stack that grows downward rather than upward.intplus_one( intx) { returnx + 1; } intplus_two( intx) { returnplus_one(x + 1); } intmain() { intresult = 0; result = plus_one(0); result = plus_two(result); cout << result; // prints 3 } At program startup, the main()function is called, creating an activation record that holds the single local variable result.
The declaration of resultinitializes its value to 0, and the program proceeds to call plus_one(0) . This creates an activation record for plus_one() that holds the parameter x.The program initializes the value of xto the argument value 0 and runs the body of plus_one() .The body computes the value of x + 1by obtaining the value ofxandadding1toit,resultinginavalueof1,whichthefunctionthenreturns.Thereturnvaluereplacestheoriginal call toplus_one(0) , and the activation record for plus_one is discarded before main()proceeds.The code then assigns the return value of 1 to result.Figure 8.6 illustrates the activation records up to this point.The program then proceeds to call plus_two(result) .First,resultis evaluated to obtain the value 1.Then an activation record is created for plus_two() , with space for its parameter x.
Observe that this activation record is located in memory where the previous activation record for plus_one() was – the latter is no longer in use, so the memory can be reused. After the new activation record is created, the parameter xis initialized with the argument value 1.Then the program runs the body of plus_two() .The body of plus_two() in turn calls plus_one(x + 1) .This evaluates x + 1to obtain the value 2, creates an activationrecordfor plus_one() ,initializesthevalueof xinthenewactivationrecordtobe2,andthenrunsthebody ofplus_one() .The state of memory at this point is shown in Figure 8.7.8.2.Function Calls and the Call Stack 38 Programming and Data Structures, Release 0.3 Stackmain0x10000resultStackmain0x10000resultplus_one0x10040xStackmain0x10001resultplus_one()return Figure 8.6: Activation record for plus_one() .
Stackmain0x10001resultStackmain0x10001resultplus_two0x10041xStackmain0x10001resultplus_two()plus_one()plus_two0x10041xplus_one0x10082x Figure 8.7: State of stack in second call to plus_one() . Observe that the new activation record for plus_one() is distinct from the previous one – each invocation of a func- tion gets its own activation record.In addition, there are now two variables xin the program.Within the scope ofplus_one() ,xrefers to the object located in the activation record for plus_one() , and its value is 2.Within plus_two() ,xrefers to the object in the activation record for plus_two() , and its value is 1.The invocation of plus_one() computes 3 as its return value, so that value replaces the call to plus_one() , and the activationrecordfor plus_one() isdiscarded.plus_two() returnsthatsamevalue3,sothevalue3replacesthecall toplus_two() inmain(), and the activation record for plus_two() is discarded.Then main()proceeds to assign the value 3 to resultand print it out.
Finally, when main()returns, its activation record too is discarded. 8.2.1 Function-Call Process To summarize, the following steps occur in a function call: 1.For pass-by-value parameters, the argument expressions are evaluated to obtain their values.Forapass-by-referenceparameter,thecorrespondingargumentexpressionisevaluatedtoobtainanobject1rather than its value.The order in which arguments are evaluated is unspecified in C++.2.Anewanduniqueactivationrecordiscreatedforthecall,withspaceforthefunction’sparameters,localvariables, and metadata.The activation record is pushed onto the stack.3.The parameters are passed, using the corresponding arguments to initialize the parameters.For a pass-by-value parameter, the corresponding argument value is copied into the parameter.For a pass-by-reference parameter, 1C++allowsreferencesto consttobindtovalues(i.e.rvaluesinprogramming-languageterms)ratherthanobjects(lvalues).
Soareferenceof typeconst int & can bind to just the value 3, as in const int &ref = 3; . 8.2.Function Calls and the Call Stack 39 Programming and Data Structures, Release 0.3 the parameter is initialized as an alias of the argument object.4.Thebodyofthecalledfunctionisrun.Thistransferofcontrolisoftencalled activeflow ,sincethecodeactively tells the computer which function to run.5.Whenthecalledfunctionreturns,ifthefunctionreturnsavalue,thatvaluereplacesthefunctioncallinthecaller.6.The activation record for the called function is destroyed.In simple cases, implementations will generally just leave in memory what is already there, simply marking the memory as no longer in use.7.Executionproceedsfromthepointofthefunctioncallinthecaller.Thistransferofcontrolisoftencalled passive flow, since the code does not explicitly tell the computer which function to run.
The following program is an example of pass by reference: voidswap( int&x, int&y) { inttmp = x; x = y; y = tmp; } intmain() { inta = 3; intb = 7; cout << a << ", " << b << endl; // prints 3, 7 swap(a, b); cout << a << ", " << b << endl; // prints 7, 3 } Theprogramstartsbycreatinganactivationrecordfor main(),withspaceforthelocalvariables aandb. Itinitializes ato3andbto7andthenprintsouttheirvalues.Theprogramthencalls swap(a, b) ,whichevaluatestheexpressions aandbtoobtaintheirobjects,createsanactivationrecordfor swap(),andinitializestheparametersfromtheargument objects.Sincethetwoparametersarereferences,theactivationrecorddoesnotcontainuser-accessiblememoryforthe parameters.(The metadata for the function, however, may include information about the parameters.) The activation record does contain explicit space for the local variable tmp, since it is not a reference.Figure 8.8 illustrates the activation record.
Stackmain0x10047b0x10003aswapyx0x1018tmp Stackmain0x10047b0x10003aswapyx0x10183tmp Stackmain0x10047b0x10007aswapyx0x10183tmp Stackmain0x10043b0x10007aswapyx0x10183tmptmp= xx = yy = tmp Figure 8.8: Activation record for a function that uses pass by reference. Here, the reference parameters are depicted with a dotted line between the names and the objects they reference.Theprogramproceedstorunthebodyof swap().First,tmpisinitializedtothevalueof x–sincexreferstothesame objectasainmain(),thevalue3ofthatobjectiscopiedintothememoryfor tmp.Thentheassignment x = ycopies 8.2.Function Calls and the Call Stack 40 Programming and Data Structures, Release 0.3 the value 7 from the object associated with y(binmain()) to the object associated with x(ainmain()).Finally, the assignment y = tmp copies the value 3 from tmpinto the object associated with y(binmain()).Whenswap() returns,itsactivationrecordisdestroyed,andexecutioncontinuesin main().
Thelatterprintsoutthenewvaluesof7 and 3 foraandb, respectively. A function can also return an object by reference, though we need to ensure that the lifetimeof the object extends beyond the function invocation.The following is an example: int& larger( int&x, int&y) { if(y > x) { returny; } returnx; } intmain() { inta = 3; intb = 7; cout << a << ", " << b << endl; // prints 3, 7 larger(a, b) = -1; cout << a << ", " << b << endl; // prints 3, -1 } The calllarger(a, b) returns the object aorbwhose value is larger, and we then assign the new value -1 to this object.If larger() were to return by value instead, attempting to assign to the resulting value would result in a compiler error.Returning by reference is most common in data structures, where we wish to access an element by reference.For instance, this is how the indexing (or subscript) operator works on a vector: std::vector< int> data = /* ...
*/ ; data[0] = -1; This operator is implemented using operator overloading , which we will discuss later. 8.2.Function Calls and the Call Stack 41 Part II Data Abstraction 42 CHAPTER NINE THE CONSTKEYWORD Theconstkeywordisa typequalifier inC++thatallowsustopreventanobjectfrombeingmodified.Asanexample, consider the following erroneous definition of strcpy() : voidstrcpy( char*dst, const char *src) { while(*src != '\0') { *src = *dst; ++src; ++dst; } *src = *dst; } In this definition, the assignments are backwards – the code is attempting to modify the source string rather than the destination.However,becausethe srcparameterwasdeclaredwithtype const char * ,thecompilerwilldetectthis error: $ g++ --std=c++17 strcpy.cpp strcpy.cpp:3:10: error: read-only variable is not assignable *src = *dst; ~~~~ ^ strcpy.cpp:7:8: error: read-only variable is not assignable *src = *dst; ~~~~ ^ 2 errors generated.
A variable declared as constcan be initialized, but its value cannot be later modified through an assignment. For a simple type, the constkeyword may appear on either side of the type: const int x = 3; // initialization is OK int const y = 4; // const can go on the right as well x = y; // ERROR: attempt to assign to const object Only types with values may be declared as const.The following types do not have values: •References; they alias objects that may have values but do not have values of their own.•Arrays; we will see arrays later in the course.•Functions; we will see function types later in the course.43 Programming and Data Structures, Release 0.3 9.1 References and const We saw previously that the binding between a reference and the object it aliases is established at initialization, and it cannot be broken as long as the reference exists.Thus, it is not meaningful for a reference itself to be const.
Whileareferencedoesnothaveavalueandthuscannotbedeclaredas constitself,itcanrefertoanobjectwith const type. The constkeyword can appear to the left of the &in a reference type, as in const int & – this is read “inside out” as “reference to a constant int”.The object the reference is aliasing is not modifiable through the reference: intx = 3; const int &ref1 = x; // reference to const int int const &ref2 = x; // const can go on the right of int as well ref1 = 4; // ERROR -- attempt to assign to const object However, the original object is still modifiable if there is a non-const way to refer to it: intx = 3; int&ref1 = x; const int &ref2 = x; x = 4; // OK -- x not declared as const ref1 = 5; // OK -- ref1 a reference to a non-const int ref2 = -6; // ERROR -- ref2 a reference to a const int The example above has three names that refer to the same object.However, the object is only modifiable through the names that do not include the constkeyword.
In the two previous examples, we have created reference-to-const aliases for a non-const object. We will see shortly that non-const to const conversions are allowed, but the other direction is prohibited.9.2 Pointers and const Pointers do have a value, so they can be declared as const.To do so, the constkeyword is placed to the right of the *: intx = 3; inty = 4; int*constptr = &x; *ptr = -1; // OK -- ptr is pointing to a non-const int ptr = &y; // ERROR -- attempt to assign to const object Reading the declaration of ptrinside out, we get “ ptris a constant pointer to an int.” Thus, we cannot modify the value ofptritself.However, since the type that ptris pointing to (what is to the left of the *) is not const, we can modify the object that ptris pointing to.
Similartoareference,wecandeclarethattheobjectthatapointerispointingtoisconstbyplacingthe constkeyword to the left of the *: intx = 3; inty = 4; const int * ptr = &x; // equivalent: int const *ptr = &x; ptr = &y ; // OK -- ptr is not const, so we can change its value *ptr = -1; // ERROR -- attempt to assign to const object Finally, we can declare that both the pointer itself and the object it is pointing to are const: 9.1. References and const 44 Programming and Data Structures, Release 0.3 intx = 3; inty = 4; const int *constptr = &x; ptr = &y ; // ERROR -- attempt to assign to const object *ptr = -1; // ERROR -- attempt to assign to const object 9.3constConversions We’ve seen examples above where we’ve constructed references-to-const and pointers-to-const objects from objects that were not declared as const.The general rule for converting between const and non-const is that the conversion must not enable modifications that are prohibited without the conversion.
Aconstobjectcanappearontheright-handsideofanassignment,sinceanassignmenthasvaluesemantics–itcopies thevaluefromtheright-handsidetotheleft-handsideobject. Thus,itdoesnotpermittheconstobjecttobemodified: const int x = 3; inty = x; // OK -- copies value from x; does not enable x to be modified On the other hand, if we initialize a reference-to-non-const with a const object, we would enable the object to be modified through the reference.
Thus, such a conversion is prohibited: const int x = 3; int&ref = x; // ERROR -- enables const object to be modified through ref ref = 4; // would modify the x object if the above were allowed The same goes for placing the address of a const object in a pointer-to-non-const: const int x = 3; int*ptr = &x; // ERROR -- enables const object to be modified through ptr *ptr = 4; // would modify the x object if the above were allowed Theotherdirectionisallowed,however: creatingareference-to-constorpointer-to-constfromanon-constobjectdoes not enable any new modifications: intx = 3; int const &ref = x; // OK -- does not permit const object to be modified const int *ptr = &x; // OK -- does not permit const object to be modified The compiler only reasons about each conversion in isolation.
This means that it does not allow a conversion from const to non-const even if we have some other means of modifying the underlying object: intx = 3; int*ptr1 = &x; // OK -- does not permit const object to be modified const int *ptr2 = ptr1; // OK -- does not permit const object to be modified ptr1 = ptr2; // ERROR -- compiler sees that ptr2 is pointing to a // a const object, but ptr1 is not a pointer // to const Intheexampleabove,eventhough ptr2wasoriginallyinitializedfrom ptr1,wecannotlaterassignthevalueof ptr2 toptr1, since it would be converting a pointer-to-const to a pointer-to-non-const. This is actually useful for us as programmers: ifwepassapointertoanotherfunction,andthefunctionguaranteesthatitwon’tmodifythepointed-to 9.3.
constConversions 45 Programming and Data Structures, Release 0.3 object by declaring its parameter as pointer-to-const, then we would be unhappy if the function could convert it back to a pointer-to-non-const and modify the pointed-to object.1 1C++ has a const_cast that enables constto be removed or added. However, it is only used in exceptional cases, none of which are relevant to this course.9.3.constConversions 46 CHAPTER TEN STRUCTS C++ has several different categories of objects: •Atomictypes are built into the language, and these types are atomic because their objects cannot be subdivided into smaller objects.Atomic types are also known as primitive types.Examples of atomic types include basic numeric types such as int,double,bool, andchar, as well as pointer types (e.g.int *,string * ).•Arraysare contiguous sequences of objects of the same type.They are therefore composed of homogeneous subobjects.We will discuss arrayslater in the course.
•Class-type objectsareobjectscomposedofmembersubobjects,eachwhichmaybeofadifferenttype. Class-type objects are thus heterogeneous , and they are also often called compound objects .In C++, a class type is introduced through the structorclasskeyword.We will use the two keywords for different conventions when introducing our own data types.Later, we will see that the actual distinction between how C++ treats the two keywords is minimal.Inordertointroduceanewdatatype,weusethe structkeyword,followedbythenameofthetypeweareintroducing, followed by a body with member declarations : struct Person { string name; intage; boolis_ninja; }; Here, we are introducing a Persontype.The body contains declarations for three member variables , each with their own type and name.The semicolon after the struct definition is mandatory, unlike in some other languages.After the struct definition, we can create objects that have Persontype.
The following program creates two local variables of type Person: intmain() { Person elise; Person tali; } EachPersonobject has its own subobjects name,age, andis_ninja located within the memory for the Person object, as shown in Figure 10.1. Sincewedidnotexplicitlyinitializethe Personobjects,theyaredefaultinitializedbyinturndefaultinitializingtheir membersubobjects.The ageandis_ninja membersareofatomictype,sotheyaredefaultinitializedtoindeterminate values.The namememberisofclasstype,anditisdefaultinitializedtoanemptystring.Inthefuture,wewillseethat class types can specify how they are initialized .47 Programming and Data Structures, Release 0.3 Stack0x1038?age0x103c?is_ninja0x1020""namePerson0x1018?age0x1000""namemain taliPersonelise0x101c?is_ninja Figure 10.1: Memory for two objects of Persontype.
We can explicitly initialize a Personobject with an initializer list, similar to how we can initialize the elements of a vector: Person elise = { "Elise", 22, true }; This initializes the struct member-by-member from the initializer list: the namemember is initialized with "Elise", theagemember is initialized with 22, and theis_ninja member is initialized with true. If fewer initializers are provided than members, the remaining members are implicitly initialized (with zeros for atomic types).We can also copy structs when initializing a new struct or assigning to an existing one: Person tali = elise; By default, copying a struct copies the members one by one.2The result in memory is illustrated in Figure 10.2.We can access individual members of a struct with the dot ( .) operator.The struct object goes on the left-hand side, and the member name on the right: tali.name = "Tali"; Here, we have assigned the string "Tali"to thenamemember of the taliobject.
Figure 10.3 shows the result in memory. As the figure shows, taliandeliseeach have their own namemembers, so that modifying one does not affect the other.Wecanuseaninitializerlistforastructincontextsotherthaninitialization.Thefollowingusesaninitializerlistinan assignment(whichisdifferentfromaninitialization,sincethetargetobjectalreadyexists),aswellasanargumenttoa function: voidPerson_print_name(Person person) { cout << person.name << endl; (continues on next page) 2We will see in the future that we can customize how class types are copied by overloading the copy constructor andassignment operator .48 Programming and Data Structures, Release 0.3 Stack0x103822age0x103ctrueis_ninja0x1020"Elise"namePerson0x101822age0x1000"Elise"namemain taliPersonelise0x101ctrueis_ninja Figure 10.2: By default, copying a class-type object copies each of the member variables.
Stack0x103822age0x103ctrueis_ninja0x1020"Tali"namePerson0x101822age0x1000"Elise"namemain taliPersonelise0x101ctrueis_ninja Figure 10.3: The result of modifying an individual member variable. 49 Programming and Data Structures, Release 0.3 (continued from previous page) } intmain() { Person tali; tali = { "Tali", 21, true }; // in an assignment Person_print_name({ "Elise", 22, true }); // as argument to function } When passing a struct to a function, we have our usual default of value semantics, meaning that a copy is made.For instance, the following erroneous definition of Person_birthday() does not modify the argument object, since it receives a copy of the argument: // MODIFIES: person // EFFECTS: Increases the person 's age by one.If they are now older // than 70, they are no longer a ninja.
voidPerson_birthday(Person person) { ++person.age; if(person.age > 70) { person.is_ninja = false; } } Figure 10.4 illustrates what happens when we call Person_birthday() on aPersonobject: StackmainPerson_birthdayPerson0x103822age0x1020"Elise"nameperson0x103ctrueis_ninja23Person0x101822age0x1000"Elise"nameelise0x101ctrueis_ninja Figure 10.4: Passing a class-type object by value produces a copy that lives in the activation record of the callee. The modification happens on a Personobject that lives in the activation record for Person_birthday() .This copy will die when Person_birthday() returns, and the object that lives in main()is unchanged.Instead,weneedtopassthestructindirectly,eitherusingareferenceorapointer.Thefollowingusesapointer,andits execution is shown in Figure 10.5: 50 Programming and Data Structures, Release 0.3 // REQUIRES: ptr points to a valid Person object // MODIFIES: *ptr // EFFECTS: Increases the person 's age by one.
If they are now older // than 70, they are no longer a ninja. voidPerson_birthday(Person *ptr) { ++(*ptr).age; if((*ptr).age > 70) { (*ptr).is_ninja = false; } } Stackmain0x10200x1000ptrPerson_birthdayPerson0x101822age0x1000"Elise"nameperson0x101ctrueis_ninja23 Figure 10.5: Passing a pointer to a class-type object avoids making a copy of that object.The code uses the *operator to dereference the pointer, then uses the .operator to access a member of the resulting Personobject.Theparenthesesaroundthedereferencearerequiredbecausethepostfix .hashigherprecedencethan the prefix *.C++ provides the ->operator as a shorthand for dereference followed by member access.The following definition of Person_birthday() is equivalent to the one above: voidPerson_birthday(Person *ptr) { ++ptr->age; if(ptr->age > 70) { ptr->is_ninja = false; } } Of course, this one is nicer to read and to write, so we should make use of the ->operator when possible.
ThePerson_birthday() function needs to modify the underlying Personobject, so we cannot declare the Person asconst. Ifafunctiondoesnotneedtomodifytheunderlyingobject,thenitshouldbedeclaredas const.Declaring a struct as constprevents any of its members from being modified.// REQUIRES: ptr points to a valid Person object // MODIFIES: nothing // EFFECTS: Prints a one-sentence description of the person voidPerson_describe( constPerson *ptr) { (continues on next page) 51 Programming and Data Structures, Release 0.3 (continued from previous page) cout << ptr->name << " is " << ptr->age << " years old and "; if(ptr->is_ninja) { cout << "is a ninja!" << endl; }else{ cout << "is not a ninja." << endl; } } Except for very small structs, we generally do not pass structs by value, since creating a copy of a large struct can be expensive.Instead, we pass them by pointer or by reference.If the original object needs to be modified, we use a pointer or reference to non-const.
Otherwise, we use a pointer or reference to const: voidfunc_ptr( constPerson *p); // const can go on either side of voidfunc_ref(Person const&p); // Person, but must be to the left // of * or & for the Person itself // to be non-modifiable 10.1 Compound Objects and const Since a class-type object has a value, it can be declared as const, which prevents any of its members from being modified. As an example, consider the following struct definition: struct Foo { intnum; int*ptr; }; Like anyconstobject, aconst Foo must be initialized upon creation: intmain() { intx = 3; constFoo foo = { 4, &x }; ...} Fooptr0x10000x1008num40x1004fooStackmainx30x1000 Figure 10.6: Contents of a Fooobject.Declaring the object as constonly prohibits modifications to the subobjects contained within the memory for the object.10.1.
Compound Objects and const 52 Programming and Data Structures, Release 0.3 Withfoodeclared as const, attempting to modify any of its members results in a compile error: foo.num = -1; // ERROR ++foo.ptr; // ERROR Modifications cannot be made to any of the subobjects that live within the memory of an object declared const.3 On the other hand, it is possible to modify the object that foo.ptr points to: *foo.ptr = -1; cout << x; // prints -1 Sincefooisconst,foo.ptr is a const pointer, and the expression has type int * const . This means it is not a pointer to const, so modifying the value of the object it is pointing at is allowed.Looking at it another way, the object xlives outside the memory for foo, so the fact that fooisconsthas no effect on whether or not xcan be modified through a pointer that lives within foo.3A member can be declared mutable, which allows it to be modified even if the object that contains it is const.10.1.
Compound Objects and const 53 CHAPTER ELEVEN ABSTRACT DATA TYPES IN C Recall that abstraction is the idea of separating whatsomething is from howit works, by separating interface from implementation. Previously, we saw procedural abstraction , which applies abstraction to computational processes.With procedural abstraction, we use functions based on their signature and documentation without having to know details about their definition.Theconceptofabstractioncanbeappliedtodataaswell.An abstractdatatype(ADT) separatestheinterfaceofadata typefromitsimplementation,anditencompassesboththedataitselfaswellasfunctionalityonthedata.
Anexample of an ADT is the stringtype in C++, used in the following code: string str1 = "hello"; string str2 = "jello"; cout << str1 << endl; if(str1.length() == str2.length()) { cout << "Same length!" << endl; } This code creates two strings and initializes them to represent different values, prints out one of them, and compares thelengthsofboth–allwithoutneedingtoanydetailsabouttheimplementationof string. Rather,itreliessolelyon the interface provided by the stringabstraction.Astringisanexampleofafull-featuredC++ADT,providingcustomizedinitialization,overloadedoperationssuchas thestream-insertionoperator,memberfunctions,andsoon.WewillstartwiththesimplermodelofCADTs,deferring C++ ADTs until next time.The C language only has support for structs with data members (i.e.member variables).While this is sufficient to represent the data of an ADT, the functions that operate on the ADT must be defined separately from the struct.
The following is the data definition of an ADT to represent triangles: // A triangle ADT. struct Triangle { doublea; doubleb; doublec; }; intmain() { Triangle t1 = { 3, 4, 5 }; Triangle t2 = { 2, 2, 2 }; } TheTriangle structcontainsthreemembervariables,oneforeachsideofthetriangle,eachrepresentedbya double.The example in main()creates and initializes two Triangle structs, resulting in the memory layout in Figure 11.1.54 Programming and Data Structures, Release 0.3 StackTriangle0x10202.0b0x10282.0c0x10182.0a0x10084.0b0x10105.0c0x10003.0amaint1t2Triangle Figure 11.1: Two local Triangle objects.AnADTalsoincludesfunctionsthatoperateonthedata.Wecandefinefunctionstocomputetheperimeterofatriangle or to modify it by scaling each of the sides by a given factor: // REQUIRES: tri points to a valid Triangle // EFFECTS: Returns the perimeter of the given Triangle.
doubleTriangle_perimeter( constTriangle *tri) { returntri->a + tri->b + tri->c; } // REQUIRES: tri points to a valid Triangle; s > 0 // MODIFIES: *tri // EFFECTS: Scales the sides of the Triangle by the factor s. voidTriangle_scale(Triangle *tri, doubles) { tri->a *= s; tri->b *= s; tri->c *= s; } Our naming convention for functions that are part of a C-style ADT is to prepend the function name with the name of theADT,Triangle inthiscase.Thefirstparameterisapointertotheactual Triangle objectthefunctionworkson.If the object need not be modified, we declare the pointer as a pointer to const.The following demonstrates how to use the Triangle ADT functions: intmain() { Triangle t1 = { 3, 4, 5 }; Triangle_scale(&t1, 2); // sides are now 6, 8, 10 cout << Triangle_perimeter(&t1) << endl; // prints 24 } The code creates a Triangle as a local variable and initializes it with sides 3, 4, and 5.It then scales the sides by a factor of 2 by calling Triangle_scale() .
Since that function takes a pointer to the actual triangle, we use the address-of operator to obtain and pass the address of t1, as shown in Figure 11.2. 55 Programming and Data Structures, Release 0.3 Stackmain0x10202.0sTriangle_scale0x10180x1000triTriangle0x10084.0b0x10105.0c0x10003.0at1 Figure 11.2: Passing a pointer to a Triangle object.The function scales each side of the triangle, resulting in t1having sides of 6, 8, and 10.We then call Triangle_perimeter() on the address of t1, which computes the value 24.In this example, the code in main()need not worry about the implementation of Triangle_scale() or Triangle_perimeter() .Instead, it relies on abstraction, using the functions for what they do rather than how they doit.However,ininitializing t1itself,thecode isrelyingonimplementationdetails–specifically,thata Triangle is implemented as three doublemembers that represent the lengths of the sides.
If the implementation were to change to represent a triangle as two sides and the angle between them, for instance, then the behavior of the code in main() would change, and it would no longer print 24. Thus, we need to abstract the initialization of a Triangle , avoiding having to initialize each member directly.We do so by defining a Triangle_init() function: // REQUIRES: tri points to a Triangle object // MODIFIES: *tri // EFFECTS: Initializes the triangle with the given side lengths.voidTriangle_init(Triangle *tri, doublea_in, doubleb_in, doublec_in) { tri->a = a_in; tri->b = b_in; tri->c = c_in; } intmain() { Triangle t1; Triangle_init(&t1, 3, 4, 5); Triangle_scale(&t1, 2); cout << Triangle_perimeter(&t1) << endl; } The user of the Triangle ADT creates an object without an explicit initialization and then calls Triangle_init() onitsaddresstoinitializeit,providingthesidelengths.Afterthatcall,the Triangle hasbeenproperlyinitializedand can be used with the other ADT functions.
Now if the implementation of Triangle changes, as long as the interface remainsthesame,thecodein main()willworkasbefore. ThecodewithintheADT,inthe Triangle_...functions, will need to change, but outside code that uses the ADT will not.The following illustrates an implementation of Triangle that represents a triangle by two sides and an angle: 56 Programming and Data Structures, Release 0.3 // A triangle ADT.struct Triangle { doubleside1; doubleside2; doubleangle; }; // REQUIRES: tri points to a Triangle object // MODIFIES: *tri // EFFECTS: Initializes the triangle with the given side lengths.voidTriangle_init(Triangle *tri, doublea_in, doubleb_in, doublec_in) { tri->side1 = a_in; tri->side2 = b_in; tri->angle = std::acos((std::pow(a_in, 2) + std::pow(b_in, 2) - std::pow(c_in, 2)) / (2 * a_in * b_in)); } // REQUIRES: tri points to a valid Triangle // EFFECTS: Returns the first side of the given Triangle.
doubleTriangle_side1( constTriangle *tri) { returntri->side1; } // REQUIRES: tri points to a valid Triangle // EFFECTS: Returns the second side of the given Triangle. doubleTriangle_side2( constTriangle *tri) { returntri->side2; } // REQUIRES: tri points to a valid Triangle // EFFECTS: Returns the third side of the given Triangle.doubleTriangle_side3( constTriangle *tri) { returnstd::sqrt(std::pow(tri->side1, 2) + std::pow(tri->side2, 2) - 2 * tri->side1 * tri->side2 * std::acos(tri->angle)); } // REQUIRES: tri points to a valid Triangle // EFFECTS: Returns the perimeter of the given Triangle.doubleTriangle_perimeter( constTriangle *tri) { returnTriangle_side1(tri) + Triangle_side2(tri) + Triangle_side3(tri); } // REQUIRES: tri points to a valid Triangle; s > 0 // MODIFIES: *tri // EFFECTS: Scales the sides of the Triangle by the factor s.
voidTriangle_scale(Triangle *tri, doubles) { tri->side1 *= s; tri->side2 *= s; } 57 Programming and Data Structures, Release 0.3 Here,wehaveadded accessororgetterfunctionsforeachofthesides,allowingausertoobtainthesidelengthswithout needing to know implementation details. Even within the ADT itself, we have used Triangle_side3() from within Triangle_perimeter() to avoid code duplication.The REQUIRES clauses of the ADT functions make a distiction between Triangle objects and validTriangle ob- jects.Theformerreferstoanobjectthatisoftype Triangle butmaynothavebeenproperlyinitialized,whilethelatter refers to a Triangle object that has been initialized by a call to Triangle_init() .Except for Triangle_init() , the ADT functions all work on valid Triangle s.
Now that we have a full definition of a C-style ADT, we adhere to the following convention for working with one: the user of a C-style ADT may only interact with the ADT through its interface, meaning the functions defined as part of the ADT’s interface. The user is generally prohibited from accessing struct member variables directly, as those are implementation details of the ADT.This convention also holds in testing an ADT , since tests should only exercise the behavior of an ADT and not its implementation.11.1 Representation Invariants Whendesigninganabstractdatatype,wemustbuildadatarepresentationontopofexistingtypes.Usually,therewill becaseswheretheunderlyingdatarepresentationpermitscombinationsofvaluesthatdonotmakesenseforourADT.Forexample,noteverycombinationofthree doublesrepresentsavalidtriangle–a doublemayhaveanegativevalue, butatrianglemaynothaveasidewithnegativelength.
Thespaceofvaluesthatrepresentvalidinstancesofatriangle abstraction is a subset of the set of values that can be represented by three doubles, as illustrated in Figure 11.3. (3,4,5)(4,5,8.3)(4,5,9)(−3,4,5)345Representation type (a,b,c)Abstract type representation invariant Figure 11.3: Representation invariants define the valid subset of the values allowed by the data representation of an ADT.Thus,whendesigninganADT,weneedtodeterminethesetofvaluesthatarevalidfortheADT.Wedosobyspecifying representationinvariants forourADT,whichdescribetheconditionsthatmustbemetinordertomakeanobjectvalid.For a triangle represented as a doublefor each side, the following representation invariants must hold: •The length of each side must be positive.•Thetriangle inequality must hold: the sum of any two sides must be strictly greater than the remaining side.Often, we document the representation invariants as part of the ADT’s data definition: 11.1.
Representation Invariants 58 Programming and Data Structures, Release 0.3 // A triangle ADT. struct Triangle { doublea; doubleb; doublec; // INVARIANTS: a > 0 && b > 0 && c > 0 && // a + b > c && a + c > b && b + c > a }; WethenenforcetheinvariantswhenconstructingormodifyinganADTobjectbyencodingthemintotheREQUIRES clauses of our functions.We can use assertions to check for them as well, where possible: // REQUIRES: tri points to a Triangle object; // each side length is positive (a > 0 && b > 0 && c > 0); // the sides meet the triangle inequality // (a + b > c && a + c > b && b + c > a) // MODIFIES: *tri // EFFECTS: Initializes the triangle with the given side lengths.
voidTriangle_init(Triangle *tri, doublea,doubleb,doublec) { assert(a > 0 && b > 0 && c > 0); // positive lengths assert(a + b > c && a + c > b && b + c > a); // triangle inequality tri->a = a; tri->b = b; tri->c = c; } // REQUIRES: tri points to a valid Triangle; s > 0 // MODIFIES: *tri // EFFECTS: Scales the sides of the Triangle by the factor s. voidTriangle_scale(Triangle *tri, doubles) { assert(s > 0); // positive lengths tri->a *= s; tri->b *= s; tri->c *= s; } 11.2 Plain Old Data As mentioned above, we adhere to the convention of only interacting with an ADT through its interface.Usually, this meansthatwedonotaccessthedatamembersofanADTinoutsidecode.However,occasionallywehavetheneedfor an ADT that provides no more functionality than grouping its members together.Such an ADT is just plain old data (POD)4,withoutanyfunctionsthatoperateonthatdata,andwedefineitsinterfacetobethesameasitsimplementation.
The following is an example of a Pixelstruct used as a POD: // A pixel that represents red, green, and blue color values. struct Pixel { intr;// red (continues on next page) 4Weusetheterm“plainolddata”inthegenericsenseandnotasthespecificC++term.C++hasageneralizationofPODtypescalledaggregates.Technically,the PersonstructwesawlasttimeisanaggregatebutnotaPOD.WhatwementionhereforPODtypesgenerallyappliestoaggregates as well.11.2.Plain Old Data 59 Programming and Data Structures, Release 0.3 (continued from previous page) intg;// green intb;// blue }; intmain() { Pixel p = { 255, 0, 0 }; cout << p.r << " " << p.g << " " << p.b << endl; } ThePixelADTconsistsofjustadatarepresentationwithnofurtherfunctionality.SinceitisaPOD,itsinterfaceand implementation are the same, so it is acceptable to access its members directly.
11.3 Abstraction Layers As with procedural abstraction, data abstraction is also defined in layers, with each layer interacting solely with the interfaceofthelayerbelowandnotitsimplementation. Forexample,wecanrepresentanimageusingthreematrices, oneforeachcolorchannel.Anycodethatusesanimagereliesontheimageinterface,withoutneedingtoknowthatit is implemented over three matrices.Each matrix in turn can be represented using a single-dimensional vector.Code thatusesamatrixreliesonthe2Dabstractionprovidedbytheinterfacewithoutneedingtoknowthatitisimplemented as a 1D vector under the hood.
012340(0,0,0) (0,0,0) (255,255,250)(0,0,0) (0,0,0) 1(255,255,250)(126,66,0)(126,66,0)(126,66,0)(255,255,250)2(126,66,0)(0,0,0) (255,219,183)(0,0,0) (126,66,0)3(255,219,183)(255,219,183)(0,0,0) (255,219,183)(255,219,183)4(255,219,183)(0,0,0) (134,0,0) (0,0,0) (255,219,183)0123400 0 2550 0 125512612612625521260 2550 12632552550 25525542550 134 0 2550123400 0 2550 0 12556666662552660 2190 6632192190 21921942190 0 0 2190123400 0 2500 0 1250000250200 1830 031831830 18318341830 0 0 183Image"what".Image"how",using Matrix"what".0 0 2550 0 255 126 126 126255 126 0 255 0 126 255 255 0 255 255 255 0 134 0 255 0 1 23 4 5 6 7 89 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 Matrix"how". Figure 11.4: Abstraction layers for an image.11.3.Abstraction Layers 60 Programming and Data Structures, Release 0.3 11.4 Testing an ADT As mentioned previously, code outside of an ADT’s implementation must interact with the ADT solely through its interface, including test code.
Modifying an ADT’s implementation should not require modifying its test code – we should be able to immediately run our regression tests in order to determine whether or not the ADT still works. Adhering to the interface often means that we can’t test each ADT function individually.For instance, we can- not testTriangle_init() in isolation; instead, we can test it in combination with the side accessors (e.g.Triangle_side1() )todeterminewhetherornottheinitializationworkscorrectly.Insteadoftestingindividualfunc- tions, we test individual behaviors , such as initialization.Asanotherexample,let’sproceedtodesignandtestanADTtorepresentacoordinateintwo-dimensionalspace,using the principle of test-driven development that we saw previously.We will use polar coordinates, which represent a coordinatebytheradiusfromtheoriginandanglefromthehorizontalaxis,andwereflectthisinthenameoftheADT and its interface.Figure 11.5: Polar representation of a point in two-dimensional space.
We start by determining the interface of the ADT: // A set of polar coordinates in 2D space. struct Polar ; // REQUIRES: p points to a Polar object // MODIFIES: *p // EFFECTS: Initializes the coordinate to have the given radius and // angle in degrees.voidPolar_init(Polar* p, doubleradius, doubleangle); // REQUIRES: p points to a valid Polar object // EFFECTS: Returns the radius portion of the coordinate as a // nonnegative value.doublePolar_radius( constPolar* p); // REQUIRES: p points to a valid Polar object // EFFECTS: Returns the angle portion of the coordinate in degrees as // a value in [0, 360).doublePolar_angle( constPolar* p); We then proceed to write some test cases, following the principles of test-driven development: 11.4.Testing an ADT 61 Programming and Data Structures, Release 0.3 // Basic test of initializing a Polar object.
TEST(test_init_basic) { Polar p; Polar_init(&p, 5, 45); ASSERT_EQUAL(Polar_radius(&p), 5); ASSERT_EQUAL(Polar_angle(&p), 45); } We can then proceed to define a data representation. As part of this process, we should consider what representation invariants our ADT should have.For our PolarADT, a reasonable set of invariants is that the radius is nonnegative, and the angle is in the range [0,360)(using degrees rather than radians)5: struct Polar { doubler; doublephi; // INVARIANTS: r >= 0 && phi >= 0 && phi < 360 }; Now that we have a data representation, we can make an initial attempt at implementing the functions as well: voidPolar_init(Polar* p, doubleradius, doubleangle) { p->r = radius; p->phi = angle; } doublePolar_radius( constPolar* p) { returnp->r; } doublePolar_angle( constPolar* p) { returnp->phi; } Wecanrunourexistingtestcasestogetsomeconfidencethatourcodeisworking.
Inaddition,theprocessofcoming up with a data representation, representation invariants, and function definitions often suggests new test cases. For instance,thefollowingtestcasescheckthattherepresentationinvariantsaremetwhen Polar_init() ispassedvalues that don’t directly meet the invariants: // Tests initialization with a negative radius.TEST(test_negative_radius) { Polar p; Polar_init(&p, -5, 225); ASSERT_EQUAL(Polar_radius(&p), 5); ASSERT_EQUAL(Polar_angle(&p), 45); } // Tests initialization with an angle >= 360.TEST(test_big_angle) { Polar p; Polar_init(&p, 5, 405); (continues on next page) 5Acompletesetofinvariantswouldlikelyalsospecifyacanonicalrepresentationoftheorigin.Forexample,itmayspecifythatiftheradiusis 0, then so is the angle.11.4.Testing an ADT 62 Programming and Data Structures, Release 0.3 (continued from previous page) ASSERT_EQUAL(Polar_radius(&p), 5); ASSERT_EQUAL(Polar_angle(&p), 45); } Given our initial implementation, these test cases will fail.
We can attempt to fix the problem as follows: voidPolar_init(Polar* p, doubleradius, doubleangle) { p->r = std::abs(radius); // set radius to its absolute value p->phi = angle; if(radius < 0) { // rotate angle by 180 degrees if radius p->phi = p->phi + 180; // was negative } } Running our test cases again, we find that both test_negative_radius andtest_big_angle still fail: the angle value returned by Polar_angle() is out of the expected range. We can fix this as follows: voidPolar_init(Polar* p, doubleradius, doubleangle) { p->r = std::abs(radius); // set radius to its absolute value p->phi = angle; if(radius < 0) { // rotate angle by 180 degrees if radius p->phi = p->phi + 180; // was negative } p->phi = std::fmod(p->phi, 360); // mod angle by 360 } Now both test cases succeed.However, we may have thought of another test case through this process: // Tests initialization with a negative angle.
TEST(test_negative_angle) { Polar p; Polar_init(&p, 5, -45); ASSERT_EQUAL(Polar_radius(&p), 5); ASSERT_EQUAL(Polar_angle(&p), 315); } Unfortunately, this test case fails. We can try another fix: voidPolar_init(Polar* p, doubleradius, doubleangle) { p->r = std::abs(radius); // set radius to its absolute value p->phi = angle; if(radius < 0) { // rotate angle by 180 degrees if radius p->phi = p->phi + 180; // was negative } p->phi = std::fmod(p->phi, 360); // mod angle by 360 if(p->phi < 0) { // rotate negative angle by 360 p->phi += 360; } } Our test cases now all pass.11.4.Testing an ADT 63 CHAPTER TWELVE COMMAND-LINE ARGUMENTS Sofar,theprogramswehaveconsideredhavenotworkedwithuserinput.Moreinterestingprograms,however,incor- poratebehaviorthatrespondstouserinput.Wewillseetwomechanismsforpassinginputtoaprogram: command-line arguments and standard input.Command-line arguments are arguments that are passed to a program when it is invoked from a shell or terminal.
As an example, consider the following command: $ g++ -Wall -O1 -std=c++17 -pedantic test.cpp –o test Here,g++is the program we are invoking, and the arguments tell g++what to do. For instance, the -Wallargument tells theg++compiler to warn about any potential issues in the code, -O1tells the compiler to use optimization level 1, and so on.Command-line arguments are passed to the program through arguments to main().Themain()function may have zero parameters, in which case the command-line arguments are discarded.It can also have two parameters1, so the signature has the following form: intmain( intargc, char*argv[]); The first argument is the number of command-line arguments passed to the program, and it is conventionally named argc.The second, conventionally named argv, contains each command-line argument as a C-style string .
An array parameter is actually a pointer parameter, so the following signature is equivalent: intmain( intargc, char**argv); Thus, the second parameter is a pointer to the first element of an array, each element of which is a pointer to the start of a C-style string, as shown in Figure 12.1. Thecommand-lineargumentsalsoincludethenameoftheprogramasthefirstargument–thisisoftenusedinprinting out error messages from the program.We recommend converting command-line arguments to std::string before working with them, as it is less error- prone than working with C-style strings directly.As an example, the following program takes an arbitrary number of integral arguments and computes their sum: #include <iostream> #include <string> // for string type and stoi() function using namespace std ; intmain( intargc, char*argv[]) { (continues on next page) 1Implementations may also allow other signatures for main().
64 Programming and Data Structures, Release 0.3 argvg++\0-Wall\0-O1\0-o\0test\0...8argc Figure 12.1: Representation of command-line arguments. (continued from previous page) intsum = 0; for(inti = 1; i < argc; ++i) { string arg = argv[i]; sum += stoi(argv[i]); } cout << "sum is " << sum << endl; } The first argument is skipped, since it is the program name.Each remaining argument is converted to an intby thestoi()function, which takes a string as the argument and returns the integer that it represents.For example, stoi("123") returns the number 123 as an int.The following is an example of running the program: $ ./sum.exe 2 4 6 8 10 sum is 30 65 CHAPTER THIRTEEN INPUT AND OUTPUT (I/O) Userinputcanalsobeobtainedthrough standardinput ,whichreceivesdatathatausertypesintotheconsole.InC++, thecinstreamreadsdatafromstandardinput.Dataisextractedintoanobjectusingthe extractionoperator >>,andthe extraction interprets the raw character data according to the target data type.
For example, the following code extracts tostring, which extracts individual words that are separated by whitespace: string word; while(cin >> word) { cout << "word = '" << word << " '" << endl; } Theextractionoperationevaluatestothe cinstream,whichhasatruthvalue–iftheextractionsucceeds,itistrue,but if the extraction fails, the truth value is false. Thus, the loop above will continue as long as extraction succeeds.The following is an example of the program: $ ./words.exe hello world!word = 'hello ' word = 'world!' goodbye word = 'goodbye ' Theprogramonlyreceivesinputaftertheuserpressestheenterkey.Thefirstlinetheuserenteredcontainstwowords, eachofwhichgetsprintedout.Thentheprogramwaitsformoreinput.Anotherwordisentered,sotheprogramreads andprintsitout.Finally,theuserinthisexampleinputsan end-of-file character–onUnix-basedsystems,thesequence Ctrl-d enters an end of file, while Ctrl-z does so on Windows systems.
The end-of-file marker denotes the end of a stream, so extracting from cinfails at that point, ending the loop above. Theprogramaboveprintsoutputto standardoutput ,representedbythe coutstream.The insertionoperator <<inserts the text representation of a value into an output stream.13.1 I/O Redirection Shellsallow inputredirection ,whichpassesthedatafromafiletostandardinputratherthanreadingfromthekeyboard.For instance, if the file words.in contains the data: hello world!goodbye Then using the <symbol before the filename redirects the file to standard input at the command line: 66 Programming and Data Structures, Release 0.3 $ ./words.exe < words.in word = 'hello ' word = 'world!' word = 'goodbye ' A file has an implicit end of file at the end of its data, and the program terminates upon reaching the end of the file.We can also do output redirection , where the shell writes the contents of standard output to a file.
The symbol for output redirection is >: $ ./words.exe > result.out hello world! goodbye $ cat result.out word = 'hello ' word = 'world!' word = 'goodbye ' Here, we redirect the output to the file result.out .We then enter input from the keyboard, ending with the Ctrl-d sequence.When the program ends, we use the catcommand to display the contents of result.out .Input and output redirection can also be used together: $ ./words.exe < words.in > result.out $ cat result.out word = 'hello ' word = 'world!' word = 'goodbye ' 13.2 Example: Adding Integers Usingstandardinput,wecanwriteaprogramthataddsupintegersenteredbyauser.
Theprogramwillterminateeither upon reaching an end of file or if the user types in the word done: #include <iostream> #include <string> // for stoi() using namespace std ; intmain() { intsum = 0; cout << "Enter some numbers to sum." << endl string word; while(cin >> word && word != "done") { sum += stoi(word); } cout << "sum is " << sum << endl; } The code extracts to a string so that it can be compared to the string "done". (The latter is a C-style string, but C++ strings can be compared with C-style strings using the built-in comparison operators.) The following is an example of running the program: 13.2.Example: Adding Integers 67 Programming and Data Structures, Release 0.3 $ ./sum Enter some numbers to sum.2 4 6 done sum is 12 Analternateversionoftheprogramextractsdirectlytoan int.
However,itcanonlybeterminatedbyanendoffileor other failed extraction: #include <iostream> using namespace std ; intmain() { intsum = 0; cout << "Enter some numbers to sum." << endl intnumber; while(cin >> number) { sum += number; } cout << "sum is " << sum << endl; } 13.3 File I/O A program can also read and write files directly using file streams. It must include the <fstream> header, and it can then use an ifstream to read from a file and an ofstream to write to a file.The former supports the same interface ascin, while the latter has the same interface as cout.
Anifstream object can be created from a file name: string filename = "words.in"; ifstream fin(filename); Alternatively, the ifstream object can be created without a file name, and then its open()function can be given the name of the file to open: string filename = "words.in"; ifstream fin; fin.open(filename); Ingeneral,aprogramshouldcheckifthefilewassuccessfullyopened,regardlessofthemechanismusedtocreatethe ifstream : if(!fin.is_open()) { cout << "open failed" << endl; return1; } Once we’ve determined the file is open, we can read from it like cin. The following program reads individual words from the file words.in and prints them: 13.3.
File I/O 68 Programming and Data Structures, Release 0.3 #include <iostream> #include <fstream> #include <string> using namespace std ; intmain() { string filename = "words.in"; ifstream fin; fin.open(filename); if(!fin.is_open()) { cout << "open failed" << endl; return1; } string word; while(fin >> word) { cout << "word = '" << word << " '" << endl; } fin.close(); // optional } The program closes the file before exiting. Doing so explicitly is optional – it will happen automatically at the end of theifstream object’s lifetime (e.g.when it goes out of scope if it is a local variable).Best practice is to extract from an input stream, whether it is cinor anifstream , in the test of a loop or conditional.That way, the test will evaluate to false if the extraction fails.
The following examples all print the last word twice because they do not check for failure between extracting and printing a word: while(!fin.fail()) { fin >> word; cout << word; } while(fin.good()) { fin >> word; cout << word; } while(!fin.eof()) { fin >> word; cout << word; } while(fin) { fin >> word; cout << word; } The following is printed when using any of the loops above: $ ./main.exe hello world! goodbye (continues on next page) 13.3.File I/O 69 Programming and Data Structures, Release 0.3 (continued from previous page) goodbye Multipleextractionscanbeplacedinthetestofaloopbychainingthem.Thetestevaluatestotruewhenallextractions succeed.
For example, the following reads two words at a time: string word1, word2; while(fin >> word1 >> word2) { cout << "word1 = '" << word1 << " '" << endl; cout << "word2 = '" << word2 << " '" << endl; } Forwords.in , only the first two words are printed, since the test will fail in the second iteration when it tries to read a fourth word: $ ./main.exe word1 = 'hello ' word2 = 'world! ' Anentirelinecanbereadusingthe getline() function,whichtakesinaninputstreamandatargetstring(byreference) and returns whether or not reading the line succeeded.If so, the target string will contain the full line read: #include <iostream> #include <fstream> #include <string> using namespace std ; intmain() { string filename = "hello.txt"; ifstream fin; fin.open(filename); if(!fin.is_open()) { cout << "open failed" << endl; return1; } string line; while(getline(fin, line)) { cout << "line = '" << line << " '" << endl; } } Forwords.in , this will result in: $ ./main.exe line = 'hello world!
' line = 'goodbye ' Anofstream workssimilarlytoan ifstream ,exceptthatitisusedforprintingoutputtoafile. Thefollowingprogram prints data to the file output.txt : #include <iostream> #include <fstream> #include <string> (continues on next page) 13.3.File I/O 70 Programming and Data Structures, Release 0.3 (continued from previous page) using namespace std ; intmain() { const int SIZE = 4; intdata[SIZE] = { 1, 2, 3, 4 }; string filename = "output.txt"; ofstream fout; fout.open(filename); if(!fout.is_open()) { cout << "open failed" << endl; return1; } for(inti = 0; i < 4; ++i) { fout << "data[" << i << "] = " << data[i] << endl; } fout.close(); // optional } The following shows the resulting data in output.txt : $ cat output.txt data[0] = 1 data[1] = 2 data[2] = 3 data[3] = 4 13.3.File I/O 71 CHAPTER FOURTEEN MORE ON STREAMS Previously,welearnedaboutthe standardinputandoutputstreams ,aswellas filestreams .
Weexaminetherelationship between streams more closely now, as well as how to write unit tests using string streams. Astreamisanabstractionovera sourceofinput,fromwhichwecanreaddata,ora sinkofoutput,towhichwecanwrite data.Streams support the abstraction of character-based input and output over many underlying resources, including the console, files, the network, strings, and so on.In C++, input streams generally derive from istream2.We will see what this means specifically when we look at inheritance andpolymorphism inthefuture.Forourpurposesrightnow,thismeansthatwecanpassdifferentkindsof input-stream objects to a function that takes in a reference to an istream.Similarly, output streams generally derive fromostream, and we can pass different kinds of output-stream objects to a function that takes in a reference to an ostream.
istreamifstreamostreamcinfinistringstreamostringstreamofstreamcoutcerrInputOutputfout Figure 14.1: Relationships between different kinds of input and output streams. Towritedataintoanoutputstream,weusethe insertionoperator <<.Theactualdatawrittenoutdependsonboththe valueitselfaswellasitstype.Forinstance,ifweusea stringastheright-hand-sideoperand,theinsertionoperation will write the characters from the string into the stream: 2Theistream typeisactuallyanaliasfor basic_istream<char> ,whichisaninputstreamthatsupportsinputusingthe chartype.Thesame goes forostream andbasic_ostream<char> .72 Programming and Data Structures, Release 0.3 inti = 123; cout << i; // writes the characters 123 doubled = 12.3; cout << d; // writes the characters 12.3 charc = 'c'; cout << c; // writes the character c string s = "Hello"; cout << s; // writes the characters Hello Expressionsthatapplyanoperatorgenerallyevaluatetoavalue.Inthecaseofstreaminsertion,theresultistheactual stream object itself.
This allows us to chain insertion operations: cout << i << d << endl; // equivalent to ((cout << i) << d) << endl; // ^^^^^^^^^ // evaluates back to the cout object To read data from an input stream, we use the extraction operator >>, with an object on the right-hand side. The charactersareinterpretedaccordingtothetypeoftheobject.Forbuilt-intypes,whitespaceisgenerallyskippedwhen extracting.charc; cin >> c; // reads a single character; does not skip whitespace string s; cout >> s; // reads in one "word", delimited by whitespace inti; cin >> i; // attempts to parse the next characters as an integer value doubled; cin >> d; // attempts to parse the next characters as a floating-point value As with the insertion operator, an expression that applies the extraction operator evaluates back to the stream itself, allowing extraction operations to be chained: cin >> c >> s >> i >> d; 14.1 String Streams Whenwritingunittests,weoftenwanttheteststobestandalonewithoutrequiringaccesstoexternaldata.
Forteststhat work with streams, we can use string streams rather than standard input/output or file streams. To use a string stream, we#include <sstream> .We can then use an istringstream as an input stream, and an ostringstream as an output stream.Thefollowingisanexampleofusingan istringstream torepresentinputdatafortestingafunctionthattakesinan input stream: TEST(test_image_basic) { // A hardcoded PPM image string input = "P3 \n2 2\n255\n255 0 0 0 255 0 \n"; input += "0 0 255 255 255 255 \n"; // Use istringstream for simulated input istringstream ss_input(input); (continues on next page) 14.1.String Streams 73 Programming and Data Structures, Release 0.3 (continued from previous page) Image *img = newImage; Image_init(img, ss_input); ASSERT_EQUAL(Image_width(img), 2); Pixel red = { 255, 0, 0 }; ASSERT_TRUE(Pixel_equal(Image_get_pixel(img, 0, 0), red)); deleteimg; } We start with a stringthat contains the actual input data and then construct an istringstream from that.
We can then pass that istringstream object to a function that has a parameter of type istream & . When that function extracts data, the result will be the data from the string we used to construct the istringstream .We can similarly use an ostringstream to test a function that takes an output stream: TEST(test_matrix_basic) { Matrix *mat = newMatrix; Matrix_init(mat, 3, 3); Matrix_fill(mat, 0); Matrix_fill_border(mat, 1); // Hardcoded correct output string output_correct = "3 3 \n1 1 1 \n1 0 1 \n1 1 1 \n"; // Capture output in ostringstream ostringstream ss_output; Matrix_print(mat, ss_output); ASSERT_EQUAL(ss_output.str(), output_correct); deletemat; } We default construct an ostringstream object and pass it to a function with a parameter of type ostream & .The ostringstream will internally capture the data that the function inserts into it.
We can then call .str()on the ostringstream toobtaina stringthatcontainsthatdata,whichwecanthencomparetoanother stringthatcontains the expected output. 14.1.String Streams 74 CHAPTER FIFTEEN PROGRAM DESIGN Apologies – this section has not been written yet.75 CHAPTER SIXTEEN ABSTRACT DATA TYPES IN C++ Nowthatwe’veseentheconceptofabstractdatatypes(ADTs),weproceedtoexaminethemechanismsC++provides for defining an ADT.Unlike C, C++ allows the data and functions of an ADT to be defined together.It also enables an ADT to prevent access to internal implementation details, as well as to guarantee that an object is appropriately initialized when it is created.Ourconventioninthiscourseistousetheword structtorefertoC-styleADTs,aswellastousethe structkeywordto definethem.Weusetheword classtorefertoC++ADTsandusethe classkeywordtodefinethem.Wewilldiscuss the technical difference between the two keywords momentarily.
A C++ class includes both member variables, which define the data representation, as well as member functions that operate on the data. The following is a Triangle class in the C++ style: class Triangle { doublea; doubleb; doublec; public: Triangle( doublea_in, doubleb_in, doublec_in); doubleperimeter() const{ return this ->a + this->b + this->c; } voidscale( doubles) { this->a *= s; this->b *= s; this->c *= s; } }; Theclasshasmembervariablesforthelengthofeachside,definingthedatarepresentation.Wedeferdiscussionofthe public: andTriangle(...) linesfornow.Belowthoselinesarememberfunctionsforcomputingtheperimeterof a triangle and scaling it by a factor.The following is an example of creating and using a Triangle object: intmain() { Triangle t1(3, 4, 5); t1.scale(2); cout << t1.perimeter() << endl; } 76 Programming and Data Structures, Release 0.3 We initialize a triangle by passing in the side lengths as part of its declaration.
We can then scale a triangle by using the same dot syntax we saw for accessing a member variable: <object>.<function>(<arguments>) . Beforewediscussthedetailsofwhatthecodeisdoing,letuscompareelementsoftheC-styledefinitionanduseofthe triangleADTwiththeC++version.ThefollowingcontraststhedefinitionofanADTfunctionbetweenthetwostyles: C-Style Struct C++ Class voidTriangle_scale(Triangle *tri, doubles) { tri->a *= s; tri->b *= s; tri->c *= s; }class Triangle { voidscale( doubles) { this->a *= s; this->b *= s; this->c *= s; } }; The following compares how objects are created and manipulated: C-Style Struct C++ Class Triangle t1; Triangle_init(&t1, 3, 4, 5); Triangle_scale(&t1, 2);Triangle t1(3, 4, 5); t1.scale(2); With the C-style struct, we defined a top-level Triangle_scale() function whose first argument is a pointer to the Triangle objectwewanttoscale.WithaC++class,ontheotherhand,wedefinea scale() memberfunctionwithin theTriangle class itself.
There is no need to prepend Triangle_ , since it is clear that scale() is a member of the Triangle class. Thememberfunctionalsodoesnotexplicitlydeclareapointerparameter–instead,theC++language addsanimplicitthisparameterthatisapointertothe Triangle objectweareworkingon.Wecanthenusethe this pointer in the same way we used the explicit tripointer in the C style.As for using a Triangle object, in the C style, we had to separately create the Triangle object and then initialize it with a call to Triangle_init() .In the C++ style, object creation and initialization are combined – we will see how later.WheninvokinganADTfunction,intheCcasewehavetoexplicitlypasstheaddressoftheobjectweareworking on.With the C++ syntax, the object is part of the syntax – it appears on the left-hand side of the dot, so the compiler automatically passes its address as the thispointer of the scale() member function.
The following contrasts the definitions of a function that treats the ADT object as const: C-Style Struct C++ Class doubleTriangle_perimeter( constTriangle *tri) { returntri->a + tri->b + tri->c; }class Triangle { doubleperimeter() const{ return this ->a + this->b + this->c; } }; 77 Programming and Data Structures, Release 0.3 C-Style StructC++ Class Stackmain0x10202.0sTriangle_scale0x10180x1000triTriangle0x10084.0b0x10105.0c0x10003.0at1Stackmain0x10202.0sTriangle::scale0x10180x1000thisTriangle0x10084.0b0x10105.0c0x10003.0at1 Figure 16.1: Memory layout when scaling a triangle in the C and C++ styles. In the C style, we add the constkeyword to the left of the *when declaring the explicit pointer parameter, resulting intribeing a pointer to const.In the C++ style, we don’t have an explicit parameter where we can add the const keyword.Instead, we place the keyword after the parameter list for the function.
The compiler will then make the implicitthisparameterapointertoconst,asifitweredeclaredwiththetype const Triangle * . Thisallowsusto call the member function on a const Triangle : constTriangle t1(3, 4, 5); cout << t1.perimeter() << endl; // OK: this pointer is a pointer to const t1.scale(2); // ERROR: conversion from const to non-const As with accessing member variables, we can use the arrow operator to invoke a member function through a pointer: Triangle t1(3, 4, 5); constTriangle *ptr = &t1; cout << ptr->perimeter() << endl; // OK: this pointer is a pointer to const ptr->scale(2); // ERROR: conversion from const to non-const 16.1 Implicit this-> Since member variables and member functions are both located within the scope of a class, C++ allows us to refer to members from within a member function without the explicit this->syntax.The compiler automatically inserts the member dereference for us: class Triangle { doublea; doubleb; doublec; (continues on next page) 16.1.
Implicit this-> 78 Programming and Data Structures, Release 0.3 (continued from previous page) ... doubleperimeter() const{ returna + b + c; // Equivalent to: this->a + this->b + this->c } }; Thisisalsothecaseforinvokingothermemberfunctions.Forinstance,thefollowingdefinesanduses functionstoget each side length: class Triangle { doublea; doubleb; doublec; ...doubleside1() const{ returna; } doubleside2() const{ returnb; } doubleside3() const{ returnc; } doubleperimeter() const{ returnside1() + side2() + side3(); // Equivalent to: this->side1() + this->side2() + this->side3() } }; In both cases, the compiler can tell that we are referring to members of the class and therefore inserts the this->.However, if there are names in a closer scope that conflict with the member names, we must use this->ourselves.The following is an example: class Triangle { doublea; ...
doubleset_side1( doublea) { this->a = a; } }; Here,the unqualified areferstotheparameter a,sinceitisdeclaredinanarrowerscopethanthemembervariable. We can still refer to the member abyqualifying its name with this->.In general, we should avoid declaring variables in a local scope that hidenames in an outer scope.Doing so in a constructor or set function is often considered acceptable, but it should be avoided elsewhere.16.1.Implicit this-> 79 Programming and Data Structures, Release 0.3 16.2 Member Accessibility The data representation of an ADT is usually an implementation detail ( plain old data being an exception).With C- style structs, however, we have to rely on programmers to respect convention and avoid accessing member variables directly.
With C++ classes, the language provides us a mechanism for enforcing this convention: declaring members asprivatepreventsaccessfromoutsidetheclass,whiledeclaringthemas publicallowsoutsideaccess.1Wegiveaset ofmembersaparticularaccesslevelbyplacing private: orpublic: beforethemembers–thataccesslevelapplies tosubsequentmembersuntilanewaccessspecifierisencountered,andanynumberofspecifiersmayappearinaclass. The following is an example: class Triangle { private: doublea; doubleb; doublec; public: Triangle( doublea_in, doubleb_in, doublec_in); doubleperimeter() const{ returna + b + c; } voidscale( doubles) { a *= s; b *= s; c *= s; } }; Inthisexample,themembers a,b,andcaredeclaredasprivate,while Triangle() ,perimeter() ,andscale() are declared as public.Private members, whether variables or functions, can be accessed from within the class, even if they are members of a different object of that class.
They cannot be accessed from outside the class: intmain() { Triangle t1(3, 4, 5); // OK: Triangle() is public t1.scale(2); // OK: scale() is public cout << t1.perimeter() << endl; // OK: perimeter() is public // Die triangle! DIE!t1.a = -1; // ERROR: a is private } With theclasskeyword, the default access level is private.Thus, the private: at the beginning of the Triangle definition is redundant, and the following is equivalent: class Triangle { doublea; doubleb; doublec; public: (continues on next page) 1Later, we will discuss protected members that are accessible to derived classes.This access level, however, is rarely used.16.2.Member Accessibility 80 Programming and Data Structures, Release 0.3 (continued from previous page) Triangle( doublea_in, doubleb_in, doublec_in); ...}; We have seen previously that members declared within a structare accessible from outside the struct.
In fact, the onlydifferencebetweenthe structandclasskeywordswhendefiningaclasstypeisthedefaultaccesslevel: public forstructbut private for class.2However, we use the two keywords for different conventions in this course. 16.3 Constructors Aconstructor issimilartoamemberfunction,exceptthatitspurposeistoinitializeaclass-typeobject.
Inmostcases, C++ guarantees that a constructor is called when creating an object of class type.3The following examples all call a constructor: Triangle t1; // calls zero-argument (default) constructor Triangle t2(3, 4, 5); // calls three-argument constructor Triangle t3 = Triangle(3, 4, 5); // calls three-argument constructor // examples with "uniform initialization syntax": Triangle t4{3, 4, 5}; // calls three-argument constructor Triangle t5 = {3, 4, 5}; // calls three-argument constructor Triangle t6 = Triangle{3, 4, 5}; // calls three-argument constructor Ascanbeseenabove,therearemanyformsofsyntaxforinitializinga Triangle object,allofwhichcallaconstructor. Whennoargumentsareprovided,thezero-argument,or default,constructoriscalled.Wewilldiscussthisconstructor in more detail later.The following does notcall a constructor: Triangle t7(); // declares a function called t7 that returns a Triangle Infact,itdoesn’tcreateanobjectatall.
Instead,itdeclaresafunctionnamed t7thattakesnoargumentsandreturnsa Triangle . A function declaration can appear at local scope, so this is interpreted as a function declaration regardless of whether it is at local or global scope.So far, we declared a single constructor for Triangle as follows: class Triangle { doublea; doubleb; doublec; public: Triangle( doublea_in, doubleb_in, doublec_in); }; 2This also applies to inheritance.We will see next time that private inheritance is the default for a class, and we will need to use the public keyword to override this.The default for a structis public inheritance.3The exception is aggregate initialization, where an initializer list is used to directly initialize the members of a class-type object.This is only possible for aggregates , which are class types that have a restricted set of features.Our pattern of C-style structs obey the rules for an aggregate, thoughwedefineinitfunctionsinsteadofusingaggregateinitialization.
OurconventionofC++classesresultsinclasstypesthatarenotaggregates, so objects of such types can only be initialized through a constructor. We can still use initializer-list syntax for a non-aggregate – it will call a constructor with the values in the initializer list as arguments.16.3.Constructors 81 Programming and Data Structures, Release 0.3 The syntax is similar to declaring a member function, except: •There is no return type.•The name of the constructor is the same as the name of the class.Like a member function, the constructor has an implicit thisparameter that points to the object being initialized.As in a member function, we can leave out this->to access a member, as long as there is no local name that hides the member.
The following is a definition of the Triangle constructor: class Triangle { doublea; doubleb; doublec; public: // poor constructor implementation Triangle( doublea_in, doubleb_in, doublec_in) { a = a_in; b = b_in; c = c_in; } }; However,thereisaproblemwiththedefinitionabove: thestatementsinthebodyoftheconstructorperform assignment , notinitialization . Thus,themembervariablesareactuallydefaultinitializedandthenassignednewvalues.Inthiscase, it is a minor issue, but it can be more significant in other cases.In particular there are several kinds of variables that allow initialization but not assignment: •arrays •references •constvariables •class-type variables that disable assignment (e.g.streams) Another case where initialization followed by assignment is problematic is for types where both initialization and assignment perform nontrivial operations – we lose efficiency by doing both when we only need initialization.
C++ provides two mechanisms for initializing a member variable: •directly in the declaration of the variable, similar to initializing a non-member variable •through a member-initializer list Amember-initializer list is syntax specific to a constructor. It is a list of initializations that appear between a colon symbol and the constructor body: class Triangle { doublea; doubleb; doublec; public: // good constructor implementation Triangle( doublea_in, doubleb_in, doublec_in) : a(a_in), b(b_in), c(c_in) {} }; 16.3.Constructors 82 Programming and Data Structures, Release 0.3 An individual initialization consists of a member-variable name, followed by an initialization expression enclosed by parentheses (or curly braces).The constructor above initializes the member ato the value of a_in,bto the value of b_in, andcto the value of c_in.The constructor body is empty, since it has no further work to do.
If a member is initialized in both its declaration and a member-initializer list, the latter takes precedence, so that the initialization in the member declaration is ignored. 16.4 Default Initialization and Default Constructors Every object in C++ is initialized upon creation, whether the object is of class type or not.If no explicit initialization is provided, it undergoes default initialization .Default initialization does the following: •Objects of atomic type (e.g.int,double, pointers) are default initialized by doing nothing.This means they retainwhatevervaluewasalreadythereinmemory.Putanotherway,atomicobjectshaveundefinedvalueswhen they are default initialized.•An array is default initialized by in turn default initializing its elements.Thus, an array of atomic objects is default initialized by doing nothing, resulting in undefined element values.•Aclass-typeobjectisdefaultinitializedbycallingthe defaultconstructor ,whichistheconstructorthattakesno arguments.
If no such constructor exists, or if it is inaccessible (e.g. it is private), a compile-time error results.Anarrayofclass-typeobjectsisdefaultinitializedbycallingthedefaultconstructoroneachelement.Thus,the element type must have an accessible default constructor in order to create an array of that type.Withinaclass,ifamembervariableisneitherinitializedatdeclarationnorinthemember-initializerlistofaconstructor, it is default initialized.The default constructor is so named because it is invoked in default initialization, and it takes no arguments.We can define a default constructor for Triangle as follows, making the design decision to initialize the object as a 1x1x1 equilateral triangle: class Triangle { doublea; doubleb; doublec; public: // default constructor Triangle() : a(1), b(1), c(1) {} // non-default constructor Triangle( doublea_in, doubleb_in, doublec_in) : a(a_in), b(b_in), c(c_in) {} }; Aclasscanhavemultipleconstructors.
Thisisaformof functionoverloading ,whichwewillreturntointhefuture. The compiler determines which compiler to invoke based on the arguments that are provided when creating a Triangle object: Triangle t1; // 1x1x1 -- calls zero-argument (default) constructor Triangle t2(3, 4, 5); // 3x4x5 -- calls three-argument constructor 16.4.Default Initialization and Default Constructors 83 Programming and Data Structures, Release 0.3 16.4.1 Implicit Default Constructor If a class declares no constructors at all, the compiler provides an implicit default constructor .
The behavior of this constructor is as if it were empty, so that it default initializes each member variable: struct Person { string name; intage; boolis_ninja; // implicit default constructor // Person() {} // default initializes each member variable }; intmain() { Person elise; // calls implicit default constructor cout << elise.name; // prints nothing: default ctor for string makes it empty cout << elise.age; // prints undefined value cout << elise.is_ninja; // prints undefined value }; If a class declares anyconstructors whatsoever, no implicit default constructor is provided: class Triangle { doublea; doubleb; doublec; public: Triangle( doublea_in, doubleb_in, doublec_in); doubleperimeter() const{ returna + b + c; } voidscale( doubles) { a *= s; b *= s; c *= s; } }; intmain() { Triangle t1; // ERROR: no implicit or explicit default constructor } In this case, if we want our type to have a default constructor, we have to explicitly write one: class Triangle { doublea; doubleb; doublec; public: // explicit default constructor (continues on next page) 16.4.
Default Initialization and Default Constructors 84 Programming and Data Structures, Release 0.3 (continued from previous page) Triangle() : a(1), b(1), c(1) {} // non-default constructor Triangle( doublea_in, doubleb_in, doublec_in) : a(a_in), b(b_in), c(c_in) {} doubleperimeter() const{ returna + b + c; } voidscale( doubles) { a *= s; b *= s; c *= s; } }; intmain() { Triangle t1; // OK: explicit default constructor } 16.5 Get and Set Functions With C++ classes, member variables are usually declared private, since they are implementation details. However, many C++ ADTs provide a means of accessing the abstract data through getandset functions (also called gettersand settersoraccessor functions ).These are provided as part of the interface as an abstraction over the underlying data.The following are examples for Triangle : class Triangle { doublea; doubleb; doublec; public: // EFFECTS: Returns side a of the triangle.
doubleget_a() const{ returna; } // REQUIRES: a_in > 0 && a_in < get_b() + get_c() // MODIFIES: *this // EFFECTS: Sets side a of the triangle to a_in. voidset_a( doublea_in) { a = a_in; } }; If the implementation changes, the interface can remain the same, so that outside code is unaffected: 16.5.Get and Set Functions 85 Programming and Data Structures, Release 0.3 class Triangle { doubleside1; // new names doubleside2; doubleside3; public: // EFFECTS: Returns side a of the triangle.doubleget_a() const{// same interface returnside1; // different implementation } // REQUIRES: a_in > 0 && a_in < get_b() + get_c() // MODIFIES: *this // EFFECTS: Sets side a of the triangle to a_in.voidset_a( doublea_in) { side1 = a_in; } }; With a set function, we’ve introduced a new location from which the representation can be modified.We need to ensure that the representation invariants are still met.
We can do so by writing and using a private function to check the invariants: class Triangle { doublea; doubleb; doublec; public: Triangle( doublea_in, doubleb_in, doublec_in) : a(a_in), b(b_in), c(c_in) { check_invariants(); } voidset_a( doublea_in) { a = a_in; check_invariants(); } private: voidcheck_invariants() { assert(0 < a && 0 < b && 0 < c); assert(a + b > c && a + c > b && b + c > a); } } Itisgoodpracticetochecktheinvariantsanywheretherepresentationcanbemodified. Here,wehavedonesoinboth the constructor and in the set function.16.5.Get and Set Functions 86 Programming and Data Structures, Release 0.3 16.6 Information Hiding Good abstraction design uses encapsulation , which groups together both the data and functions of an ADT.With a class, we get encapsulation by defining both member variables and member functions.A proper abstraction also provides information hiding , which separates interface from implementation.
Access speci- fiers such as private allow us to prevent the outside world from accessing implementation details. WecanfurtherhideinformationfromthesightoftheusersofanADTbyphysicallyseparatingthecodefortheinterface fromthecodefortheimplementation.ThestandardmechanismtodosoinC++istoplacedeclarationsinheaderfiles and definitions in source files.With a class, we place a class definition that only contains member declarations in the header file: // Triangle.hpp // A class that represents a triangle ADT.class Triangle { public: // EFFECTS: Initializes this to a 1x1x1 triangle.Triangle(); // EFFECTS: Initializes this with the given side lengths.Triangle( doublea_in, doubleb_in, doublec_in); // EFFECTS: Returns the perimeter of this triangle.doubleperimeter() const; // REQUIRES: s > 0 // MODIFIES: *this // EFFECTS: Scales the sides of this triangle by the factor s.
voidscale( doubles); private: doublea; doubleb; doublec; // INVARIANTS: // positive side lengths: a > 0 && b > 0 && c > 0 // triangle inequality: a + b > c && a + c > b && b + c > a }; It is also generally preferable to declare the public members of the class before private members, so that users do not have to skip over implementation details to find the public interface. Wethendefinetheconstructorsandmemberfunctionsoutsideoftheclassdefinition,inthecorrespondingsourcefile.In order to define a member function outside of a class, we need two things: 1) A declaration of the function within the class, so that the compiler (and other programmers) can tell that the member exists.2) Syntax in the definition that tells the compiler that the function is a member of the associated class and not a top-level function.Thelatterisaccomplishedbyprefixingthemembernamewiththeclassname,followedbythe scope-resolutionoper- ator: 16.6.
Information Hiding 87 Programming and Data Structures, Release 0.3 // Triangle.cpp #include "Triangle.hpp" Triangle::Triangle() : a(1), b(1), c(1) {} Triangle::Triangle( doublea_in, doubleb_in, doublec_in) : a(a_in), b(b_in), c(c_in) {} doubleTriangle::perimeter() const{ returna + b + c; } voidTriangle::scale( doubles) { a *= s; b *= s; c *= s; } Thistellsthecompilerthatthetwoconstructors,aswellasthe perimeter() andscale() functions,aremembersof theTriangle class. 16.7 Testing a C++ ADT We test a C++ ADT by writing test cases that live outside of the ADT itself.C++ forces us to respect the interface, since the implementation details are private: // Triangle_tests.cpp #include "Triangle.hpp" #include "unit_test_framework.hpp" TEST(test_triangle_basic) { Triangle t(3, 4, 5); ASSERT_EQUAL(t.area(), 6); ASSERT_EQUAL(t.get_a(), 3); // must use get and set functions t.set_a(4); ASSERT_EQUAL(t.get_a(), 4); } TEST_MAIN() 16.7.
Testing a C++ ADT 88 Programming and Data Structures, Release 0.3 16.8 Member-Initialization Order Membervariablesarealwaysinitializedintheorderinwhichtheyaredeclaredintheclass. Thisisthecaseregardless if some members are initialized at the declaration point and others are not, or if a constructor’s member-initializer list is out of order: class Triangle { doublea; doubleb; doublec; public: Triangle( doublea_in, doubleb_in, doublec_in) : b(b_in), c(c_in), a(a_in) { // this ordering is ignored } }; Here,aisinitializedfirstto a_in,thenbtob_in,thenctoc_in;theorderinginthemember-initializerlistisignored.
Somecompilerswillgenerateawarningiftheorderdiffersbetweenthememberdeclarationsandthemember-initializer list: $ g++ --std=c++17 -Wall Triangle.cpp Triangle.cpp:8:16: warning: field 'c'will be initialized after field 'a' [-Wreorder] : b(b_in), c(c_in), a(a_in) { // this ordering is ignored 16.9 Delegating Constructors Whenaclasshasmultipleconstructors,itcanbeusefultoinvokeoneconstructorfromanother. Thisallowsustoavoid codeduplication,anditalsomakesourcodemoremaintainablebyreducingthenumberofplaceswherewehardcode implementation details.In order to delegate to another constructor, we must do so in the member-initializer list.The member-initializer list must consist solely of the call to the other constructor: class Triangle { doublea; doubleb; doublec; public: // EFFECTS: Initializes this to be an equilateral triangle with // the given side length.
Triangle( doubleside_in) : Triangle(side_in, side_in, side_in) {} // delegate to 3-argument constructor Triangle( doublea_in, doubleb_in, doublec_in) : a(a_in), b(b_in), c(c_in) {} }; Thedelegationmustbeinthemember-initializerlist. Ifweinvokeadifferentconstructorfromwithinthebody,itdoes not do delegation; rather, it creates a new, temporary object and then throws it away: 16.8.Member-Initialization Order 89 Programming and Data Structures, Release 0.3 Triangle( doubleside_in) { // default initializes members Triangle(side_in, side_in, side_in); // creates a new Triangle object that // lives in the activation record for // this constructor } 16.9.Delegating Constructors 90 CHAPTER SEVENTEEN DERIVED CLASSES AND INHERITANCE In addition to encapsulation and information hiding, C++ classes provide two features that are fundamental to object- oriented programming : •Inheritance : the ability for a class to reuse the interface or functionality of another class.
•Subtype polymorphism : the ability to use an object of a more specific type where an object of a more general type is expected. We will discuss inheritance today, deferring subtype polymorphism until next time.
To motivate the concept of inheritance, consider the following definitions of Chicken andDuckADTs: class Chicken { public: Chicken( conststring &name_in) : age(0), name(name_in), roads_crossed(0) { cout << "Chicken ctor" << endl; } string get_name() const{ returnname; } intget_age() const{ returnage; } voidcross_road() { ++roads_crossed; } voidtalk() const{ cout << "bawwk" << endl; } private: intage; string name; introads_crossed; };class Duck { public: Duck( conststring &name_in) : age(0), name(name_in), num_ducklings(0) { cout << "Duck ctor" << endl; } string get_name const{ returnname; } intget_age() const{ returnage; } voidhave_babies() { num_ducklings += 7; } voidtalk() const{ cout << "quack" << endl; } private: intage; string name; intnum_ducklings; }; 91 Programming and Data Structures, Release 0.3 ThetwoADTsarenearlyidentical–bothhave ageandnamemembervariables,withtheircorrespondinggetfunctions, and both have a talk()member function that makes the appropriate chicken or duck sound.
In terms of differences, chickens tend to cross roads (since they don’t fly very well), so we keep track of how often they do that. On the other hand, ducks are often accompanied by their ducklings, so we keep track of how many they have.Intuitively,itmakessensefor Chicken andDucktosharealotoffunctionality,sincechickensandducksarebothtypes of birds.BirdChickenDuckis ais a Figure 17.1: Relationship between different kinds of birds.This “is-a” relationship, where a Chicken is aBirdand aDuckis also aBird, can be encoded with inheritance .We writeBirdas abase class , then write Chicken andDuckas classes that inheritorderivefromBird.We place the common functionality in Bird, which then gets inherited by the derived classes.
class Bird { public: Bird( conststring &name_in) : age(0), name(name_in) { cout << "Bird ctor" << endl; } string get_name() const{ returnname; } intget_age() const{ returnage; } voidhave_birthday() { ++age; } voidtalk() const{ cout << "tweet" << endl; } private: intage; string name; }; Here, all birds have a name and an age, and the generic sound a bird makes is “tweet”. For more a more specific kind of bird, we obtain the functionality of the base class by deriving from it: 92 Programming and Data Structures, Release 0.3 class Chicken :publicBird { ...}; Thesyntaxforderivingfromabaseclassistoputacolonafterthenameofthederivedclass,thenthe publickeyword, then the name of the base class.This results in public inheritance , where it is part of the interface of Chicken that it derives from Bird.Without the publickeyword, it would be private inheritance1, where it is an implementation detail and not part of the interface that Chicken derives from Bird.
Now thatChicken derives from Bird, it inherits the functionality of the Birdclass, and the public interface of Bird is also supported by Chicken: Chicken c("Myrtle"); c.have_birthday(); cout << c.get_name() << " " << c.get_age(); // prints Myrtle 1 Functionality that is specific to a particular kind of bird goes in the class for that bird: class Chicken :publicBird { public: ... voidcross_road() { ++roads_crossed; } voidtalk() const{ cout << "bawwk" << endl; } private: introads_crossed; }; Here, we have the additional data member roads_crossed ;nameandageare inherited from Bird.(They are not directly accessible from the Chicken class, however, since they are private.We will come back to this later.) Figure 17.2 illustrates the layout of BirdandChicken in memory.intmain() { Bird big_bird("Big Bird"); Chicken myrtle("Myrtle"); } The memory of Chicken actually consists of a Birdpiece, plus the additional Chicken members.
Thus, the data members defined by Birdare also included in a Chicken. In order to properly initialize a derived-class object, its constructor must ensure that its base-class subobject is also appropriatelyinitialized.Thebaseclassmayhaveprivatemembervariables,whichcannotbeaccessedfromthederived class,sothederivedclassdoesnotinitializetheinheritedmembersdirectly.Instead,itinvokesabase-classconstructor in the member-initializer list of its own constructors: 1As with member accessibility, the default inheritance is public if the structkeyword is used to define a class type and private if the class keywordisused.Withprivateinheritance,the(non-private)inheritedmembersareprivatetothederivedclass,sothatoutsidecodemaynotaccess thosemembers.Thereisalso protectedinheritance ,whereclassesthatderivefromthederivedclasscanaccessthe(non-private)inheritedmembers of the derived class, but outside code cannot.
93 Programming and Data Structures, Release 0.3 StackBird0x10180age0x1000"Big Bird"namemainbig_birdChicken0x10380age0x103c0roads_crossed0x1020"Myrtle"namemyrtleBird Figure 17.2: The layout of a derived-class object contains a subset that matches the layout of a base-class object. class Chicken :publicBird { public: Chicken( conststring &name_in) : Bird(name_in), roads_crossed(0) { cout << "Chicken ctor" << endl; } ...private: introads_crossed; }; In C++, a derived-class constructor alwaysinvokes a constructor for the base class.If an explicit invocation does not appear in the member-initializer list, there is an implicit call to the default constructor.If the base class has no default constructor, an error results: class Chicken :publicBird { public: Chicken( conststring &name_in) : roads_crossed(0) { // ERROR: implicit call to Bird(), which doesn 't exist cout << "Chicken ctor" << endl; } ...
}; For completeness, the following is an implementation of Duckas a derived class of Bird: class Duck :publicBird { public: Duck( conststring &name_in) (continues on next page) 94 Programming and Data Structures, Release 0.3 (continued from previous page) : Bird(name_in), num_ducklings(0) { cout << "Duck ctor" << endl; } voidhave_babies() { num_ducklings += 7; } voidtalk() const{ cout << "quack" << endl; } private: intnum_ducklings; }; Bywriting Birdandderivingfromitinboth Chicken andDuck,wehaveavoidedduplicationofthesharedfunction- ality. 17.1 Ordering of Constructors and Destructors We have already seen that in most cases, a constructor is invoked when a class-type object is created.Similarly, a destructor isinvokedwhenaclass-typeobject’slifetimeisover.Foralocalvariable,thisiswhenthevariablegoesout of scope.
The following illustrates an example: class Foo { public: Foo() { // constructor cout << "Foo ctor" << endl; } ~Foo() { // destructor cout << "Foo dtor" << endl; } }; voidfunc() { Foo x; } intmain() { cout << "before call" << endl; func(); cout << "after call" << endl; } The class Foohas a custom destructor, written as ~Foo(), which runs when a Fooobject is dying. Here, we just have both the constructor and destructor print messages to standard out.The following is printed when the code is run: before call Foo ctor (continues on next page) 17.1.Ordering of Constructors and Destructors 95 Programming and Data Structures, Release 0.3 (continued from previous page) Foo dtor after call We will cover destructors in more detail later in the course.For now, we concern ourselves solely with the order in which constructors and destructors execute when we have derived classes.
Whentherearemultipleobjectsthatareconstructedanddestructed,C++followsa“socks-and-shoes”ordering: when weputonsocksandshoesinthemorning,weputonsocksfirst,thenourshoes. Intheevening,however,whenwetake them off, we do so in the reverse order: first our shoes, then our socks.In the case of a derived class, C++ will always construct the base-class subobject before initializing the derived-class pieces.Destruction is in the reverse order: first the derived-class destructor runs, then the base-class one.The following illustrates this order: class Bird { public: Bird( conststring &name_in) : age(0), name(name_in) { cout << "Bird ctor" << endl; } ~Bird() { cout << "Bird dtor" << endl; } ...}; class Chicken :publicBird { public: Chicken( conststring &name_in) : Bird(name_in), roads_crossed(0) { cout << "Chicken ctor" << endl; } ~Chicken() { cout << "Chicken dtor" << endl; } ...
}; intmain() { cout << "construction:" << endl; Chicken myrtle("Myrtle"); cout << "destruction:" << endl; } The following results from running the code: construction: Bird ctor Chicken ctor destruction: Chicken dtor (continues on next page) 17.1. Ordering of Constructors and Destructors 96 Programming and Data Structures, Release 0.3 (continued from previous page) Bird dtor Whencreatinga Chicken object,theinvocationofthe Birdconstructoristhefirstthingthathappensinthe Chicken constructor.This is true regardless of whether or not an explicit call to the Birdconstructor appears, and regardless of ordering of the member-initializer list.Then the rest of the Chicken constructor runs.When a Chicken object is dying, first the code in the Chicken destructor runs.Then the code in the Birddestructor automatically runs.
(It is generally erroneous to invoke the base-class destructor explicitly, since the compiler always does so implicitly.) The following code creates both a Chicken and aDuckobject: intmain() { cout << "construction:" << endl; Chicken myrtle("Myrtle"); Duck donald("Donald"); cout << "destruction:" << endl; } Assuming that Duckhas a destructor that prints out "Duck dtor" , the code prints the following: construction: Bird ctor Chicken ctor Bird ctor Duck ctor destruction: Duck dtor Bird dtor Chicken dtor Bird dtor We see the same ordering in Duckconstruction and destruction. Furthermore, we see that because myrtleis con- structed before donald, it is destructed after donald– socks-and-shoes ordering here as well.17.2 Name Lookup and Hiding When a member access is applied to an object, the compiler follows a specific process to look up the given name: •Thecompilerstartsbylookingforamemberwiththatnameinthecompile-timeor statictype oftheobject.
(We will discuss static and dynamic types next time.) •If no member with that name is found, the compiler repeats the process on the base class of the given type. If the type has no base class, a compiler error is generated.•Ifamemberwiththegivennameisfound,thecompilerthencheckswhetherornotthememberisaccessibleand whetherthemembercanbeusedinthegivencontext.2Ifnot,acompilererrorisgenerated–thelookupprocess does not proceed further.As an example, consider the following member accesses: Chicken myrtle("Myrtle"); myrtle.get_age(); (continues on next page) 2Ifnamelookupfindsasetofoverloadedfunctionswithinthesameclass,thecompilerperformsoverloadresolutiontodeterminewhichoverload is the most appropriate.We will discuss function overloading in more detail next time.17.2.
Name Lookup and Hiding 97 Programming and Data Structures, Release 0.3 (continued from previous page) myrtle.talk(); myrtle.age; myrtle.undefined; •Formyrtle.get_age() , the compiler first looks for a get_age member defined in the Chicken class. Since Chicken doesnotdefinesuchamember,thecompilerlooksfora get_age memberinitsbase Birdclass.There isindeeda get_age memberin Bird,sothecompilerthenchecksthatthememberisaccessibleandisafunction that can be called with no arguments.These checks succeed, so the lookup process terminates successfully.•Formyrtle.talk() , the compiler looks for a talkmember in Chicken.There is one, so it then checks to makesureitisaccessibleandisafunctionthatcanbecalledwithnoarguments.Thissucceeds,andatruntime, it isChicken::talk() that is called.The function Bird::talk() ishidden, since the name lookup process never gets to it.•Formyrtle.age , the compiler looks for an agemember in Chicken.There is none, so the compiler looks in Bird.
There is such a member, so the compiler checks whether it is accessible from the given context. The member is private, so this check fails, and the compiler reports an error.•Formyrtle.undefined , the compiler looks for an undefined member in Chicken.There is none, so the compilerlooksin Bird.Thereisnosuchmember,and Birdhasnobaseclass,sothecompilerreportsanerror.As another example, consider the following code: class Base { public: intx; voidfoo( conststring &s); }; class Derived :publicBase { public: voidx(); voidfoo( inti); }; intmain() { Derived d; inta = d.x; d.foo("hello"); } Whenlookingup d.x,thecompilerfindsamember xinDerived.However,itisamemberfunction,whichcannotbe assigned to an int.Thus, the compiler reports an error – it does not consider the hidden xthat is defined in Base.Similarly, when looking up d.foo, the compiler finds a member fooinDerived.Though it is a function, it cannot be called with a string literal, so the compiler reports an error.
Again, the compiler does not consider the foothat is defined in Base; that member is hidden by the foodefined in Derived. Tosummarize,C++doesnotconsiderthecontextinwhichamemberisuseduntilafteritsfindsamemberofthegiven name.This is in contrast to some other languages, which consider context in the lookup process itself.Onoccasion,wewishtoaccessahiddenmemberratherthanthememberthathidesit.Themostcommoncaseiswhen a derived-class version of a function calls the base-class version as part of its functionality.The following illustrates this inChicken: 17.2.Name Lookup and Hiding 98 Programming and Data Structures, Release 0.3 class Chicken :publicBird { public: ...
voidtalk() const{ if(age >= 1) { // ERROR: age is private in Bird cout << "bawwk" << endl; }else{ // baby chicks make more of a tweeting rather than clucking noise Bird::talk(); // call Bird 's version of talk() } } }; By using the scope-resolution operator, we are specifically asking for the Birdversion of talk(), enabling access to it even though it is hidden.3 The code above does have a problem: it accesses the agemember of Bird, which, though it is not hidden, is private and so not accessible to Chicken. There are two solutions to this problem: •We can declare ageto beprotected, which allows derived classes of Birdto access the member but not the outside world.•We can use the public get_age() function instead.The former strategy is not desirable; since the member variable ageis an implementation detail, making it protected exposesimplementationdetailstothederivedclasses.Instead,weshoulduseagetfunctiontoabstracttheimplemen- tation detail.
We could choose to make such a function protected, so that it is part of the interface that derived classes have access to but not the outside world. For age, we already have a public get function, so we can just use that: class Chicken :publicBird { public: ...voidtalk() const{ if(get_age() >= 1) { cout << "bawwk" << endl; }else{ // baby chicks make more of a tweeting rather than clucking noise Bird::talk(); // call Bird 's version of talk() } } }; 3Interestingly, we can apply the scope-resolution operator as part of dot or arrow syntax in order to access the base-class version: myrtle.Bird::talk() .However, this is very uncommon in real code, and we will not do it at all in this course.17.2.Name Lookup and Hiding 99 CHAPTER EIGHTEEN POLYMORPHISM The word polymorphism literally means “many forms.” In the context of programming, polymorphism refers to the ability of a piece of code to behave differently depending on the context in which it is used.
Appropriately, there are several forms of polymorphism: •ad hoc polymorphism , which refers to function overloading •parametric polymorphism in the form of templates •subtype polymorphism , which allows a derived-class object to be used where a base-class object is expected The unqualified term “polymorphism” usually refers to subtype polymorphism. We proceed to discuss ad hoc and subtype polymorphism, deferring parametric polymorphism until later.18.1 Function Overloading Adhocpolymorphismrefersto functionoverloading ,whichistheabilitytouseasinglenametorefertomanydifferent functionsinasinglescope.C++allowsbothtop-levelfunctionsandmemberfunctionstobeoverloaded.Thefollowing is an example of overloaded member functions: class Base { public: voidfoo( inta); intfoo(string b); }; intmain() { Base b; b.foo(42); b.foo("test"); } Whenweinvokeanoverloadedfunction,thecompilerresolvesthefunctioncallbycomparingthetypesofthearguments totheparametersofthecandidatefunctionsandfindingthebestmatch.
Thecall b.foo(42) callsthememberfunction foo()withparameter int,since42isan int. Thecall b.foo("test") callsthefunctionwithparameter string– "test"actually has type const char * , but astringparameter is a better match for a const char * thanint.In C++, functions can only be overloaded when defined within the same scope.If functions of the same name are defined in a different scope, then those that are defined in a closer scope hide the functions defined in a further scope: class Derived :publicBase { public: (continues on next page) 100 Programming and Data Structures, Release 0.3 (continued from previous page) intfoo( inta); doublefoo( doubleb); }; intmain() { Derived d; d.foo("test"); // ERROR } When handling the member access d.foo, under the name-lookup process we saw last time, the compiler finds the namefooinDerived.Itthenappliesfunction-overloadresolution;however,noneofthefunctionswithname foocan be invoked on a const char * , resulting in a compile error.
The functions inherited from Baseare not considered, since they were defined in a different scope. Functionoverloadingrequiresthesignaturesofthefunctionstodiffer,sothatoverloadresolutioncanchoosetheover- loadwiththemostappropriatesignature.Here,“signature”referstothefunctionnameandparametertypes–thereturn type is not part of the signature and is not considered in overload resolution.class Person { public: voidgreet(); voidgreet( intx); // OK voidgreet(string x); // OK voidgreet( intx, string s); // OK voidgreet(string s, intx); // OK boolgreet(); // ERROR: signature the same as the first overload voidgreet() const; // OK: implicit this parameter different }; Formemberfunctions,the constkeywordaftertheparameterlistispartofthesignature–itchangestheimplicit this parameter from being a pointer to non-const to a pointer to const.Thus, it is valid for two member-function overloads to differ solely in whether or not they are declared as const.
18.2 Subtype Polymorphism Subtypepolymorphism allowsaderived-classobjecttobeusedwhereabase-classoneisexpected. Inorderforthisto work, however, we need indirection.Consider what happens if we directly copy a Chicken object into a Bird: intmain() { Chicken chicken("Myrtle"); // ...Bird bird = chicken; } While C++ allows this, the value of a Chicken does not necessarily fit into a Birdobject, since a Chicken has more member variables than a Bird.The copy above results in object slicing – the members defined by Birdare copied, but theChicken ones are not, as illustrated in Figure 18.1.To avoid slicing, we need indirection through a reference or a pointer, so that we avoid making a copy: Bird &bird_ref = chicken; Bird *bird_ptr = &chicken; 18.2.
Subtype Polymorphism 101 Programming and Data Structures, Release 0.3 StackBird0x10183age0x1000"Myrtle"namemainbirdChicken0x10383age0x103c238roads_crossed0x1020"Myrtle"namechickenBird Figure 18.1: Object slicing copies only the members defined by the base class. The above initializes bird_ref as an alias for the chicken object.Similarly, bird_ptr is initialized to hold the address of the chicken object.In either case, a copy is avoided.C++allowsareferenceorpointerofabasetypetorefertoanobjectofaderivedtype.Itallowsimplicit upcasts,which areconversionsthatgoupwardintheinheritancehierarchy,suchasfrom Chicken toBird,asintheexamplesabove.On the other hand, implicit downcasts are prohibited: Chicken &chicken_ref = bird_ref; // ERROR: implicit downcast Chicken *chicken_ptr = bird_ptr; // ERROR: implicit downcast TheimplicitdowncastsareprohibitedbyC++eventhough bird_ref andbird_ptr actuallyreferto Chicken objects.
Inthegeneralcase,theycanrefertoobjectsthataren’tof Chicken type,suchas Duckorjustplain Birdobjects. Since the conversions may be unsafe, they are disallowed by the C++ standard.While implicit downcasts are prohibited, we can do explicitdowncasts with static_cast : Chicken &chicken_ref = static_cast <Chicken &>(bird_ref); Chicken *chicken_ptr = static_cast <Chicken *>(bird_ptr); These conversions are unchecked at runtime, so we need to be certain from the code that the underlying object is a Chicken.Inordertobeabletobindabase-classreferenceorpointertoaderived-classobject,theinheritancerelationshipmust be accessible.From outside the classes, this means that the derived class must publicly inherit from the derived class.Otherwise, the outside world is not allowed to take advantage of the inheritance relationship.Consider this example: class A { }; class B : A { // default is private when using the class keyword }; intmain() { B b; (continues on next page) 18.2.
Subtype Polymorphism 102 Programming and Data Structures, Release 0.3 (continued from previous page) A *a_ptr = &b; // ERROR: inheritance relationship is private } This results in a compiler error: main.cpp:9:16: error: cannot cast 'B'to its private base class 'A' A *a_ptr = &b; // ERROR: inheritance relationship is private ^ main.cpp:4:13: note: implicitly declared private here class B : A { // default is private when using the class keyword ^ 1 error generated. 18.3 Static and Dynamic Binding Subtype polymorphism allows us to pass a derived-class object to a function that expects a base-class object: voidImage_init(Image* img, istream& is); intmain() { Image *image = /* ...*/ ; istringstream input( /* ...*/ ); Image_init(image, input); } Here, we have passed an istringstream object to a function that expects an istream.Extracting from the stream will use the functionality that istringstream defines for extraction.
Anothercommonusecaseistohaveacontainerofbase-classpointers,eachofwhichpointstodifferentderived-class objects: voidall_talk(Bird *birds[], intlength) { for(inti = 0; i < length; ++i) { array[i]->talk(); } } intmain() { Chicken c1 = /* ... */ ; Duck d = /* ...*/ ; Chicken c2 = /* ...*/ ; Bird *array[] = { &c1, &d, &c2 }; all_talk(array, 3); } Unfortunately, given the way we defined the talk()member function of Birdlast time, this code will not use the derived-class versions of the function.Instead, all three calls to talk()will use the Birdversion: $ ./main.exe tweet tweet tweet 18.3.Static and Dynamic Binding 103 Programming and Data Structures, Release 0.3 In the invocation array[i]->talk() , the declared type of the receiver, the object that is receiving the member- function call, is different from the actual runtime type.The declared or static type isBird, while the runtime or dynamic type isChicken wheni == 0.
This disparity can only exist when we have indirection, either through a reference or a pointer. Foraparticularmemberfunction,C++givesustheoptionofeither staticbinding wherethecompilerdetermineswhich functiontocallbasedonthestatictypeofthereceiver,or dynamicbinding ,wheretheprogramalsotakesthedynamic type into account.The default is static binding, since it is more efficient and can be done entirely at compile time.In order to get dynamic binding instead, we need to declare the member function as virtualin the base class: class Bird { ...virtual void talk() const{ cout << "tweet" << endl; } }; Now when we call the all_talk() function above, the compiler will use the dynamic type of the receiver in the invocation array[i]->talk() : $ ./main.exe bawwk quack bawwk Thevirtual keyword is necessary in the base class, but optional in the derived classes.
It can only be applied to the declarationwithinaclass;ifthefunctionissubsequentlydefinedoutsideoftheclass,thedefinitioncannotincludethe virtual keyword: class Bird { ... virtual void talk() const; }; voidBird::talk() const{ cout << "bawwk" << endl; } 18.4 dynamic_cast With dynamic binding, the only change we need to make to our code is to add the virtual keyword when declaring the base-class member function.No changes are required to the actual function calls (e.g.in all_talk() ).Consider an alternative to dynamic binding, where we manually check the runtime type of an object to call the appro- priate function.In C++, a dynamic_cast conversion checks the dynamic type of the receiver object: Chicken chicken("Myrtle"); Bird *b_ptr = &chicken; Chicken *c_ptr = dynamic_cast <Chicken *>(b_ptr); if(c_ptr) { // check for null // do something chicken-specific } 18.4.
dynamic_cast 104 Programming and Data Structures, Release 0.3 If the dynamic type is not actually a Chicken, the conversion results in a null pointer. Otherwise, it results in the address of the Chicken object.Thus, we can check for null after the conversion to determine if it succeeded.There are two significant issues with dynamic_cast : 1.It generally results in messy and unmaintainable code.For instance, we would need to modify all_talk() as follows to use dynamic_cast rather than dynamic binding: voidall_talk(Bird * birds[], intlength) { for(inti = 0; i < length; ++i) { Chicken *c_ptr = dynamic_cast <Chicken*>(birds[i]); if(c_ptr) { c_ptr->talk(); } Duck *d_ptr = dynamic_cast <Duck*>(birds[i]); if(d_ptr) { d_ptr->talk(); } Eagle *e_ptr = dynamic_cast <Eagle*>(birds[i]); if(e_ptr) { e_ptr->talk(); } ...} } Wewouldneedabranchforeveryderivedtypeof Bird,andwewouldhavetoaddanewbrancheverytimewe wrote a new derived class.
The code also takes time that is linear in the number of derived classes. 2.In C++, dynamic_cast can only be applied to classes that are polymorphic , meaning that they define at least one virtual member function.Thus, we need to use virtual one way or another.Codethatuses dynamic_cast isusuallyconsideredtobepoorlywritten.Almostuniversally,itcanberewrittentouse dynamic binding instead.18.5 Member Lookup Revisited We have already seen that when a member is accessed on an object, the compiler first looks in the object’s class for a member of that name before proceeding to its base class.With indirection, the following is the full lookup process: 1.Thecompilerlooksupthememberinthe statictype ofthereceiverobject,usingthe lookupprocess wediscussed before (starting in the class itself, then looking in the base class if necessary).It is an error if no member of the given name is found in the static type or its base types.2.
If the member found is an overloaded function, then the arguments of the function call are used to determine which overload is called. 3.Ifthememberisavariableornon-virtualfunction(including staticmemberfunctions ,whichwewillseelater), the access is statically bound at compile time.4.If the member is a virtual function, the access uses dynamic binding.At runtime, the program will look for a function of the same signature , starting at the dynamic type of the receiver, then proceeding to its base type if necessary.As indicated above, dynamic binding requires two conditions to be met to use the derived-class version of a function: •The member function found at compile time using the static type must be virtual.18.5.Member Lookup Revisited 105 Programming and Data Structures, Release 0.3 •The derived-class function must have the same signature as the function found at compile time.
When these conditions are met, the derived-class function overrides the base-class one – it will be used instead of the base-class function when the dynamic type of the receiver is the derived class. If these conditions are not met, the derived-class function hidesthe base-class one – it will only be used if the static type of the receiver is the derived class.As an example, consider the following class hierarchy: class Top { public: intf1() const{ return1; } virtual int f2() const{ return2; } }; class Middle :publicTop { public: intf1() const{ return3; } virtual int f2() const{ return4; } }; class Bottom :publicMiddle { public: intf1() const{ return5; } virtual int f2() const{ return6; } }; Each class has a non-virtual f1()member function; since the function is non-virtual, the derived-class versions hide the ones in the base classes.The f2()function is virtual, so the derived-class ones override the base-class versions.
The following are some examples of invoking these functions: intmain() { Top top; Middle mid; Bottom bot; Top *top_ptr = &bot; Middle *mid_ptr = &mid; cout << top.f2() << endl; // prints 2 (continues on next page) 18.5. Member Lookup Revisited 106 Programming and Data Structures, Release 0.3 (continued from previous page) cout << mid.f1() << endl; // prints 3 cout << top_ptr->f1() << endl; // prints 1 cout << top_ptr->f2() << endl; // prints 6 cout << mid_ptr->f2() << endl; // prints 4 mid_ptr = &bot; cout << mid_ptr->f1() << endl; // prints 3 cout << mid_ptr->f2() << endl; // prints 6 } We discuss each call in turn: •There is no indirection in the calls top.f1() andmid.f1() , so there is no difference between the static and dynamic types of the receivers.The former calls the Topversion of f1(), resulting in 2, while the latter calls theMiddleversion, producing 3.•The static type of the receiver in top_ptr->f1() andtop_ptr->f2() isTop, while the dynamic type is Bottom.
Sincef1()is non-virtual, static binding is used, resulting in 1. On the other hand, f2()is virtual, so dynamic binding uses the Bottomversion, producing 6.•In the first call to mid_ptr->f2() , both the static and dynamic type of the receiver is Middle, soMiddle‘s version is used regardless of whether f2()is virtual.The result is 4.•The assignment mid_ptr = &bot changes the dynamic type of the receiver to Bottomin calls on mid_ptr.The static type remains Middle, so the call mid_ptr->f1() results in 3.The second call to mid_ptr->f2() , however, uses dynamic binding, so the Bottomversion of f2()is called, resulting in 6.18.6 The override Keyword Acommonmistakewhenattemptingtooverrideafunctionistoinadvertentlychangethesignature,sothatthederived- class version hides rather than overrides the base-class one.The following is an example: class Chicken :publicBird { ...
virtual void talk() { cout << "bawwk" << endl; } } intmain() { Chicken chicken("Myrtle"); Bird *b_ptr = &chicken; b_ptr->talk(); } Thiscodecompiles,butitprints tweetwhenrun. Underthelookupprocessabove,theprogramlooksforanoverride ofBird::talk() at runtime.However, no such override exists – Chicken::talk() has a different signature, since it is notconst.Thus, the dynamic lookup finds Bird::talk() and calls it instead.Ratherthanhavingthecodecompileandthenbehaveincorrectly,wecanaskthecompilertodetectbugslikethiswith theoverride keyword.Specifically, we can place the override keyword after the signature of a member function to let the compiler know we intended to override a base-class member function.If the derived-class function doesn’t actually do so, the compiler will report this: 18.6.The override Keyword 107 Programming and Data Structures, Release 0.3 class Chicken :publicBird { ...
voidtalk() override { cout << "bawwk" << endl; } } Here, we have removed the virtual keyword, since it is already implied by override – only a virtual function can be overridden, and the “virtualness” is inherited from the base class. Since we are missing the const, the compiler reports the following: main.cpp:39:15: error: non-virtual member function marked 'override 'hides virtual member function void talk() override { ^ main.cpp:20:16: note: hidden overloaded virtual function 'Bird::talk 'declared here: different qualifiers (const vs none) virtual void talk() const { ^ 1 error generated.Adding in the constfixes the issue: class Chicken :publicBird { ...voidtalk() const override { cout << "bawwk" << endl; } } intmain() { Chicken chicken("Myrtle"); Bird *b_ptr = &chicken; b_ptr->talk(); } The code now prints bawwk.
18.7 Abstract Classes and Interfaces In some cases, there isn’t enough information in a base class to define a particular member function, but we still want that function to be part of the interface provided by all its derived classes. In the case of Bird, for example, we may wantaget_wingspan() functionthatreturnstheaveragewingspanforaparticularkindofbird.Thereisn’tadefault value that makes sense to put in the Birdclass.Instead, we declare get_wingspan() as apure virtual function , without any implementation in the base class: class Bird { ...virtual int get_wingspan() const= 0; }; 18.7.Abstract Classes and Interfaces 108 Programming and Data Structures, Release 0.3 The syntax for declaring a function as pure virtual is to put = 0;after its signature.This is just syntax – we aren’t actually setting its value to 0.SinceBirdisnowmissingpartofitsimplementation,wecannolongercreateobjectsof Birdtype.The Birdclassis saidtobe abstract.
Wecanstilldeclare Birdreferencesandpointers,however,sincethatdoesn’tcreatea Birdobject. We can then have such references and pointers refer to derived-class objects: Bird bird("Big Bird"); // ERROR: Bird is abstract Chicken chicken("Myrtle"); // OK, as long as Chicken is not abstract Bird &bird_ref = chicken; // OK Bird *bird_ptr = &chicken; // OK Inorderforaderivedclasstonotbeabstractitself,itmustprovideimplementationsofthepurevirtualfunctionsinits base classes: class Chicken :publicBird { ...intget_wingspan() const override { return20; // inches } }; With a virtual function, a base class provides its derived classes with the option of overriding the function’s behavior.With a pure virtual function, the base class requires its derived classes to override the function, since the base class does not provide an implementation itself.If a derived class fails to override the function, the derived class is itself abstract, and objects of that class cannot be created.
We can also define an interface, which is a class that consists only of pure virtual functions. Such a class provides no implementation; rather, it merely defines the interface that must be overridden by its derived classes.The following is an example: class Shape { public: virtual double area() const= 0; virtual double perimeter() const= 0; virtual void scale( doubles) = 0; }; With subtype polymorphism, we end up with two use cases for inheritance: •implementation inheritance , where a derived class inherits functionality from a base class •interfaceinheritance ,whereaderivedclassinheritstheinterfaceofitsbaseclass,butnotnecessarilyanyimple- mentation Deriving from a base class that isn’t an interface results in both implementation and interface inheritance.Deriving from an interface results in just interface inheritance.
The latter is useful to work with a hierarchy of types through a common interface, using a base-class reference or pointer, even if the derived types don’t share any implementation. 18.7.Abstract Classes and Interfaces 109 Part III Containers and Dynamic Memory 110 CHAPTER NINETEEN CONTAINERS AND ITERATORS Apologies – this section has not been written yet.19.1 Range-Based For Loops Arange-based for loop is a special syntax for iterating over sequences that support traversal by iterator.Rather than writing out each piece of the traversal, we can have the compiler generate it for us: vector< int> vec = { 1, 2, 3, 4, 5 }; for(intitem : vec) { cout << item << endl; } The syntax of a range-based for loop is: for(<type> <variable> : <sequence>) <body> In the example above, the variable is named itemand has type int, andvecis the sequence over which the loop iterates.
The compiler automatically converts this into a traversal by iterator: for(autoit = vec.begin(); it != vec.end(); ++it) { intitem = *it; cout << item << endl; } The variable itemis initialized in each iteration from an element in the sequence. Then the code in the body of the range-based for loop follows.The following loop attempts to set every element in the vector to the value 42: for(intitem : vec) { item = 42; // attempt to set element to 42 } However, this loop does not actually modify any elements.To understand why, let us take a look at its translation into a traversal by iterator: for(autoit = vec.begin(); it != vec.end(); ++it) { intitem = *it; item = 42; } 111 Programming and Data Structures, Release 0.3 The loop is actually modifying a copyof each element rather than an element itself.
To avoid making a copy, we can declare the loop variable to be a reference: for(int&item : vec) { item = 42; // actually set element to 42 } This translates to: for(autoit = vec.begin(); it != vec.end(); ++it) { int&item = *it; item = 42; } This successfully modifies each element to have the value 42. Range-based for loops are often used in combination with auto, as in the following: vector< int> vec = { 1, 2, 3, 4, 5 }; for(auto&item : vec) { item = 42; } for(autoitem : vec) { cout << item << endl; } The first loop declares itemas a reference, so that it aliases an element in the sequence.The second loop does not declareitemas a reference, so it produces a copy of an element in the sequence.
The following is the translation of both loops: vector< int> vec = { 1, 2, 3, 4, 5 }; for(autoit = vec.begin(); it != vec.end(); ++it) { int&item = *it; // alias item = 42; } for(autoit = vec.begin(); it != vec.end(); ++it) { intitem = *it; // copy item = 42; } With a range-based for loop, we can simplify print_all() : template <typename Sequence > voidprint_all( constSequence &sequence) { for(auto&item : sequence) { cout << item << endl; } } We can call it on any sequence1that supports traversal by iterator, as long as the element type can be inserted into an output stream: 1We can even call print_all() on an array, as long as it still is an array: 19.1. Range-Based For Loops 112 Programming and Data Structures, Release 0.3 vector<string> vec = { "hello", "world!" }; print_all(vec); 19.1.1 Iterating over a Map The standard-library map defines an iterator that produces key-value pairs upon dereference.
The following is an examplethatconstructsamap,countinghowmanytimeseachuniquewordoccursinavector. Ittheniteratesoverthe map to print out the counts.voidprint_word_counts( conststd::vector<std::string> &words) { std::map<std::string, int> word_counts; // Each time a word is seen, add 1 to its entry in the map for(const auto &word : words) { word_counts[word] += 1; } // Print out the results by iterating through the map.for(const auto &key_value : word_counts) { // key-value pairs const auto &word = key_value.first; const auto &count = key_value.second; cout << word << "occurred " << count << " times." << endl; } } Whenincrementingaword’scount,wedonotneedtocheckwhetherthewordisinthemap;ifnot,themapautomati- cally inserts the word into the map with a value-initialized count of zero, which we then increment to one.We use range-based for loops to iterate over both the vector and the map, declaring a type-deduced reference to each element.
A reference avoids making a copy, which is nontrivial for strings. The iteration over the map produces key- value pairs ( std::pair<std::string, int> ), and we access the firstandsecondmembers to obtain the word and count, respectively.string arr[] = { "hello", "world!" }; print_all(arr); Thisisbecausearange-basedforloopactuallycalls std::begin() andstd::end() onthesequence,ratherthandirectlycallingtherespective member functions.For arrays, std::begin() andstd::end() return pointers, while for class types, they call the begin() andend()member functions, respectively.19.1.Range-Based For Loops 113 CHAPTER TWENTY TIME COMPLEXITY Apologies – this section has not been written yet.114 CHAPTER TWENTYONE ARRAYS As we mentioned previously, C++ has several different categories of objects , including atomic, array, and class-type objects.An arrayissimplecollectionofobjects,builtintoC++andmanyotherlanguages.Anarrayhasthefollowing properties: •It has a fixed size, set when the array is created.
This size never changes as long as the array is alive. •An array holds elements that are of the same type.•The elements of an array are stored in a specific order, with the index of the first element being 0.•The elements are stored contiguously in memory, one after another.•Accessing any element of an array takes constant time, regardless of whether the element is at the beginning, middle, or end of the array.An array variable can be declared by placing square brackets to the right of the variable name, with a compile-time constant between the brackets, denoting the number of elements.For example, the following declares arrayto be an array of four intelements: intarray[4]; The following uses a named constant to declare array2to be an array of four ints: const int SIZE = 4; intarray2[SIZE]; In both cases, we did not provide an explicit initialization.Thus, arrayandarray2are default initialized by default initializingeachoftheirelements.
Sincetheirelementsareofatomictype int,theyaredefaultinitializedtoundefined values. We can explicitly initialize an array with an initializer list , a list of values in curly braces: intarray[4] = { 1, 2, 3, 4 }; This initializes the element at index 0 to 1, the element at index 1 to 2, and so on.Iftheinitializerlistcontainsfewervaluesthanthesizeofthearray,theremainingarrayelementsareimplicitlyinitial- ized.For atomic elements, these remaining elements are initialized to zero values1.Thus, the following initializes the first two elements of array2to 1 and 2, respectively, and the last two elements to 0: intarray2[4] = { 1, 2 }; The following results in every element in array3being initialized to 0: 1This is referred to as value initialization , which is distinct from default initialization.115 Programming and Data Structures, Release 0.3 intarray3[4] = {}; Here,wehaveprovidedanemptyinitializerlist,sothatthefirstzeroelements(i.e.
noneofthem)areexplicitlyinitialized while the remaining elements (i.e. all of them) are implicitly initialized to 0.If the size of the array is the same as the size of the initializer list, we can elide the size of the array in its declaration: intarray[] = { 1, 2, 3, 4 }; Figure 21.1 illustrates the layout of arrayin memory.0x10001array[0]0x10042array[1]0x10083array[2]0x100c4array[3]array: Figure 21.1: Layout of an array in memory.This diagram assumes that an inttakes up four bytes in memory, which is the case on most modern machines.Individualarrayelementscanbeaccessedwithsquarebrackets,withanindexbetweenthebrackets.Indexingstartsat 0, up through the size of the array minus one.For example, the following increments each element in arrayby one and prints out each resulting value: for(inti = 0; i < 4; ++i) { ++array[i]; cout << array[i] << endl; } Arrayscanbecomposedwithotherkindsofobjects,suchasstructs.
Thefollowingisanarrayofthree Personelements: struct Person { string name; intage; boolis_ninja; }; Person people[3]; Figure 21.2 shows the layout of this array in memory. The following is a struct that contains an array as a member, and its layout is shown in Figure 21.3: struct Matrix { intwidth; intheight; intdata[6]; }; intmain() { Matrix matrix; ...} 116 Programming and Data Structures, Release 0.3 0x1018?age0x1000""name 0x1038?age0x1020""name 0x1058?age0x1040""namepeople:people[0]people[1]people[2]PersonPersonPerson0x101ctrueis_ninja0x103ctrueis_ninja0x105ctrueis_ninja Figure 21.2: An array of class-type objects.Matrix0x1004?height0x1000?widthdata:0x1008?data[0]0x100c?data[1]0x1010?data[2]0x1014?data[3]0x1018?data[4]0x101c?data[5]matrix Figure 21.3: A class-type object with an array member.117 Programming and Data Structures, Release 0.3 21.1 Arrays and Pointers Arrays in C++ are objects.However, in most contexts, there isn’t a value associated with an array as a whole2.
The individual elements (if they are not of array type), have values, but not the array as a whole. Instead, when we use an array in a context where a value is required, the compiler converts the array into a pointer to the first element in the array: intarray[] = { 1, 2, 3, 4 }; cout << &array[0] << endl; // prints 0x1000 assuming the figure above cout << array << endl; // prints 0x1000 assuming the figure above *array = -1; cout << array[0] << endl; // prints -1 In this example, assuming the layout in Figure 21.1 where the first element is at address 0x1000, printing arrayto standard output just prints out the address 0x1000– it converts arrayto a pointer to its first element, and it is the pointer’s value that is then printed.Similarly, dereferencing the array first turns it into a pointer to the first element, followed by the dereference that gives us the first element itself.The tendency of arrays to decayinto pointers results in significant limitations when using an array.
For instance, we cannotassignonearraytoanother–theright-handsideofanassignmentrequiresavalue,whichinthecaseofanarray will become a pointer, which is then incompatible with the left-hand side array: intarr1[4] = { 1, 2, 3, 4 }; intarr2[4] = { 5, 6, 7, 8 }; arr2 = arr1; // error: LHS is an array, RHS is a pointer Asdiscussedbefore,bydefault,C++passesparametersbyvalue. Thisisalsotrueiftheparameterisanarray.Sincean array decays to a pointer when its value is required, this implies that an array is passed by value as a pointer to its first element.
Thus, an array parameter to a function is actually equivalent to a pointer parameter, regardless of whether or not the parameter includes a size: voidfunc1( intarr[4]); // parameter equivalent to int *arr voidfunc2( intarr[5]); // parameter equivalent to int *arr voidfunc3( intarr[]); // parameter equivalent to int *arr voidfunc4( int*arr); intmain() { intarr1[4] = { 1, 2, 3, 4 }; intarr2[5]; intx = -3; func1(arr1); // OK: arr1 turns into pointer, as does parameter of func1 func2(arr1); // OK: arr1 turns into pointer, as does parameter of func2 // compiler ignores size in func2 parameter func3(arr1); // OK: arr1 turns into pointer, as does parameter of func3 func4(arr1); // OK: arr1 turns into pointer, matches parameter of func4 (continues on next page) 2The system of values in C++ is very complicated and beyond the scope of this course. In the context of this course, we use the term valueto mean something called an rvaluein programming-language terms.
There are a handful of ways to construct an array rvalue in C++, but none that we will encounter in this course. 21.1.Arrays and Pointers 118 Programming and Data Structures, Release 0.3 (continued from previous page) func1(arr2); // OK: arr2 turns into pointer, as does parameter of func1 // compiler ignores size in func1 parameter func2(arr2); // OK: arr2 turns into pointer, as does parameter of func2 func3(arr2); // OK: arr2 turns into pointer, as does parameter of func3 func4(arr2); // OK: arr2 turns into pointer, matches parameter of func4 func1(&x); // OK: parameter of func1 turns into pointer func2(&x); // OK: parameter of func2 turns into pointer func3(&x); // OK: parameter of func3 turns into pointer func4(&x); // OK: matches parameter of func4 } This means that a function that takes an array as a parameter cannot guarantee that the argument value corresponds to an array of matching size, or even that it is a pointer into an array.
Instead, we need another mechanism for passing size information to a function; we will come back to this momentarily. 21.2 Pointer Arithmetic C++ supports certain arithmetic operations on pointers: •Anintegralvaluecanbeaddedtoorsubtractedfromapointer,resultinginapointerthatisoffsetfromtheoriginal one.•Two pointers can be subtracted, resulting in an integral value that is the distance between the pointers.Pointer arithmetic is in terms of number of elements rather than number of bytes .
For instance, if an inttakes up four bytes of memory, then adding 2 to an int *results in a pointer that is two ints forward in memory, or a total of eight bytes: intarray[] = { 4, 3, 2, 1 }; int*ptr1 = array; // pointer to first element int*ptr2 = &array[2]; // pointer to third element int*ptr3 = ptr1 + 2; // pointer to third element int*ptr4 = array + 2; // pointer to third element ++ptr1; // move pointer to second element In initializing ptr4,arrayis converted to a pointer to its first element, since the +operator requires a value, and the resultistwo intsforwardinmemory,producingapointertothethirdelement. Thelastlineincrements ptr1topoint to the next intin memory.The result is shown in Figure 21.4.The following demonstrates subtracting pointers: cout << ptr2 - ptr1 << endl; // prints 1 Sinceptr2is oneintfurther in memory than ptr, the difference ptr2 - ptr is 1.
PointerarithmeticisonereasonwhyeachC++typehasitsownpointertype–inordertobeabletodopointerarithmetic, the compiler needs to use the size of the pointed-to type, so it needs to know what that type is. For example, imple- mentations generally represent doubleobjects with eight bytes, so adding 2 to a double * moves 16 bytes forward in memory.In general, for a pointer of type T *, addingNto it moves N * sizeof(T) bytes forward in memory3.Pointers can also be compared with the comparison operators, as in the following using the pointers declared above: 3sizeofis an operator that can be applied to a type to obtain the number of bytes used to represent that type.When applied to a type, the parenthesesaremandatory(e.g.sizeof(int) ).Theoperatorcanalsobeappliedtoavalue,inwhichcaseitresultsinthesizeofthecompile-time type of that value.Parentheses are not required in this case (e.g.sizeof 4 orsizeof x ).21.2.
Pointer Arithmetic 119 Programming and Data Structures, Release 0.3 0x10004array[0]0x10043array[1]0x10082array[2]0x100c1array[3] Stackmain 0x10180x1008ptr20x10200x1008ptr30x10100x1000ptr10x10004array[0]0x10043array[1]0x10082array[2]0x100c1array[3] Stackmain 0x10180x1008ptr20x10200x1008ptr30x10100x1004ptr1++ptr10x10280x1008ptr40x10280x1008ptr4 Figure 21.4: Pointer arithmetic is in terms of whole objects, not bytes. cout << (ptr1 == ptr2) << endl; // false (prints as 0) cout << (ptr2 == ptr3) << endl; // true (prints as 1) cout << (ptr1 < ptr2) << endl; // true cout << (*ptr1 < *ptr2) << endl; // false (compares element values) ++ptr1; cout << (ptr1 == ptr2) << endl; // true cout << (array == &array[0]) << endl; // true (LHS turns into pointer) Arithmeticisgenerallyusefulonlyonpointerstoarrayelements,sinceonlyarrayelementsareguaranteedtobestored contiguouslyinmemory.
Similarly,comparisonsaregenerallyonlywell-definedonpointersintothesamearrayoron pointers constructed from arithmetic operations on the same pointer. 21.3 Array Indexing Array indexing in C++ is actually implemented using pointer arithmetic.If one of the operands to the subscript ( []) operatorisanarrayandtheotherisintegral,thentheoperationisequivalenttopointerarithmeticfollowedbyaderef- erence: intarr[4] = { 1, 2, 3, 4 }; cout << *(arr + 2) << endl; // prints 3: arr+2 is pointer to 3rd element cout << arr[2] << endl; // prints 3: equivalent to *(arr + 2) cout << 2[arr] << endl; // prints 3: equivalent to *(2 + arr); // but don 't do this!Thus, ifarris an array and iis integral, then arr[i]is equivalent to *(arr + i) : 1.The subscript operation requires the value of arr, so it turns into a pointer to its first element.2.Pointer arithmetic is done to produce a pointer ielements forward in memory.3.The resulting pointer is dereferenced, resulting in the element at index i.21.3.
Array Indexing 120 Programming and Data Structures, Release 0.3 Because the subscript operation is equivalent to pointer arithmetic, it can be applied to a pointer equally as well: intarr[4] = { 1, 2, 3, 4 }; int*ptr = arr + 1; // pointer to second element cout << ptr[2] << endl; // prints 4: constructs a pointer that is 2 // elements forward in memory, then // dereferences that Thereareseveralimplicationsoftheequivalencebetweenarrayindexingandpointerarithmetic. First,itiswhatmakes array access a constant time operation – no matter the index, accessing an element turns into a single pointer addition followed by a single dereference.The equivalence is also what makes passing arrays by value work – the result is a pointer, which we can still subscript into since it just does pointer arithmetic followed by a dereference.Finally, it allows us to work with subsets of an array.
For instance, the following code prints out just the middle elements of an array: voidprint_array( intarray[], intsize) { for(inti = 0; i < size; ++i) { cout << array[i] << " "; } } intmain() { intarray[4] = { 3, -1, 5, 2 }; print_array(arr + 1, 2); // prints out just -1 5 } 0x10003array[0]0x1004-1array[1]0x10085array[2]0x100c2array[3]Stackmainprint_array0x10182size0x101c0i0x10100x1004array Figure 21.5: Passing a subset of an array to a function. Theprint_array() functionreceivesapointertothearray’ssecondelementaswellasasizeof2,asshowninFigure 21.5.Thus,itonlyprintsoutthesecondandthirdelements;asfarasthefunctionknows,itisworkingwithanarrayof size 2 that starts at the address 0x1004.21.3.Array Indexing 121 Programming and Data Structures, Release 0.3 21.4 More on Array Decay Anarrayonlydecaysintoapointerwhenitsvalueisrequired.Whenanarrayobject’svalueisnotrequired,itdoesnot decay into a pointer.
For example, the address-of ( &) operator requires an object but not its value – thus, applying &to an array produces a pointer to the whole array, not a pointer to an individual element nor a pointer to a pointer4. Another example is applying the sizeofoperator to an array.The operator produces the size of the whole array in bytes5,asopposedtoapplyingittoapointer,whichjustproducesthesizeofapointer(generallyeightbytesonmodern systems): intx = 42; intarr[5] = { 1, 2, 3, 4, 5 }; int*ptr = arr; cout << sizeofx << endl; // 4 (on most machines) cout << sizeofarr << endl; // 20 cout << sizeofptr << endl; // 8 Once an array has turned into a pointer, the resulting pointer loses all information about the size of the array, or even that it is a pointer into an array.Thus, we need another mechanism for keeping track of the size of an array, such as whenwepassthearraytoafunction(ifitispassedbyvalue,itturnsintoapointerwhichretainsnoinformationabout the array’s size).
21.5 The End of an Array If a program dereferences a pointer that goes past the bounds of the array, the result is undefined behavior6. If we are lucky, the program will crash, indicating we did something wrong and giving us an opportunity to debug it.In the worstcase,theprogrammaycomputetherightresultwhenwerunitonourownmachinebutmisbehavewhenrunon a different platform (e.g.the autograder).There are two general strategies for keeping track of where an array ends.1.Keeptrackofthelengthseparatelyfromthearray.Thiscanbedonewitheitheranintegersizeorbyconstructing a pointer that is just past the end of an array (by just adding the size of the array to a pointer to the array’s first element).2.Store a special sentinel value at the end of the array, which allows an algorithm to detect that it has reached the end.The first strategy is what we used in defining the print_array() function above.
As demonstrated there, the stored size may be smaller than the size of the array, resulting in the function operating on a subset of the array. The second strategy requires there to be a special value that can be reserved to indicate the end of the array, and that we are assured will not occur as a real element.It is how built-in (C-style) strings (as opposed to C++ std::string ) are implemented, though we do not cover the details here.Instead, we will return to the sentinel strategy when we implement linked data structures .4A pointer to an array of 4 ints can be declared using the syntax int (*ptr_to_arr)[4]; .The address value stored in a pointer to an array is generally the same address as that of the array’s first element.5Thus, the expression sizeof array / sizeof *array recovers the number of elements, as long as arrayis still an array.6Constructingapointerthatisoutofboundsisnotaproblem;weoftenconstructpointersthatarejustpasttheendofanarray,aswewillseein a moment.
It is dereferencing such a pointer that results in undefined behavior. 21.4.More on Array Decay 122 Programming and Data Structures, Release 0.3 21.6 Array Traversal Theprint_array() functionabovealsodemonstrateshowtotraversethroughanarrayusinganindexthatstartsat0 up to the size of the array, exclusive.The following is another example: int const SIZE = 3; // constant to represent array size intarray[SIZE] = { -1, 7, 3 }; for(inti = 0; i < SIZE; ++i) { cout << *(array + i) << endl; // using pointer arithmetic cout << array[i] << endl; // using subscript (better) } 0x1004-1array[0]0x10087array[1]0x100c3array[2]Stackmain0x10003SIZE0x10100i0x1004-1array[0]0x10087array[1]0x100c3array[2]Stackmain0x10003SIZE0x10101i0x1004-1array[0]0x10087array[1]0x100c3array[2]Stackmain0x10003SIZE0x10102i0x1004-1array[0]0x10087array[1]0x100c3array[2]Stackmain0x10003SIZE0x10103i Figure 21.6: Traversal by index uses an index to walk through an array.
Thispatternofaccessingelementsiscalled traversalbyindex –weuseanintegerindexintherange [0, 𝑆𝐼𝑍𝐸 )where 𝑆𝐼𝑍𝐸is the size of the array, and we use the index to obtain the corresponding element. We can use the subscript operator or do pointer arithmetic ourselves.(The former is generally considered better, since it is more familiar and clearer to most programmers.However, you will often see both arr[0]and*arrused to access the first element.) Theactualsyntaxweuseisirrelevanttothepattern–whatmakesthistraversalbyindexisthatweuseanintegerindex to access the array, and we traverse through the elements by modifying the index.
Another pattern we can use is traversal by pointer , which walks a pointer across the elements of an array: int const SIZE = 3; // constant to represent array size intarray[SIZE] = { -1, 7, 3 }; int*end = array + SIZE; // pointer just past the end of arr for(int*ptr = array; ptr < end; ++ptr) { // walk pointer across arr cout << *ptr << endl; // dereference to obtain element } Here, we start by constructing a pointer that is just past the end of the array: the last element is at arr + SIZE - 1 , so we need to end our traversal when the pointer we are using reaches arr + SIZE . We then use another pointer that starts at the first element, dereference it to obtain an element, and then increment it to move on to the next element.Thesyntaxweusetodereferenceanelementisirrelevanttothepattern(itcanbe *ptrorptr[0])–whatmakesthis traversal by pointer is that we use a pointer to each element to access the array, and we traverse through the elements by modifying that pointer.
Traversal by index is the more common pattern when working with general arrays. However traversal by pointer is a special case of traversal by iterator, which we saw previously.We will shortly see that traversal by iterator/pointer allows us to write algorithms that work on both library containers and arrays.Thus, both the traversal-by-index and traversal-by-pointer patterns are important to programming in C++.Aside from providing us insight about memory and how objects are stored, arrays are a fundamental abstraction that can be used to build more complex abstractions.We proceed to see how to use arrays to build data structures such as 21.6.
Array Traversal 123 Programming and Data Structures, Release 0.3 0x1004-1array[0]0x10087array[1]0x100c3array[2]Stackmain0x10003SIZE0x10100x1004ptr0x10180x1010end0x1004-1array[0]0x10087array[1]0x100c3array[2]Stackmain0x10003SIZE0x10100x1008ptr0x10180x1010end0x1004-1array[0]0x10087array[1]0x100c3array[2]Stackmain0x10003SIZE0x10100x100cptr0x10180x1010end0x1004-1array[0]0x10087array[1]0x100c3array[2]Stackmain0x10003SIZE0x10100x1010ptr0x10180x1010end Figure 21.7: Traversal by pointer uses a pointer to walk through an array. vectors and sets.21.7 Arrays and const Sinceanarraydoesnothaveavalueofitsown,itcannotbeassignedtoasawhole–wesawpreviouslythatacompile error would result, since we cannot obtain an array value to place on the right-hand side of the assignment.Thus, it is also not meaningful for an array itself to be const either.
Similar to a reference, an array may not be const itself, but its elements may be: const double arr[4] = { 1.1, 2.3, -4.5, 8 }; arr[2] = 3.1; // ERROR -- attempt to assign to const object Thedeclaration const double arr[4] isreadinsideoutas“ arrisanarrayoffourconstantdoubles.”Theelements can be initialized through an initializer list, but they may not be modified later through assignment. If an array is a member of a class-type object, the array elements inherit the “constness” of the object itself.For example, consider the following: struct Foo { intnum; int*ptr; intarr[4]; }; Like anyconstobject, aconst Foo must be initialized upon creation: intmain() { intx = 3; constFoo foo = { 4, &x, { 1, 2, 3, 4 } }; ...} Thearraymembercanbeinitializedusingitsowninitializerlist,whichisthesamesyntaxforinitializingalocalarray variable.Aswesaw previously ,attemptingtomodify foo.num orfoo.ptr resultsinacompilererror.Thesameistrueforthe elements of foo.arr: 21.7.
Arrays and const 124 Programming and Data Structures, Release 0.3 Foo0x10080x1000ptr0x10044numarr:0x100c1arr[0]0x10102arr[1]0x10143arr[2]0x10184arr[3]fooStackmain0x10003x Figure 21.8: Contents of a Fooobject. Declaring the object as constonly prohibits modifications to the subobjects contained within the memory for the object.foo.arr[0] = 2; // ERROR Sine the array element is a subobject of a const object, it cannot be modified.21.7.Arrays and const 125 CHAPTER TWENTYTWO ARRAY-BASED CONTAINERS Acontainer is an abstract data type whose purpose is to hold objects of some other type.We have already seen two examplesofcontainers: built-inarraysandvectorsfromthestandardlibrary.Botharecontainersthatholdelementsin a particular order, indexed starting from 0.A built-in array has a fixed size, while a vector can grow and shrink.Let’s define our own container ADT, using built-in arrays as our building block.
Rather than an ordered sequence, we willbuildasetabstraction,whichrepresentsanunorderedcollectionofuniqueelements. Wewillstartwithacontainer that holds integers, generalizing it to arbitrary element types next time.In designing our ADT, we will use the following process: 1.Determine which operations our ADT will support.2.Write some code that uses our ADT.This will helps us figure out what the right interface should be, and it will serve as a test case.(Ideally, we would also write unit tests for each part of the public interface, following the pattern of test-driven development.) 3.Define the ADT’s public interface, including both function signatures and documentation.4.Come up with a data representation.Define member variables and determine the representation invariants.5.Write definitions for the ADT’s constructors and member functions, making sure that they adhere to the repre- sentation invariants.
22.1 Set Operations The following are the operations our set will support: •Creating an empty set. •Inserting a value into a set.We will allow an existing item to be inserted – it will just do nothing.•Removing a value from a set.We will allow a nonexistent item to be removed – it will just do nothing.•Check if a value is contained in a set.•Count the number of items in a set.•Print a character representation of a set to an output stream.126 Programming and Data Structures, Release 0.3 22.2 Code Example Here is a small program that uses a set: intmain() { IntSet set; set.insert(7); set.insert(32); set.insert(32); cout << "Size: " << set.size() << endl; // prints 2 set.print(cout); // prints { 7, 32 } in some arbitrary order set.insert(42); set.remove(32); set.remove(32); cout << "Contains 32?" << set.contains(32) << endl; // prints 0 (false) cout << "Contains 42?
" << set.contains(42) << endl; // prints 1 (true) } 22.3 Public Interface The code example leads to the following public interface: class IntSet { public: // Maximum size of a set. static const int MAX_SIZE = 10; // EFFECTS: Initializes this set to be empty.IntSet(); // REQUIRES: size() < MAX_SIZE // MODIFIES: *this // EFFECTS: Adds value to the set, if it isn 't already in the set.voidinsert( intvalue); // MODIFIES: *this // EFFECTS: Removes value from the set, if it is in the set.voidremove( intvalue); // EFFECTS: Returns whether value is in the set.boolcontains( intvalue) const; // EFFECTS: Returns the number of elements.intsize() const; // EFFECTS: Prints out the set in an arbitrary order.voidprint(std::ostream &os) const; }; 22.2.Code Example 127 Programming and Data Structures, Release 0.3 Thepublicinterfaceincludesadefaultconstructorandmemberfunctionstoinsertorremoveanitem,checkifanitem is in the set, obtain its size, and print a representation of the set to a stream.
The latter three functions do not modify theset,sotheyaredeclaredas const,meaningthatthe thispointerwillbeapointertoconst. Thecompilerwillthen enforce that those functions do not modify any member variables.22.4 staticData Members Thepublicinterfacealsoincludesaconstant, MAX_SIZE ,thatdenotesthemaximumsizeofaset.Wedefinetheconstant inside the IntSetclass.This distinguishes the constant from other constants of the same name; there may be some other ADT with a MAX_SIZE .It also makes use of encapsulation, which allows all of an ADT’s data and functionality to be defined together within a class.Theconstantisdeclared static,whichhasaspecificmeaningwhenusedinaclass–itindicatesthatthegivenmember isnotassociatedwithanobjectoftheclass,butwiththeclassasawhole.Foramembervariable,thismeansthatthere is a single copy of that variable in the program, located in static storage.Without the statickeyword, each object of the class would have its own copy, located in the memory for that object.
The statickeyword also allows a member variable to be a compile-time constant, provided it is also declared as const(orconstexpr ) and initialized from an expression that can be computed at compile time.1 A static member can be accessed by name from within the class, the same as a non-static member. It can be accessed from outside the class with the scope-resolution operator: intmain() { IntSet set; for(inti = 0; i < IntSet::MAX_SIZE; ++i) { set.insert(i); } } We need a compile-time constant because we will use a member variable that is a built-in array as part of our data representation.2In C++, a local or member variable that is an array must have a size that is known to the compiler.In the caseof a localvariable, the compilerneeds to knowhow big itis so thatthe program cancreate activation records of the correct size.For a member variable, the compiler needs to know its size so that it can determine the size of the object as a whole.
Pointer arithmetic (including array accesses) requires the compiler to know the size of an object at compile time, since it is in terms of whole objects rather than with respect to individual bytes. 22.5 Data Representation We rely on existing types to represent the data of our IntSet.For the elements themselves, we use a built-in array, withMAX_SIZE as its capacity.However, our set will start out empty, after which we can add and remove elements as we please.Thus, the size of the set will generally not be the same as the size of the array, and we need a separate member variable to keep track of the number of elements in the set.We will use an intfor this member.class IntSet { ...private: (continues on next page) 1Membervariablesthatare staticneednotbecompile-timeconstants.However,amembervariablethatisn’tacompile-timeconstantcannot be initialized at the point of declaration (unless it is declared as inlinein C++17 and onward).
The variable must be defined outside of the class, generally in a source ( .cpp) file. As with a member function, the scope-resolution operator is used to define a member variable outside the class (e.g.int IntSet::foo = 3; ).2In the future, we will see how to eliminate the fixed-size restriction by storing the elements indirectly using a dynamic array.We will see that this raises issues of memory management and learn how to resolve them.22.4.staticData Members 128 Programming and Data Structures, Release 0.3 (continued from previous page) intelements[MAX_SIZE]; intnum_elements; }; Now that we’ve determined a data representation, we need to figure out what values correspond to valid sets.We use representation invariants to specify the set of valid values.Fornum_elements ,anegativevaluedoesnotmakesense,sinceasetcannothaveanegativesize.Atthesametime,our setsdonothaveenoughspacetostoremorethan MAX_SIZE elements,sothatplacesanupperboundon num_elements .
The invariants for num_elements are thus0 <= num_elements && num_elements <= MAX_SIZE . Forelements , we need to know where in the array the set’s elements are actually stored.We will store them at the beginning of the array, so one invariant is that the first num_elements items in the array are the ones in the set.The set abstraction prohibits duplicate elements, so another invariant is that there are no duplicates among the first num_elements items inelements .We document the representation invariants where we define our representation: class IntSet { ...private: intelements[MAX_SIZE]; intnum_elements; // INVARIANTS: // 0 <= num_elements && num_elements <= MAX_SIZE // the first num_elements items in elements are the items in the set // the first num_elements items in elements contain no duplicates }; 22.6 size_t Thesize_ttyperepresentsonlynonnegativeintegers,andtheC++standardguaranteesthatitislargeenoughtohold the size of any object.
Since it does not represent negative integers, we could have used it for num_elements rather than defining 0 <= num_elements as a representation invariant. We would then also use size_tas the return type forsize(), which is what the standard-library containers do.C++hasintegraltypesthatare unsigned,whichdonotrepresentnegativenumbers,and size_tisjustoneexample.The inttypeissigned(unlessitisprecededbythe unsigned keyword).Unsignedintegerscanleadtosubtleprogramming errors.The following is an example that compares a signed and unsigned integer: intmain() { size_ts = 3; inti = -1; cout << (s < i) << endl; // prints 1 (true) } Perhaps non-intuitively, the comparison s < iis true, even though sis positive but iis negative.This is because the compiler converts ito asize_tin doing the comparison, and the data that represents a negative signed integer actually represents a very large unsigned integer.Another common error is incorrectly iterating backwards over a sequence: 22.6.
size_t 129 Programming and Data Structures, Release 0.3 intmain() { vector< int> vec = { 1, 2, 3 }; for(size_ti = vec.size() - 1; i >= 0; --i) { cout << vec[i] << endl; } } Thiscodegoesofftheendofthevector,resultinginundefinedbehavior. Thereasonisthata size_tisalwaysgreater than or equal to 0, and when iis equal to 0 and decremented, its value wraps around to the largest possible size_t value.The following iteration correctly avoids this problem: intmain() { vector< int> vec = { 1, 2, 3 }; for(size_ti = vec.size(); i > 0; --i) { cout << vec[i - 1] << endl; } } Theloopiteratesfrom vec.size() downto1,offsettingby1whenindexingintothevector.Thefollowingequivalent code makes use of postfix decrement to avoid the offset in the index expression: intmain() { vector< int> vec = { 1, 2, 3 }; for(size_ti = vec.size(); i-- > 0;) { cout << vec[i] << endl; } } Giventhepitfallsofunsignedintegers,manyC++programmersavoidthem,usingsignedintegersinstead.Wetoowill generally stick to signed integers.
22.7 Implementation Weproceedtodefinetheconstructorandmemberfunctionsof IntSet,definingthemastheywouldappearinasource file, outside the class definition. We require only a default constructor for IntSet.However, we cannot rely on a compiler-generated implicit one: it would default initialize num_elements to an undefined value, violating our representation invariants.Thus, we need to define our own default constructor.3 IntSet::IntSet() : num_elements(0) {} Weneednotdoanythingwith elements .Itgetsdefaultinitializedtocontainundefinedvalues,butthatdoesn’tviolate our representation invariants; since num_elements is 0, the invariants for elements are trivially satisfied.Weproceedtodefine contains() .Therepresentationinvariantstellusthatthevaliditemsarethefirst num_elements inelements .They can be stored in any order, so we need to iterate through them to see if the value is in the set.
boolIntSet::contains( intvalue) const{ for(inti = 0; i < num_elements; ++i) { (continues on next page) 3Alternatively,wecaninitialize num_elements to0atthepointitisdeclared. Theimplicitlydefineddefaultconstructorwouldthenbesufficient; it would still have an empty member-initializer list, but the compiler uses the inline initialization of a member variable if it is not initialized in the member-initializer list.22.7.Implementation 130 Programming and Data Structures, Release 0.3 (continued from previous page) if(elements[i] == value) { returntrue; } } returnfalse; } When we find an item, we can return immediately without checking the rest of the elements.On the other hand, if we get through all the elements without finding the given value, it is not in the set so we return false.For inserting into the set, we first assert the requires clause, which ensures that our invariant of num_elements <= MAX_SIZE isneverviolated.
Wealsomustcheckwhetherthevalueisintheset,sinceaddingitagainwouldviolationthe invariantofnoduplicates. Ifthevalueisnotintheset,thesimplestwaytoinsertitistoplaceitatindex num_elements and increment that variable.This meets the invariant that the first num_elements items in the array are the values in the set.voidIntSet::insert( intvalue) { assert(size() < MAX_SIZE); if(!contains(value)) { elements[num_elements] = value; ++num_elements; // we could use num_elements++ in the line above instead } } To remove an element, we first need to check whether the value is in the set.If so, we need to know its location in the array, which would require iterating through the elements to find it.Rather than repeating this algorithm in both contains() andremove() , we define a private helper function to do so and call it in both places.class IntSet { ...
private: intindexOf( intvalue) const; }; intIntSet::indexOf( intvalue) const{ for(inti = 0; i < num_elements; ++i) { if(elements[i] == value) { returni; } } return-1; } Rather than returning whether or not the value is in the set, indexOf() returns its actual index if it is there. If not, it returns an invalid index; we use -1, since indices start at 0.We can then write contains() as follows: boolIntSet::contains( intvalue) const{ returnindexOf(value) != -1; } We proceed to define remove() : 22.7.Implementation 131 Programming and Data Structures, Release 0.3 voidIntSet::remove( intvalue) { intindex = indexOf(value); if(index != -1) { elements[index] = elements[num_elements - 1]; --num_elements; } } Inordertoactuallyremovetheitem,weneedtoplaceanotheritematitslocation.Thesimplestsolutionthatmeetsthe representation invariants is to copy over the last item and then decrement num_elements , which ensures that the first num_elements items are the values in the set.
elementsnum_elements47635012345678953 Figure 22.1: Removing an element from an unordered set can be done by copying the last element into the position vacated by the removed element. The remaining member functions are defined as follows: intIntSet::size() const{ returnnum_elements; } voidIntSet::print(std::ostream &os) const{ os << "{ "; for(inti = 0; i < num_elements; ++i) { os << elements[i] << " "; } os << "}"; } 22.8 Sorted Representation Therepresentationof IntSetplacesnorestrictionsontheorderingofelementsinthearray.Thissimplifiestheimple- mentationof insert() andremove() ,butitrequires contains() (andindexOf() )toiterateovereveryelementin the worst case.Analternaterepresentationwouldbetorequirethatthesetelementsarestoredinsorted,increasingorder.Themember variables remain the same – it is the representation invariants that change.class SortedIntSet { ...private: intelements[MAX_SIZE]; intnum_elements; // INVARIANTS: (continues on next page) 22.8.
Sorted Representation 132 Programming and Data Structures, Release 0.3 (continued from previous page) // 0 <= num_elements && num_elements <= MAX_SIZE // the first num_elements items in elements are the items in the set // the first num_elements items in elements contain no duplicates // the first num_elements items are in sorted, increasing order }; To insert an item, we can no longer just put it after the existing elements, since the new value may be smaller than existing values. Instead, we need to store it at its appropriate sorted position.This requires moving existing elements out of the way if necessary.Our algorithm will start after the last element and repeatedly: •Compare the item to the left with the value we are inserting.•Iftheitemtotheleftislessthanthenewvalue,thenewvalueisplacedatthecurrentposition,andwearedone.•If the item is greater than the new value, then the old item is moved one position to the right, and we repeat the process one position over to the left.
•If no more items are to the left, we place the new value at the current position (i.e. the beginning of the array).elementsnum_elements43567012345678945675 Figure 22.2: Inserting into an ordered set requires shifting existing elements to make room for the new element at the proper location.voidSortedIntSet::insert( intvalue) { assert(size() < MAX_SIZE); if(!contains(value)) { intindex = num_elements; while(index > 0 && elements[index - 1] > value) { elements[index] = elements[index - 1]; --index; } elements[index] = value; ++num_elements; } } Similarly, to remove an item, we must shift the remaining elements leftward in order to maintain our representation invariants.elementsnum_elements435670123456789673 Figure 22.3: Removing from an ordered set requires shifting elements to preserve the representation invariants.22.8.
Sorted Representation 133 Programming and Data Structures, Release 0.3 voidSortedIntSet::remove( intvalue) { intindex = indexOf(value); if(index != -1) { for(; index < num_elements - 1; ++index) { elements[index] = elements[index + 1]; } --num_elements; } } The advantage of sorting is that we don’t have to look through all the elements to determine the location of a value. Instead, we can use binary search , which eliminates half the search space in each step: •Compare the value we are looking for to the middle element among the remaining items.•If the value is equal to the middle element, we have found its index.•If the value is less than the middle element, we know it must be to the left, if it is in the set.Thus, we need only repeat the search on the items in the first half.•If the value is greater than the middle element, we know it must be to the right, if it is in the set.Thus, we need only repeat the search on the items in the second half.
•If we have run out of elements to search, the value is not in the set. The following implements this algorithm: intSortedIntSet::indexOf( intvalue) const{ intstart = 0; intend = num_elements; while(start < end) { intmiddle = start / 2 + end / 2; if(value == elements[middle]) { returnmiddle; }else if (value < elements[middle]) { end = middle; }else{ start = middle + 1; } } return-1; } Sincehalfthesearchspaceiseliminatedineachstep,thisalgorithmtakestimethatislogarithmicinthesizeoftheset.We denote this as O (log𝑛), where 𝑛is the number of elements in the set.For a set of size 𝑛, the following compares the worst-case runtime of each operation on unsorted and sorted sets: Operation Unsorted Set Sorted Set insert() O(𝑛) O(𝑛) remove() O(𝑛) O(𝑛) contains() O(𝑛) O(log𝑛) size() O(1) O(1) constructor O(1) O(1) The notation O (1)means that the operation takes constant time: the time it takes is independent of the size of the set.22.8.
Sorted Representation 134 Programming and Data Structures, Release 0.3 Theinsert() andremove() operations must first check whether the item is in the set, so they can be no faster than contains() . The latter is significantly faster on a sorted set than an unsorted set, demonstrating the advantage of sorting.22.8.Sorted Representation 135 CHAPTER TWENTYTHREE CONTAINER ADTS AND POLYMORPHISM We continue our discussion of container ADTs by examining several forms of polymorphism in the context of con- tainers.Wewillstartbylookingatoperatoroverloading,aformofadhocpolymorphism,andthenproceedtodiscuss parametric polymorphism.23.1 Operator Overloading C++followsthephilosophythatuser-definedtypesshouldhavethesameaccesstolanguagefacilitiesasbuilt-intypes.Since operators can be used with built-in atomic types, C++ allows operators to be applied to class types through operator overloading .Most operators in C++ can be overloaded.
An operator overload requires at least one of the operands to be of class type1– the behavior of operators on atomic types cannot be changed. When the compiler encounters an operator where at least one operand is of class type, it looks for a function whose name isoperator followed by the symbol for the actual operator.For example, if +is applied to two IntSets, the compiler looks for a function with name operator+ that can be applied to two IntSetobjects.For most operators, the function can either be a top-level function or a member of the type of the left-most operand, if it is of class type.The following is a member function that defines the +operation to compute the union of two IntSets: class IntSet { ...
public: IntSet operator +(constIntSet &rhs) const; }; IntSet IntSet:: operator +(constIntSet &rhs) const{ IntSet result = * this; for(inti = 0; i < rhs.num_elements; ++i) { result.insert(rhs.elements[i]); } returnresult; } Thefunctionfirstcopiesoverthereceiverobjectintoanewlocal IntSet. Ittheniteratesovertheelementsintheother IntSet, inserting them into the result.As we saw last time, the insert() function only inserts an element if the set does not already contain the item.We can now call the member function directly, or we can apply the +operator instead.When we do so, the compiler finds the overloaded operator+() and calls it for us.1The operand can also be of enumeration type, which is beyond the scope of this course.136 Programming and Data Structures, Release 0.3 intmain() { IntSet set1; set1.insert(32); set1.insert(42); set1.insert(7); IntSet set2; set2.insert(12); set2.insert(-3); set2.insert(42); IntSet set3 = set1.
operator +(set2); set3.print(cout); // prints { 32, 42, 7, 12, -3 } IntSet set4 = set1 + set2; set4.print(cout); // prints { 32, 42, 7, 12, -3 } } In theory, we could instead define the overloaded operator as a top-level function, declared as follows: IntSet operator +(constIntSet &lhs, constIntSet &rhs); However, we did not define an interface for iterating through the elements of an IntSetfrom outside the class, so we cannot actually implement this function. Overloaded operators can take arguments by value or by reference, like any other function.In most cases, we pass the arguments by reference to avoid making a copy.Thoughmostoperatorscanbeoverloadedeitherastop-levelormemberfunctions,therearesomecaseswherewemust use a top-level function: •The first operand is of atomic type.Atomic types are not classes, so they do not have member functions.•The first operand is of class type, but we do not have access to the class definition, so we cannot define a new member function.
An example of the latter is overloading the stream-insertion operator, where we do not have access to the definition of ostream. The following overloads insertion of an IntSet: std::ostream & operator <<(std::ostream &os, constIntSet &set) { set.print(os); returnos; } Wesawpreviouslythatinsertingtoastreamevaluatesbacktothestreamobject.Tosupportthisproperly,ouroverload returns the given stream object.It must return the object by reference: •Streams cannot be copied, so the code would not compile if it returned a stream by value.•Even if streams could be copied, we want to return the original stream object itself, not a copy.•Even if a copy would work, we would end up with object slicing, since osactually will refer to an object of a class that derives from ostream.The parameters are in the same order as the operands, from left to right.The function need only call the print() member function on the IntSetand then return the given ostream object.
Then we can insert an IntSetdirectly into a stream: 23.1. Operator Overloading 137 Programming and Data Structures, Release 0.3 intmain() { IntSet set; set.insert(32); set.insert(42); cout << set << endl; // prints { 32, 42 } } In other cases, we need to define an operator as a member function: •If the overload needs access to private members, a member function would have access because it is part of the class.2 •Some operators can only be overloaded as member functions: the assignment operator ( =), the function-call operator ( ()), the subscript operator ( []), and the arrow operator ( ->).(We will see examples of overloading the first two operators later.) Asanexample,let’soverloadthesubscriptoperatortocheckwhetherthegivenvalueisintheset.Thefollowingdoes so: class IntSet { ...
public: bool operator [](intvalue) const; }; boolIntSet:: operator [](intvalue) const{ returncontains(value); } The following is an example of applying the operator: intmain() { IntSet set; set.insert(32); cout << set[32] << endl; // prints 1 (true) cout << set[42] << endl; // prints 0 (false) } 23.2 Parametric Polymorphism TheIntSetcontaineronlyholdselementsthatareoftype int. Supposewewantedanothercontainerthatholds char values.Onesolutionistocopyandpastethe IntSetcode,thenchange inttochareverywhereitreferstotheelement type: class CharSet { public: // Maximum size of a set.static const int MAX_SIZE = 10; // EFFECTS: Initializes this set to be empty.(continues on next page) 2Inthefuture,wewillseethatwecanusea frienddeclaration togiveanoutsideclassorfunctionaccesstoprivatemembers.Frienddeclarations are sometimes used with operator overloads.23.2.
Parametric Polymorphism 138 Programming and Data Structures, Release 0.3 (continued from previous page) CharSet(); // REQUIRES: size() < MAX_SIZE // MODIFIES: *this // EFFECTS: Adds value to the set, if it isn 't already in the set. voidinsert( charvalue); // MODIFIES: *this // EFFECTS: Removes value from the set, if it is in the set.voidremove( charvalue); // EFFECTS: Returns whether value is in the set.boolcontains( charvalue) const; // EFFECTS: Returns the number of elements.intsize() const; // EFFECTS: Prints out the set in an arbitrary order.voidprint(std::ostream &os) const; private: charelements[MAX_SIZE]; intnum_elements; // INVARIANTS: // 0 <= num_elements && num_elements <= MAX_SIZE // the first num_elements items in elements are the items in the set // the first num_elements items in elements contain no duplicates }; This is not a very satisfying solution.It leads to duplication of nearly identical code.
Furthermore, if we then wanted a set ofdoubles, we would have to define an almost identical DoubleSet , and so on. We already know how to avoid code duplication when we have a value that can be different: add a function parameter thatallowstheusertospecifythevaluetheycareabout.Theproblemhereisthatourentitythatdiffersisnotavalue,but atype.Whilefunctionparameterscanrepresentdifferentargumentvalues,weneedanothermechanismforspecifying type arguments .The mechanism that C++ provides is a template.Atemplateisamodelforproducingcode.Wewriteagenericversion,parameterizedbyoneormore templateparam- eters.The compiler then instantiates a specific version of the code by substituting arguments for the parameters and compiling the resulting code.We specify a template and its parameters by placing a template header before the entity that we are defining.template <typename T > class UnsortedSet { ...
}; The template header can go on the same line or the previous one: whitespace generally does not matter in C++. The header begins with the template keyword, followed by a parameter list surrounded by angle brackets.Within the parameter list, we introduce a template parameter by specifying the kind of entity the parameter can represent.The typename keywordindicatesthattheparameterisatypeparameter.3Theparameternamethenfollows.Here,wehave 3Theclasskeyword can be used instead of typename ; the two are equivalent in this context.With either keyword, a non-class type can still be used as the type argument.23.2.Parametric Polymorphism 139 Programming and Data Structures, Release 0.3 chosenthename T,sincewedon’thavefurtherinformationaboutthetype.( Value_type orElement_type areother common names to use with a container.) Atemplatemayhavemorethanoneparameter,anditcanalsohaveaparameterthatisofintegraltype.
Thefollowing is how the std::array template is declared: template <typename T , std:: size_tN> class array ; Since the entity that follows the template header is a class, it is a class template . It takes two arguments, one for the element type and the other for the size of the container, which must be a compile-time constant.We can then create a std::array of 10ints as follows: std::array< int, 10> items; The syntax for using a class template is to follow the name of the template with an argument list enclosed by angle brackets.We can similarly create and use an unsorted set of chars: UnsortedSet< char> char_set; char_set.insert( 'e'); char_set.insert( 'a'); char_set.insert( 'e'); cout << char_set << endl; // prints { e, a } Inorderforthistowork,wewritethedefinitionof UnsortedSet tousethetemplateparameter Tfortheelementtype.The scope of a template parameter is the entire entity that follows; if it is a class, then the scope is the entire class definition.
template <typename T > class UnsortedSet { public: // Maximum size of a set. static const int MAX_SIZE = 10; // EFFECTS: Initializes this set to be empty.UnsortedSet(); // REQUIRES: size() < MAX_SIZE // MODIFIES: *this // EFFECTS: Adds value to the set, if it isn 't already in the set.voidinsert( constT &value); // MODIFIES: *this // EFFECTS: Removes value from the set, if it is in the set.voidremove( constT &value); // EFFECTS: Returns whether value is in the set.boolcontains( constT &value) const; // EFFECTS: Returns the number of elements.intsize() const; // EFFECTS: Prints out the set in an arbitrary order.voidprint(std::ostream &os) const; (continues on next page) 23.2.
Parametric Polymorphism 140 Programming and Data Structures, Release 0.3 (continued from previous page) private: T elements[MAX_SIZE]; intnum_elements; // INVARIANTS: // 0 <= num_elements && num_elements <= MAX_SIZE // the first num_elements items in elements are the items in the set // the first num_elements items in elements contain no duplicates }; Theactualtypeargumentusedtoinstantiate UnsortedSet maybesomethingsmalllike int,oritmaybealargeclass typesuchas string. Thus,itisgoodpracticetopassobjectsofatemplateparameterbyreferenceratherthanbyvalue, avoiding copying potentially large objects.Whenweuse UnsortedSet withaparticulartypeargument,thecompileractuallyplugstheargumentinfor T,gener- ating code for that instantiation and compiling it with the rest of the program.For example, UnsortedSet<string> is instantiated as follows: class UnsortedSet <string> { public: // Maximum size of a set.static const int MAX_SIZE = 10; // EFFECTS: Initializes this set to be empty.
UnsortedSet(); // REQUIRES: size() < MAX_SIZE // MODIFIES: *this // EFFECTS: Adds value to the set, if it isn 't already in the set. voidinsert( conststring &value); // MODIFIES: *this // EFFECTS: Removes value from the set, if it is in the set.voidremove( conststring &value); // EFFECTS: Returns whether value is in the set.boolcontains( conststring &value) const; // EFFECTS: Returns the number of elements.intsize() const; // EFFECTS: Prints out the set in an arbitrary order.voidprint(std::ostream &os) const; private: string elements[MAX_SIZE]; intnum_elements; // INVARIANTS: // 0 <= num_elements && num_elements <= MAX_SIZE // the first num_elements items in elements are the items in the set // the first num_elements items in elements contain no duplicates }; 23.2.Parametric Polymorphism 141 Programming and Data Structures, Release 0.3 23.2.1 Function Templates Wecanalsodefineafunctionasatemplate,resultingina functiontemplate .
Forexample,thefollowingcomputesthe maximum of two items of the same type: template <typename T > T max( constT &value1, constT &value2) { returnvalue2 > value1 ? value2 : value1; } As with a class template, we define a function template by preceding it with a template header, which introduces one or more template parameters.We can then use the parameter anywhere in the function definition.Here, our function template takes two arguments of the same type and compares them.The ?:operator is a conditional.It evaluates its first operand, and if the result is true, it produces the second operand.Otherwise, it produces the third operand.
Similar to a class template, we can use a function template by following its name with an argument list enclosed by angle brackets:4 intmain() { inti1 = 3; inti2 = -3; cout << max< int>(i1, i2) << endl; cout << max< double>(3.1, 7.5) << endl; } Unlikeaclasstemplate,however,thecompilerisableinmostcasesto deducethetemplateargumentfromthearguments tothefunctioncall. Inthefirstcallabove,theargumentsarebothoftype int,sothecompilercandeducethatwewant intas the template argument.Similarly, the arguments are both of type doublein the second call, so the compiler can deduce we want double.Thus, we can leave off the explicit template arguments: intmain() { inti1 = 3; inti2 = -3; cout << max(i1, i2) << endl; // deduced as max<int>(i1, i2) cout << max(3.1, 7.5) << endl; // deduced as max<double>(3.1, 7.5) } Themax()function template can only be applied to a type that supports the >operator.
If we try to call it on objects that don’t support the operator, the result is a compile error: intmain() { Duck d1("Donald"); Duck d2("Scrooge"); Duck best_duck = max(d1, d2); cout << best_duck.get_name() << " wins!" << endl; } This results in an error like the following: main.cpp: In instantiation of 'T max(const T&, const T&) [with T = Duck] ': main.cpp:20:30: required from here main.cpp:14:17: error: no match for 'operator> '(operand types are 'const Duck 'and (continues on next page) 4Dependingonthecompilerandwhatheadersareincluded,wemayhavetotellthecompilerthatweintendtouseour max()functiontemplate rather than the one in the standard library. We can do so by using the scope-resolution operator with nothing to the left: ::max<double>(3.1, 7.5).23.2.Parametric Polymorphism 142 Programming and Data Structures, Release 0.3 (continued from previous page) ˓→'const Duck ') return value2 > value1 ?
value2 : value1; ~~~~~~~^~~~~~~~ Theoffendinglineofcodeistheonemarkedas“requiredfromhere”–itisthelinethatattemptstocall max()ontwo Duckobjects. The compiler actually instantiates max<Duck>() , but the resulting instantiation produces errors when the compiler tries to compile it.23.2.2 Compiling Templates WesawpreviouslythattheC++compiler onlyneedsaccesstodeclarations whencompilingcodethatusesaclassora functiondefinedinsomeothersourcefile.However,thisisnotthecaseforclassandfunctiontemplates.Thecompiler mustactuallyinstantiatethedefinitionsforeachsetoftemplatearguments,soitmusthaveaccesstothefulldefinition of a template.To provide the compiler with access to the full definition of a template wherever it is used, we must arrange for the headerfiletocontainthefulldefinition.Wecanjustdefinethetemplatedirectlyintheheaderfileitself;itisstillgood practice to separate the declarations from the definitions for the benefit of anyone using our code.
// max.hpp // EFFECTS: Returns the maximum of value1 and value2. template <typename T > T max( constT &value1, constT &value2); ...template <typename T > T max( constT &value1, constT &value2) { returnvalue2 > value1 ?value2 : value1; } A better organization is to separate the definitions into their own file; common convention is to use a suffix like .tpp for this file.We can then use a #include directive to pull the code into the header file: // max.hpp // EFFECTS: Returns the maximum of value1 and value2.template <typename T > T max( constT &value1, constT &value2); #include "max.tpp" // max.tpp template <typename T > T max( constT &value1, constT &value2) { returnvalue2 > value1 ?value2 : value1; } Code that uses the maxmodule would then just #include "max.hpp" , which would transitively include max.tpp.23.2.
Parametric Polymorphism 143 Programming and Data Structures, Release 0.3 23.2.3 Include Guards Incomplexprograms,itisoftenthecasethatasinglefileinadvertently #include sthesameheaderfilemorethanonce. For instance, it may be that module A depends on module B and thus includes its header.Then module C depends on both A and B, so it includes both their headers.This results in module C including B’s header twice, which can cause compiler errors that a function or a class is defined more than once.To avoid problems with a header being included more than once, headers generally have include guards that arrange for the compiler to ignore the code if the header is included a second time.The following is an example of include guards: #ifndef MAX_HPP #define MAX_HPP // max.hpp // EFFECTS: Returns the maximum of value1 and value2.
template <typename T > T max( constT &value1, constT &value2); #include "max.tpp" #endif /* MAX_HPP */ The#ifndef and#define directivesaretheopeningoftheincludeguard,andthe #endifclosesit. Thecodewithin is ignored if the header is included again.5 23.2.4 Member-Function Templates Defining a member function within the definition for a class template is no different than a member function within a class.Defining a member function outside the definition of a class template differs from that of a regular class; we must inform the compiler that the function is a member of a class template.template <typename T > boolUnsortedSet<T>::contains( constT &value) const{ returnindexOf(value) != -1; } template <typename T > voidUnsortedSet<T>::insert( constT &value) { assert(size() < MAX_SIZE); if(!contains(value)) { elements[num_elements] = value; ++num_elements; } } Here, we must tell the compiler that contains() is a member of UnsortedSet<T> .
However, before we can use the nameT, we need to introduce it with a template header. The scope of a template header is the entity that immediately follows; thus, each member-function definition needs its own template header.5The#ifndef checks whether the macroMAX_HPP is defined.If not, the compiler processes the code between the #ifndef and the#endif.The#define introduces a definition for MAX_HPP.The next time the header is included, MAX_HPP is defined, so the #ifndef becomes false, and the compiler ignores the code between the #ifndef and#endif.A widely supported but nonstandard alternative is #pragma once , which need only be placed at the top of file.23.2.
Parametric Polymorphism 144 Programming and Data Structures, Release 0.3 23.2.5 Insertion-Operator Template Nowthatwehavean UnorderedSet classtemplate,wecanwriteaninsertionoperatorthatworksonanyinstantiation by defining it as a function template: template <typename T > std::ostream & operator <<(std::ostream &os, constUnsortedSet<T> &set) { set.print(os); returnos; } The function template is parameterized by the element type of an UnorderedSet , and we use the template parameter as part of the type for the second function parameter. The compiler is able to deduce the template argument when we insert a set into a stream: UnsortedSet< char> char_set; char_set.insert( 'e'); char_set.insert( 'a'); char_set.insert( 'e'); cout << char_set << endl; // prints { e, a } 23.2.6 Another Example Let us write a function template that copies elements from an array into a set.
We would like to use it as follows: intmain() { UnsortedSet< int> set1; intarr1[4] = { 1, 2, 3, 2 }; fill_from_array(set1, arr1, 4); cout << set1 << endl; // prints { 1, 2, 3 } UnsortedSet< char> set2; chararr2[3] = { 'a','b','a'}; // prints { a, b } fill_from_array(set2, arr2, 3); } Thefill_from_array() template must be parameterized by the element type, and we use that type for both the set and array function parameters: template <typename T > voidfill_from_array(UnsortedSet<T> &set, constT *arr, intsize) { for(inti = 0; i < size; ++i) { set.insert(arr[i]); } } The set is passed by reference, to avoid making a copy and to allow the function to modify the original set. The array decaysintoapointerwhenitispassed,andwedeclarethepointerasapointertoconst,sincewedonotneedtomodify the array elements.
The body of the function template just iterates over the array, inserting each element into the set; thesetignoresinsertionofduplicatevalues,sothereisnoneedtocheckwhetherthesetalreadycontainsavaluebefore inserting it. 23.2.Parametric Polymorphism 145 Programming and Data Structures, Release 0.3 23.3 Static vs.Dynamic Polymorphism The template mechanism gives us parametric polymorphism; a template type parameter can take on the form of any type.Thecompilerinstantiatesthecodeatcompiletime,sowealsorefertothisas staticpolymorphism .Comparethis with subtype polymorphism, where the program resolves virtual function calls at runtime; we therefore use dynamic polymorphism to also refer to it.In designing an ADT, we have the choice of static polymorphism, dynamic polymorphism, or both.For instance, SortedSet andUnsortedSet share the same interface, so we could define a common base interface and make use of dynamic binding.
However, dynamic polymorphism comes with a runtime performance cost; a virtual function call generally requires two extra pointer dereferences compared to a non-virtual call. For a container, a program may makemanycallstoinsertitems,removeitems,checkwhetheranitemisinthecontainer,andsoon.Thus,thegeneral convention in C++ is to avoid dynamic polymorphism with containers.Another reason why dynamic polymorphism is not a good fit for a container is that we usually make the decision of whichcontainertousewhenwewriteourcode,notwhenwerunit.However,itisstillgoodpracticetowriteourcode in such a way that we can easily change the container type we are using.Ideally, we would have a single location in our code that needs to change if we decide to use something else.We’ve seen this pattern already when it comes to a value that is used in many places: define a constant or variable, and use the associated name rather than the value directly.
Thus,introducinganewnameforanentityisapowerfulformofabstraction,allowingustoavoidhardcoding the entity everywhere in our code. C++ gives us this capability for types with type aliases.23.3.1 Type Aliases Atype alias is a new name for an existing type.We can introduce a type alias with a using declaration : usingUnsortedIntSet = UnsortedSet< int>; The syntax for introducing a type alias with a using declaration is the usingkeyword, followed by the name we want to introduce, the =symbol, and the existing type that we want the name to alias.The example above introduces the nameUnsortedIntSet as an alias for the type UnsortedSet<int> .A simple alias can also be defined with the typedef keyword: typedef UnsortedSet< int> UnsortedIntSet; The syntax is in the reverse order of a using declaration: the existing type first, then the new alias.Ausingdeclaration(butnotatypedef)canalsodefinean aliastemplate ,whichintroducesanewnamethatisatemplate for a set of types.
The following is an example: template <typename T > usingSet = UnsortedSet<T>; Similar to any template, we introduce an alias template by placing a template header with the requisite parameters before the using declaration. Then we can use Setin the same way we would a class template: template <typename T > usingSet = UnsortedSet<T>; template <typename T > voidfill_from_array(Set<T> &set, constT *arr, intn); intmain() { (continues on next page) 23.3.Static vs.Dynamic Polymorphism 146 Programming and Data Structures, Release 0.3 (continued from previous page) Set< int> set1; intarr1[4] = { 1, 2, 3, 2 }; fill_from_array(set1, arr1, 4); Set< char> set2; chararr2[3] = { 'a','b','a'}; fill_from_array(set2, arr2, 3); } The compiler treats Set<int> andSet<char> asUnsortedSet<int> andUnsortedSet<char> , sinceSetis an alias forUnsortedSet .
If we decide to use sorted sets instead, there is just one place we need to change: template <typename T > usingSet = SortedSet<T>; Now the compiler will treat Set<int> andSet<char> asSortedSet<int> andSortedSet<char> . 23.3.2 The Factory Pattern With dynamic polymorphism, we can defer the decision of which derived class to use until runtime.For example, the following code asks the user for what color bird they want, then calls a factoryfunction to create the actual object: intmain() { string color; cin >> color; Bird *bird = Bird_factory(color, "Myrtle"); cout << "Bird " << bird->get_name() << " is " << bird->get_age() << " and says: " << bird->talk() << endl; deletebird; cin >> color; bird = Bird_factory(color, "Heihei"); cout << "Bird " << bird->get_name() << " is " << bird->get_age() << " and says: " << bird->talk() << endl; deletebird; } The factory function creates an object of the appropriate derived type and returns a pointer to it.
It cannot create the object in local memory – a local object dies when the function that created it returns, so it would not live past the call toBird_factory() . Instead, we create it in dynamic memory with thenewoperator: Bird * Bird_factory( conststring &color, conststring &name) { if(color == "blue") { return new BlueBird(name); }else if (color == "black") { return new Raven(name); } ...} We then use the deleteoperator on the object’s address when we no longer need it.We will start looking at dynamic memory in more detail next time.23.3.Static vs.Dynamic Polymorphism 147 Programming and Data Structures, Release 0.3 23.3.3 Liskov Substitution Principle Whendesigninganinheritancehierarchy,animportantpropertyis substitutability ofaderived-classobjectforabase- class one.
This notion is formalized by the Liskov substitution principle , which states that in order for type 𝑆to be a subtypeof type 𝑇, the following requirement must be met: Any property of objects of type 𝑇should also be a property of objects of type 𝑆. —Barbara Liskov, MIT This implies that in any code that depends on 𝑇’s interface, an object of type 𝑆can be substituted without any unde- sirable effects.If the requirement above is not satisfied, 𝑆would be a derived type of 𝑇but not a subtype.A classic example is a ToyDuck class that derives from Duck: class ToyDuck :publicDuck { ...public: // EFFECTS: Prints out quack if battery level >= 10.voidtalk() const override { if(battery_level >= 10) { cout << "quack" << endl; --battery_level; } } }; Codethatusesa Duckmayassumethataquackingnoisegetsprintedouteachtime talk()iscalled.A ToyDuck would violate this expectation, since it does not print anything out if the ToyDuck has insufficient battery.
Thus, ToyDuck is a derived type of Duck, but not a subtype. 23.3.Static vs.Dynamic Polymorphism 148 Programming and Data Structures, Release 0.3 Figure 23.1: Liskov substitution principle.Credit: Derick Bailey, retrieved from Stack Overflow 23.3.Static vs.Dynamic Polymorphism 149 CHAPTER TWENTYFOUR MEMORY MODELS AND DYNAMIC MEMORY Recall that an object is a piece of data in memory , located at some address in memory.An object also has a storage durationthat determines its lifetime.In this course, we consider three storage durations: •static: the lifetime is essentially the whole program •automatic (also called local): the lifetime is tied to a particular scope, such as a block of code •dynamic: the object is explicitly created and destroyed by the programmer The first two durations are controlled by the compiler, and an object with static or automatic scope is associated with a variable.
Objects with dynamic storage are managed by the programmer, and they are not directly associated with variables. The following variables refer to objects with static storage duration: •global variables1 •static member variables •static local variables Thelifetimeoftheseobjectsisessentiallythewholeprogram,sotheycanbeusedatanypointintimeintheprogram.2 24.1 Static Local Variables We have already seen global and static member variables.A static local variable is a local variable declared with the statickeyword.Rather than living in the activation record for a function call, it is located in the same region of memory as other variables with static storage duration, and there is one copy of each static local variable in the entire program.
The following is an example: intcount_calls() { static int count = 0; return++count; } intmain() { cout << count_calls() << endl; // prints 1 cout << count_calls() << endl; // prints 2 cout << count_calls() << endl; // prints 3 cout << count_calls() << endl; // prints 4 } 1Also those defined at namespace scope. 2Initialization in C++ is rather complicated, and the details are beyond the scope of this course.A relatively safe assumption is that variables withstaticstoragedurationcanbeinitializedinanyorderbefore main()isrun,butthattheyhaveallbeeninitializedbythetime main()iscalled.150 Programming and Data Structures, Release 0.3 Thecountstatic local variable is initialized to 0, so its value is 0 the first time count_calls() is called.The call increments countandreturnsthenewvalueof1.Thenexttime count_calls() iscalled,counthasvalue1.Itgets incremented again, and the call returns 2.And so on.
Thus, all calls to count_calls() use the same countobject, unlike a non-static local variable, where each call would get its own object. 24.2 Automatic Storage Duration Functionparametersandlocalvariableshaveautomaticstorageduration,alsocalledlocalstorageduration.Thelifetime oftheassociatedobjectcorrespondstothevariable’s scope,theregionofcodewhereitisvalidtorefertothevariable.Thescopeofavariablebeginsatitspointofdeclarationandendsattheendofthescoperegioninwhichitisdefined.A scope region can be the body of a function, a whole loop or conditional, the body of a loop or conditional, or just a plainblockdenoted by curly braces.
For example, consider the following code: voidfunc( intx) { for(inti = 2; i < 10; ++i) { string s = " cats"; cout << i << s << endl; }// end scope of i, s inty = 10; { intz = -3; cout << x << " " << y << " " << z << endl; }// end scope of z }// end scope of x, y The variables fall into the following categories; •The scope of a parameter is the entire function body. Thus, the lifetime of the object associated with xbegins when the function is called and ends when the function returns.•The scope of a variable declared in a loop header is the entire loop.Thus, the lifetime of the object ibegins when the loop starts and ends when the loop exits.•The scope of a variable declared within a block is from its point of declaration to the end of the block.The lifetime of sbegins when its initialization runs and ends at the end of a loop iteration – a new object associated withsis created in each iteration.
The lifetime of yalso begins when its initialization runs, and it ends when the function returns. Lastly, the lifetime of zstarts when its declaration is run and ends when the code exits the block containing z‘s declaration.Scopegenerallypreventsusfromusingalocalvariablebeyondthelifetimeofitsassociatedobject.However,indirection through a pointer or reference can circumvent this protection.The following is an example: int*func1() { intx = 3; return&x; } voidfunc2() { inty = 5; } (continues on next page) 24.2.Automatic Storage Duration 151 Programming and Data Structures, Release 0.3 (continued from previous page) intmain() { int*z = func1(); func2(); assert(*z == 3); // ASSERTION FAILURE } Stackmainfunc10x10083x0x1000?zStackmain0x1000?zStackmain0x10000x1008zStackmainfunc20x10085y0x10000x1008zStackmain0x10000x1008z Figure 24.1: Returning the address of a local variable results in a pointer that refers to a dead object.Dereferencing the pointer produces undefined behavior.
Whentheprogramcalls func1(),itplacestheactivationrecordonthestack,with xinsideoftheactivationrecord. The callreturnstheaddressof x,whichgetsstoredin z.However,whenthecallreturns,itsactivationrecordisdestroyed, sozisactuallypointingatadeadobject.Thememoryforthatactivationrecordcanthenbereusedforsomethingelse –inthecaseofFigure24.1,theactivationrecordfor func2(),placingyatthesameaddressusedfor x.Dereferencing zresultsinundefinedbehavior;inthiscase,sincethememorywasreusedfor y,dereferencing zresultsinthevalue5, not 3.There are cases, however, where we want an object’s lifetime to last beyond the execution of the function that creates it.Previously, we saw the factory pattern , where a factory function creates an object and returns its address.
We used thenewoperator to decouple the lifetime of the object from the duration of the function call: Bird * Bird_factory( conststring &color, conststring &name) { if(color == "blue") { return new BlueBird(name); }else if (color == "black") { return new Raven(name); } ... } 24.3 Address Space Thenewoperator creates an object not in some activation record, but in an independent region of memory called the heap.Thestackandheaparetwoofthe segments thatmakeupaprogram’s addressspace ,whichisthetotalmemory associated with a running program.Figure 24.2 depicts a typical layout for an address space.Thetextsegmentcontainstheactualmachineinstructionsrepresentingtheprogram’scode,anditisoftenplacedatthe bottom of a program’s address space.(Nothing is located at address 0, since that is the representation used for a null pointer.) Spaceforobjectsinstaticstoragegenerallyislocatedabovethetextsegment,followedbytheheap.
Thelatter cangroworshrinkasobjectsindynamicmemoryarecreatedanddestroyed;inmostimplementationstheheapgrows upward as needed, into the empty space between the heap and stack. The stack starts at the top of the address space, and it grows downward when a new activation record is created.24.3.Address Space 152 Programming and Data Structures, Release 0.3 Stack(grows down)THE BIG VOIDHeap(grows up)Static Storage(Fixed size)Text(The program)Address MAX Address 0 Figure 24.2: The address space of a program.24.4 The newand deleteOperators Thesyntaxofa newexpressionconsistsofthe newkeyword,followedbyatype,followedbyanoptionalinitialization using parentheses or curly braces.The following are examples: // default initialization new int; // value initialization new int(); new int{}; // explicit initialization new int(3); new int{3}; If no initialization is provided, the newly created object is default initialized.
For an atomic type, nothing is done, so the object’s value is whatever is already there in memory. For a class type, the default constructor is called.Empty parentheses or curly braces result in value initialization .For an atomic type, the object is initialized to a zero value.For a class type, the default constructor is called.Explicit initialization can be done by supplying values in parentheses or curly braces.For atomic types, the value is used to initialize the object.For C-style ADTs, curly braces must be used, and the values within are used to initialize the member variables.For C++ ADTs, both parentheses and curly braces invoke a constructor with the values within as arguments.Anewexpression does the following: •Allocates space for an object of the given type on the heap.24.4.The newand deleteOperators 153 Programming and Data Structures, Release 0.3 •Initializes the object according to the given initialization expression.
•Evaluates to the address of the newly created object. The address is how we keep track of the new object; it is not associated with a variable name, so we have to store the address somewhere to be able to use the object.intmain() { int*ptr = new int(3); cout << *ptr << endl; // prints 3 ...} Stackmain0x10000x9994ptr0x99943Heap Figure 24.3: A newexpression creates an object on the heap and evaluates to its address.The newly created object’s lifetime is not tied to a particular scope.Rather, it begins when the newexpression is evaluated and ends when the deleteoperator is applied to the object’s address.deleteptr; Here,theoperandto deleteevaluatestotheaddressvaluecontainedin ptr.Thedeleteoperatorfollowsthisaddress and destroys the object at that address.Stackmain0x10000x9994ptr0x99943Heap Figure 24.4: Applying deleteto an address in dynamic memory kills the object that lives at that address.
Theexpression delete ptr; doesnotkilltheptrobject–itisalocalvariable,anditslifetimeendswhenitgoesout of scope. Rather, deletefollows the pointer to the object it is pointing to and kills the latter.We can continue to use the pointer object itself: intmain() { int*ptr = new int(3); cout << *ptr << endl; // prints 3 deleteptr; // kills *ptr, not ptr itself ptr = new int(-1); cout << *ptr << endl; // prints -1 deleteptr; // kills *ptr, not ptr itself } // ptr dies here, since it is going out of scope 24.4.The newand deleteOperators 154 Programming and Data Structures, Release 0.3 24.5 Dynamic Arrays Wesawpreviouslythatlocalandmember-variablearraysmusthaveasizethatisknownatcompiletime,sothecompiler canreasonaboutthesizesofactivationrecordsandclass-typeobjects.Thisrestrictiondoesnotapplytodynamicarrays –sincetheyarelocatedontheheapratherthaninanactivationrecordordirectlywithinaclass-typeobject,thecompiler does not need to know their size.
The syntax for creating a dynamic array is the newkeyword, an element type, square brackets containing an integer expression, and an optional initializer list. The expression within the square brackets need not be a compile-time constant: intmain() { cout << "How many elements?"; intcount; cin >> count; int*arr = new int[count]; for(inti = 0; i < count; ++i) { arr[i] = i; } ...} Anewarray expression does the following: •Allocates space for an array of the given number of elements on the heap.•Initializesthearrayelementsaccordingtothegiveninitializationexpression.Ifnoinitializationisprovided,the elements are default initialized.•Evaluates to the address of the first element of the newly created array.Previously,wesawthatalocalormember-variablearray decaystoapointer toitsfirstelementwhenthearray’svalue isrequired.Adynamicarrayimmediatelydecaysaspartofthe newarrayexpression,sotheexpressionevaluatestothe address of the first element.
Figure 24.5 illustrates memory at the end of the code snippet above. Stackmain0x10005count0x99904Heap0x998c30x998820x998410x998000x10040x9980arr Figure 24.5: A newarray expression creates an array on the heap and evaluates to the address of its first element.As with any pointer into an array, we can use the subscript operator to index into the array: arr[i] = i; This is equivalent to: 24.5.Dynamic Arrays 155 Programming and Data Structures, Release 0.3 *(arr + i) = i; The lifetime of a dynamic array begins when it is created by a newarray expression.It ends when the array-deletion operatordelete[] is applied to the address of the array’s first element: delete[] arr; Thoughthetypeof arrisint *,wecannotusetheregular deleteoperatoronit;instead,wemustinformtheprogram withdelete[] that we intend to delete a dynamic array, not just a single object on its own.Using the wrong deletion operator results in undefined behavior.
It is also undefined behavior to apply delete[] to anything other than the address of the first element of a dynamic array. We cannot delete an individual element of an array.The lifetime of an array’s elements are tied to the lifetime of the array as a whole; they are born when the array as a whole is born and die when the array dies.24.6 Lifetime of Class-Type Objects When a class-type object is created, a constructor is run to initialize it.3When a class-type object dies, its destructor is run to clean up its data.For a local object, this is when the associated variable goes out of scope.For a dynamic object, it is when deleteis applied to its address.Ifaclass-typeobjectisanelementofanarray,itdieswhenthearraydies,soitsdestructorrunswhenthearrayisdying.Thelifetimeofmembervariablesofaclass-typeobjectistiedtothelifetimeoftheobjectasawhole.Whentheobject dies, its members die as well; if they are of class-type themselves, their destructors run.
Specifically, the members of a class-type object are automatically destroyed after the destructor of the object is run, in reverse order of their declarations. The following is an example: class M { public: M(conststring &s) : mstr(s) { cout << "M ctor: " << mstr << endl; } ~M() { cout << "M dtor: " << mstr << endl; } private: string mstr; }; class C { public: C(conststring &s) : cstr(s), m1(s + ".m1"), m2(s + ".m2") { cout << "C ctor: " << cstr << endl; } ~C() { cout << "C dtor: " << cstr << endl; } (continues on next page) 3The exception is aggregates (C-style ADTs) that are initialized directly with an initializer list.24.6.
Lifetime of Class-Type Objects 156 Programming and Data Structures, Release 0.3 (continued from previous page) private: string cstr; M m1; M m2; }; intmain() { C c1("c1"); C *cptr = newC("(*cptr)"); C c2("c2"); deletecptr; } This prints the following when run: M ctor: c1.m1 M ctor: c1.m2 C ctor: c1 M ctor: (*cptr).m1 M ctor: (*cptr).m2 C ctor: (*cptr) M ctor: c2.m1 M ctor: c2.m2 C ctor: c2 C dtor: (*cptr) M dtor: (*cptr).m2 M dtor: (*cptr).m1 C dtor: c2 M dtor: c2.m2 M dtor: c2.m1 C dtor: c1 M dtor: c1.m2 M dtor: c1.m1 Whenmain()is run, the declaration of c1creates aCobject and calls its constructor. The latter first initializes the membersm1andm2in order before running the body of C‘s constructor.Thus, we get the output: M ctor: c1.m1 M ctor: c1.m2 C ctor: c1 The code then constructs a Cobject in dynamic memory, resulting in: M ctor: (*cptr).m1 M ctor: (*cptr).m2 C ctor: (*cptr) It then creates another local Cobject: M ctor: c2.m1 M ctor: c2.m2 C ctor: c2 24.6.
Lifetime of Class-Type Objects 157 Programming and Data Structures, Release 0.3 Theprogramproceedstoapply deletetotheaddressofthedynamic Cobject,whichcausesitsdestructortorun. The body of~C()runs first, and then the members are destroyed in reverse order: C dtor: (*cptr) M dtor: (*cptr).m2 M dtor: (*cptr).m1 The string cstris also destroyed, since it is a class-type object, and it is destroyed after m1.However, the string destructor doesn’t print anything out, so we do not see it in the output.The order in which the bodies of the destructors are run is the reverse of the constructors – we get the same “socks- and-shoes” ordering that we saw with base-class and derived-class constructors and destructors .When execution reaches the end of main(), bothc1andc2go out of scope, so their associated objects are destroyed in reverse order of construction.
Thus, c2dies first, followed by c1: C dtor: c2 M dtor: c2.m2 M dtor: c2.m1 C dtor: c1 M dtor: c1.m2 M dtor: c1.m1 24.7 Dynamic-Memory Errors The compiler manages objects with static and automatic storage duration, and the management of subobjects is di- rectly tied to the objects that contain them. Dynamic objects, on the other hand, must be explicitly managed by the programmer.Improper management can result in many kinds of errors that are unique to dynamic memory.The most common error with dynamic memory is a memory leak , where a program is no longer in need of a dynamic object but has failed to delete it.The usual cause of a memory leak is orphaned memory , when we lose track of a dynamic object, inevitably resulting in a leak.The following is an example: voidfunc1() { double*ptr = new double (3.0); } intmain() { func1(); ...} Whenfunc1() iscalled,itallocatesadynamicobjectandstoresitsaddressinthelocalvariable ptr.Whenfunc1() returns,itsactivationrecordisdestroyedand ptrdies.
Thus,theprogramnolongerknowstheaddressofthedynamic object that func1() created – the object has been orphaned, and there is no way to get to it to delete it. Thus, the corresponding memory is leaked.The solution is to apply deleteto the address before we lose track of it: voidfunc1() { double*ptr = new double (3.0); deleteptr; } (continues on next page) 24.7.Dynamic-Memory Errors 158 Programming and Data Structures, Release 0.3 (continued from previous page) intmain() { func1(); ...} Memory leaks result in a program using more memory than it needs.This is problematic on systems that run more than one program at once, which is the case for most machines – it reduces the amount of physical memory available to the other programs, potentially slowing them down.It is our responsibility as programmers to write well-behaved programs that avoid memory leaks.
Anothermemoryerrorisa doublefree ,alsocalleda doubledelete ,whereaprogramdeletesthesameobjectmorethan once: voidfunc2() { intx = 0; int*ptr1 = new int(1); int*ptr2 = new int(2); ptr2 = ptr1; deleteptr1; deleteptr2; } Here,theseconddynamic intisorphanedbytheassignment ptr2 = ptr1 . Theprogramthenapplies deletetothe same address twice; this is a double free, which results in undefined behavior.Another category of errors is a bad delete , which is when a delete operator is applied to the wrong kind of address.Thisincludesapplying deletetotheaddressofanon-dynamicobjectandapplying delete[] toanythingotherthan the address of the first element in a dynamic array.The result of a bad delete is undefined behavior.Deleting a dynamic object is not enough to avoid a memory error.If we keep around its address, we have a dangling pointer– a pointer that points to a dead object.If we then dereference the pointer, we get undefined behavior.
The following is an example: voidfunc3() { int*ptr = new int(42); cout << *ptr << endl; deleteptr; int*ptr2 = new int(3); cout << *ptr << endl; // oops deleteptr2; } In this code, we have accidentally dereferenced ptrafter applying deleteto it. The object it is pointing at is dead, and the memory may have been reused for something else.We can avoid dangling pointers by restricting the scope of a pointer to the region of code where it is expected to be used4.One way to do so is by moving that code into its own block, as in the following: 4Analternativestrategyistosetapointertonullafterapplying deletetoit.Dereferencinganullpointerstillresultsinundefinedbehavior,but implementationsalmostuniversallydetectthis,resultingina segmentationfault orabadaccess .However,therearetwodownsidestothisstrategy.First, it complicates the code, making it harder to read and maintain.Second, deleting a null pointer is valid in C++ – it has no effect.
This means that if we set a pointer to null and then subsequently delete it a second time, we will not encounter an error. However, this may hide a logic bug – perhapsweexpectedthepointertostillbealiveeventhoughitwasdeletedearlier,inwhichcasewewouldpreferavisibleerrorfromadoubledelete ratherthecodepassingourtestcases.Forthesereasons,itisbettertorelyonscopingtodetectdanglingpointersatcompiletimeratherthanrelying on runtime checks.24.7.Dynamic-Memory Errors 159 Programming and Data Structures, Release 0.3 voidfunc3() { { int*ptr = new int(42); cout << *ptr << endl; deleteptr; } int*ptr2 = new int(3); cout << *ptr << endl; // oops deleteptr2; } Nowptrisnolongerinscopewhenwemistakenlyaccessit,andthecompilerwilldetectthisandgiveusameaningful error.24.8 Uses for Dynamic Memory Dynamicmemoryaddsanotheruseforindirectionthroughapointerorreference.Sinceadynamicobjectisnotdirectly associated with a variable, we are forced to interact with the object indirectly.
We have already seen two uses for dynamic memory: •Thefactorypattern,whereafactoryfunctioncreatesobjectsofspecificderivedtypesbasedonruntimeinforma- tion. •Dynamic arrays, where the size can be determined at runtime.The factory pattern is an example of decoupling the lifetime of an object from a particular scope.Next time, we will makeuseofdynamicarraystobuildacontainerADTwithoutafixedmaximumcapacity;wewilldosobydecoupling the storage for the container’s elements from that of the container itself.However, we will see that this results in nontrivial memory-management issues, and we will learn how to address them.24.8.Uses for Dynamic Memory 160 CHAPTER TWENTYFIVE MANAGING DYNAMIC MEMORY We saw previously that the compiler and runtime automatically manage the lifetime of objects associated with static, local,andmembervariables.Forinstance,ifwedeclareanarrayasalocalvariable,itwilldiewhenthevariablegoes out of scope: intmain() { intarr[10]; for(inti = 0; i < 10; ++i) { arr[i] = i; } ...
}// arr dies here An automatically managed array must have a size that is known at compile time, so that the compiler can properly manage it. The compiler does not automatically manage dynamic arrays: intmain() { intsize; cout << "Enter a size:" << endl; cin >> size; int*darr = new int[size]; for(inti = 0; i < size; ++i) { darr[i] = i; } ...}// the pointer darr dies here, but not the memory it is pointing to The code above contains a memory leak, since we did not delete the memory we dynamically allocated.We also have seen that when a class-type object dies, its destructor is run: class C { public: ~C() { cout << "C dtor" << endl; } }; (continues on next page) 161 Programming and Data Structures, Release 0.3 (continued from previous page) intmain() { C c; ...
cout << "end of c 's scope" << endl; }// c dies here This prints out the following when run: end of c 's scope C dtor Here,thecompilerautomaticallymanagesthelifetimeoftheobjectassociatedwiththelocalvariable c,andsinceitis of class type, its destructor is run when the object dies. 25.1 RAII We can leverage automatic memory management and destructors by wrapping up the management of a dynamic re- source in a class.In particular, we will arrange for the constructor of a class-type object to allocate a resource and for the destructor to release that resource.Doing so ties the management of the resource to the lifetime of the class-type object.Thisstrategyiscalled resourceacquisitionisinitialization(RAII) ,anditisalsoknownas scope-basedresource management .
The following is a class that manages a dynamic array: class DynamicIntArray { public: DynamicIntArray( intsize_in) : elements( new int[size_in]), num_elements(size_in) {} ~DynamicIntArray() { delete[] elements; } intsize() const{ returnnum_elements; } int&operator [](inti) { returnelements[i]; } const int &operator [](inti)const{ returnelements[i]; } private: int*elements; intnum_elements; }; 25.1. RAII 162 Programming and Data Structures, Release 0.3 WhenaDynamicIntArray objectiscreated,itallocatesadynamicarrayofthespecifiedsize.Thesubscriptoperator is overloaded to index into the array.There are two overloads, one that returns a modifiable element by reference if applied to a non-const DynamicIntArray , and another that returns a non-modifiable element by reference to const when applied to a const DynamicIntArray .The class also provides a size()member function to query the size of the array.
When the DynamicIntArray object dies, it deletes the dynamic arraythat it had allocated, so that memory does not leak. The following is an example that uses DynamicIntArray : intmain() { intsize; cout << "Enter a size:" << endl; cin >> size; DynamicIntArray darr(size); // internally allocates an array for(inti = 0; i < darr.size(); ++i) { // size() member function darr[i] = i; // overloaded subscript } ...} // darr dies here, causing its destructor to run and free the // array it allocated When the object associated with darris created, it allocates a dynamic array, storing the address of the first element in itselements member.StackDynamicIntArray0x10085num_elements0x10000x9980elementsmaindarr0x99904Heap0x998c30x998820x998410x99800 Figure 25.1: A DynamicIntArray object manages an array in dynamic memory.Whendarrgoesoutofscope,itsassociatedobjectdies,andthe DynamicIntArray destructorisrun.Thedestructor deletes the array, cleaning up the resource that it was using.
Thus,withtheRAIIpattern,wehaveleveragedautomaticmemorymanagementandaclass-typeobjecttosuccessfully manage a dynamic array. 25.1.RAII 163 Programming and Data Structures, Release 0.3 Stack0x10085num_elements0x10000x9980elementsdarr0x99904Heap0x998c30x998820x998410x99800~DynamicIntArray()DynamicIntArraymain Figure 25.2: The destructor for DynamicIntArray deletes the array that it is managing.25.2 Growable Set Let’s use a similar strategy to write a new version of UnsortedSet without a fixed-capacity limitation.We allow the settohaveanarbitrarynumberofelementsbydecouplingthestorageoftheelementsfromthatofthesetobject,using dynamic memory for the former.We modify the data representation so that the member variable elements is now a pointer to the first element of a dynamicarray.Wealsoadda capacity membervariabletokeeptrackofthesizeofthatdynamicarray.
Theresulting class definition for UnsortedSet is as follows: template <typename T > class UnsortedSet { public: // EFFECTS: Initializes this set to be empty. UnsortedSet(); // MODIFIES: *this // EFFECTS: Adds value to the set, if it isn 't already in the set.voidinsert( constT &value); // MODIFIES: *this // EFFECTS: Removes value from the set, if it is in the set.voidremove( constT &value); // EFFECTS: Returns whether value is in the set.boolcontains( constT &value) const; // EFFECTS: Returns the number of elements.intsize() const; // EFFECTS: Prints out the set in an arbitrary order.voidprint(std::ostream &os) const; private: // MODIFIES: *this // EFFECTS: Doubles the capacity of this set.voidgrow(); (continues on next page) 25.2.Growable Set 164 Programming and Data Structures, Release 0.3 (continued from previous page) // Initial size of a set.
static const int INITIAL_SIZE = 5; T *elements; intcapacity; intnum_elements; // INVARIANTS: // elements points to the sole dynamic array associated with this set // capacity is the size of the array that elements points to // 0 <= num_elements && num_elements <= capacity // the first num_elements items in elements are the items in the set // the first num_elements items in elements contain no duplicates }; We have added two representation invariants: •elements pointstothestartofthesoledynamicarrayassociatedwiththeset,andeachsethasitsowndynamic array •capacity is the size of dynamic array that elements points to We have also added two private members: •grow()doubles the capacity of the set •INITIAL_SIZE is a constant whose value is the initial size of a set The following is the new constructor for UnsortedSet : template <typename T > UnsortedSet<T>::UnsortedSet() : elements( newT[INITIAL_SIZE]), capacity(INITIAL_SIZE), num_elements(0) {} Theconstructorallocatesadynamicarrayofsize INITIAL_SIZE andstorestheaddressofitsfirstelementin elements .
We satisfy the remaining representation invariants by setting capacity toINITIAL_SIZE andnum_elements to 0. We modify insert() so that if the set is out of space, it calls the grow()member function to increase the available capacity: template <typename T > voidUnsortedSet<T>::insert( constT &value) { if(contains(value)) { return; } if(num_elements == capacity) { grow(); // double the capacity; } elements[num_elements] = value; ++num_elements; } Thegrow()member function doubles the capacity of the set.In C++, an array has a fixed size, even if it is dynamic, so we cannot change the size of the existing elements array.Instead, we allocate a new dynamic array, copy over the elements, and discard the old array, as shown in Figure 25.3.25.2.
Growable Set 165 Programming and Data Structures, Release 0.3 StackUnsortedSet<int>0x100c5num_elements0x10085capacitymainsetHeap0x1000elements763510123476351012345678910 Figure 25.3: The grow()operation creates a new, larger array, copies the elements to the new array, and deletes the old array. The following implements this: template <typename T > voidUnsortedSet<T>::grow() { T *new_arr = newT[2 * capacity]; // allocate a new array that is twice as big for(inti = 0; i < num_elements; ++i) { // copy the elements to the new array new_arr[i] = elements[i]; } capacity *= 2; // update capacity delete[] elements; // free the old array elements = new_arr; // set elements to point to first element of the new array } Thefunctionallocatesanewarrayanddeletestheoldone,satisfyingtheinvariantthatthereisexactlyonedynamicarray associated with the set.It sets elements to point to that array and updates capacity to be the array’s size.
Copying theelementstothenewarraysatisfiestherepresentationinvariantthatthefirst num_elements itemsinelements are the ones in the set. Thegrow()operationdemonstratesthepowerofindirection.Bydecouplingthestoragefortheelementsfromthatof theUnsortedSet object, we have also decoupled their lifetimes.Thus, if the old storage no longer meets our needs, wecanreplaceitwithdifferentstoragethatdoes,killingtheoldarrayandcreatinganewone.Comparethistostoring thearraydirectlywithinthememoryfortheset,whichbothlimitsthearraytobeofafixedsizeandtiesitslifetimeto that of the set.SinceUnsortedSet now manages the resource of dynamic memory, we need to write a destructor that frees the resource when the UnsortedSet object dies.Before we proceed to write the destructor, a clarification is in order.The destructor does not causethe object to die.
The object dies when its lifetime ends: •if it is associated with a local variable, when the variable goes out of scope •if it is associated with a static variable, when the program ends •if it is a member of a class-type object, when the latter object dies •if it is an element of an array, when the array dies •if it is a dynamic object, when deleteis applied to its address The destructor merely runswhen the object dies – it gives the object a chance to put its affairs in order while it is on its deathbed. If the object is managing dynamic memory, it needs to release that memory.25.2.Growable Set 166 Programming and Data Structures, Release 0.3 template <typename T > UnsortedSet<T>::~UnsortedSet() { delete[] elements; } The representation invariant that there is exactly one dynamic array associated with each UnsortedSet ensures that after the destructor runs, there is no longer a live array associated with the dying set.
With the destructor, we have ensured that in simple cases, UnsortedSet properly manages memory. However, there is one case that we missed: copying a set.Consider the following code: intmain() { UnsortedSet< int> s1; for(inti = 0; i < 5; ++i) { s1.insert(i); } UnsortedSet< int> s2 = s1; cout << s1 << endl; // prints { 0, 1, 2, 3, 4 } cout << s2 << endl; // prints { 0, 1, 2, 3, 4 } s2.insert(5); // causes a grow cout << s2 << endl; // prints { 0, 1, 2, 3, 4, 5 } cout << s1 << endl; // UNDEFINED BEHAVIOR } The code creates a set s1and adds five items to the set, filling it to capacity.It then creates s2as a copy of s1; by default,thisdoesamember-by-membercopy,sothatboth s1.elements ands2.elements pointtothesamedynamic array.Wethenaddaniteminto s2,causingittogrowanddeleteitsoldarray.Thisisthesamearraythat s1.elements is pointing to, so that when we proceed to print out s1, it accesses a dead object.The result is undefined behavior.
Hadwenotcausedagrow,therewouldhavebeenadoubledeletewhen s2ands1die,sincetheywouldbothdeletethe samearray. Thisstillresultsinundefinedbehavior.Thefundamentalproblemisthatthecopyviolatestherepresentation invariant that each set has its own array.We will see how to fix this next time.25.2.Growable Set 167 CHAPTER TWENTYSIX THE BIG THREE We saw last time that copying an UnsortedSet ultimately results in undefined behavior.Before we fix the issue, we need to understand how C++ copies class-type objects and what mechanisms it provides to control the behavior of a copy.By default, a copy just copies over the members one by one, as we saw when we first discussed class-type objects : Person elise = { "Elise", 22, true }; Person tali = elise; The result is shown in Figure 26.1.Stack0x103822age0x103ctrueis_ninja0x1020"Elise"namePerson0x101822age0x1000"Elise"namemain taliPersonelise0x101ctrueis_ninja Figure 26.1: The default copy behavior for a class-type object is to copy each of its members.
The code above is an example of making a copy when initializing a new object. There are several forms of syntax we can use for initialization as a copy: Person tali = elise; Person tali(elise); Person tali{elise}; Person tali = {elise}; Initialization as a copy also occurs when we pass an object by value: 168 Programming and Data Structures, Release 0.3 voidfunc(Person p); intmain() { Person elise = { "Elise", 22, true }; func(elise); } Theparameter pisassociatedwithanobjectthatlivesintheactivationrecordfor func(),andtheobjectisinitialized when the function is called.It is initialized as a copy of the argument value elise.
Just like we can pass an object by value, we can also return an object by value, which generally makes a copy: Person func2() { Person elise = { "Elise", 22, true }; returnelise; } intmain() { Person tali = func2(); } 26.1 Copy Constructor Wealsopreviouslydiscussedthataconstructorisalwayscalledwhenaclass-typeobjectiscreated(exceptforC-style ADTs when the members are initialized directly, like eliseabove). Copy initialization of a class-type object also invokesaconstructor,specificallythe copyconstructor fortheclass.Thefollowingisanexampleofexplicitlydefining a copy constructor: class Example { public: Example( intx_in, doubley_in) : x(x_in), y(y_in) {} Example( constExample &other) : x(other.x), y(other.y) { cout << "Example copy ctor: " << x << ", " << y << endl; } intget_x() const{ returnx; } doubleget_y() const{ returny; } private: intx; doubley; }; The second constructor above is the copy constructor, and it takes a reference to an existing object as the parameter.26.1.
Copy Constructor 169 Programming and Data Structures, Release 0.3 The parameter must be passed by reference – otherwise, a copy will be done to initialize the parameter, which itself will invoke the copy constructor, which will call the copy constructor to initialize its parameter, and so on. We have instrumented the copy constructor to print a message when it is called.Thus, the code intmain() { Example e1(2, -1.3); Example e2 = e1; } will print the following when run: Example copy ctor: 2, -1.3 The program invokes the copy constructor to initialize e2frome1.The C++ compiler provides an implicit copy constructor if a user-defined one is not present.
The implicit copy con- structor just does a member-by-member copy, so in the case of Example, it acts like the following: Example( constExample &other) : x(other.x), y(other.y) {} 26.2 Assignment Operator Assignment is another situation where an object is copied; unlike initialization, however, assignment copies into an existing object rather than a new one. The following is an example: intmain() { Example e1(2, -1.3); Example e2(3, 4.1); e2 = e1; } An assignment expression consists of a left-hand-side object, the =operator, and a right-hand-side object or value.The expression evaluates the right-hand side, copies it into the left-hand-side object, and then evaluates back to the left-hand-side object.We can then use the result in a larger expression: cout << (e2 = e1).get_x() << endl; // prints 2 Like most operators, the assignment operator can be overloaded; the overload must be a member function of the type of the left-hand side.
class Example { public: Example & operator =(constExample &rhs); ... }; The function takes in an Example by reference to const, corresponding to the right-hand operand of the assignment.1 The return value will be the left-hand-side object itself, and it needs to be returned by reference rather than by value (the latter would make a copy rather than returning the object itself).Thus, the return type is Example & .The following is a definition of the overloaded assignment operator that just does a member-by-member copy: 1In C++, a reference to const can bind to a temporary, allowing the right-hand operand of the assignment to be a value rather than an object.26.2.Assignment Operator 170 Programming and Data Structures, Release 0.3 Example & Example:: operator =(constExample &rhs) { x = rhs.x; y = rhs.y; return*this; } The two members are individually copied from the right-hand side.
The left-hand-side object must be returned; we need to dereference the thispointer to get to the object to which it is pointing. Likethecopyconstructor,thecompilerprovidesanimplicitdefinitionoftheassignmentoperatorifauser-definedone is not present.Like the implicitly defined copy constructor, the implicit assignment operator performs a member-by- member copy.26.3 Shallow and Deep Copies Formostclasstypes,amember-by-membercopyissufficient, andthereisnoneedtowriteacustomcopyconstructor or assignment operator.However, for a type that manages a dynamic resource, a member-by-member copy generally results in incorrect sharing of a resource.
For example, consider the following code that copies an UnsortedSet : intmain() { UnsortedSet< int> s1; for(inti = 0; i < 5; ++i) { s1.insert(i); } UnsortedSet< int> s2 = s1; cout << s1 << endl; // prints { 0, 1, 2, 3, 4 } cout << s2 << endl; // prints { 0, 1, 2, 3, 4 } s2.insert(5); // causes a grow cout << s2 << endl; // prints { 0, 1, 2, 3, 4, 5 } cout << s1 << endl; // UNDEFINED BEHAVIOR } Theinitializationof s2callstheimplicitcopyconstructor,whichdoesamember-by-membercopy,asifitwerewritten as follows: template <typename T > UnsortedSet<T>::UnsortedSet( constUnsortedSet &other) : elements(other.elements), capacity(other.capacity), num_elements(other.num_elements) {} The result is that s1.elements ands2.elements point to the same array, as depicted by Figure 26.2. Inserting 5 into s2causes a grow operation, which creates a new array and deletes the old one.The result is shown in Figure 26.3.Then printing out s1accesses the old, deleted array, resulting in undefined behavior.
Thefundamentalproblemisthattheimplicitlydefinedmember-by-membercopyisa shallowcopy : itcopiesthepointer to the array of elements, rather than following it and copying the array as a whole. This violates the representation invariant that each set has its own array.Instead, we need a deep copy , where we make a copy of the underlying 26.3.Shallow and Deep Copies 171 Programming and Data Structures, Release 0.3 Stack0x101c5num_elements0x10185capacitymain s2Heap0x1010elements01234012340x100c5num_elements0x10085capacitys10x1000elementsUnsortedSet<int>UnsortedSet<int> Figure 26.2: The implicit copy constructor copies each member one by one, resulting in a shallow copy.0x101c5num_elements0x10185capacitymain s20x1010elements0x100c5num_elements0x10085capacitys10x1000elementsUnsortedSet<int>UnsortedSet<int>StackHeap01234012340123450123456789106 Figure 26.3: A subsequent grow()results in one of the sets using a dead array.26.3.
Shallow and Deep Copies 172 Programming and Data Structures, Release 0.3 resource rather than having the two sets share the same resource. To obtain a deep copy, we need to provide a custom implementation of the copy constructor: template <typename T > class UnsortedSet { public: UnsortedSet( constUnsortedSet &other); ...}; template <typename T > UnsortedSet<T>::UnsortedSet( constUnsortedSet &other) : elements( newT[other.capacity]), // create new array capacity(other.capacity), // shallow copy non-resources num_elements(other.num_elements) { for(inti = 0; i < num_elements; ++i) { // copy over the elements elements[i] = other.elements[i]; } } Rather than copying the elements pointer, we initialize the new set’s member to point to the start of a dynamic array of the same capacity as other‘s.The members that don’t represent resources are just copied directly ( capacity and num_elements ).The body of the constructor copies each element from the old set to the new one.
The result is that each set has its own, independent copy of the elements, as shown in Figure 26.4. StackHeap012340123401234012340x101c5num_elements0x10185capacitymain s20x1010elements0x100c5num_elements0x10085capacitys10x1000elementsUnsortedSet<int>UnsortedSet<int> Figure 26.4: The custom copy constructor for UnorderedSet performs a deep copy, providing the new set with its own array.Thecustomcopyconstructorprovidesadeepcopyinthecaseofinitializinganewsetasacopy.Weneedadeepcopy in assignment as well: s2 = s1; Thus,weneedacustomassignmentoperatorinadditiontoacustomcopyconstructor.Thefollowingisafirstattempt at defining one: 26.3.Shallow and Deep Copies 173 Programming and Data Structures, Release 0.3 template <typename T > class UnsortedSet { public: UnsortedSet & operator =(constUnsortedSet &rhs); ...
}; template <typename T > UnsortedSet<T> & UnsortedSet<T>:: operator =(constUnsortedSet &rhs) { delete[] elements; // delete old array elements = newT[rhs.capacity]; // make new array of the required size capacity = rhs.capacity; // shallow copy non-resources num_elements = rhs.num_elements; for(inti = 0; i < num_elements; ++i) { // copy over the elements elements[i] = rhs.elements[i]; } return*this; // return LHS object } The function first deletes the old array before creating a new one. It may be the case that the size of the rhsset is larger than the capacity of the set receiving the copy, in which case creating a new array is necessary.The function thenmakes ashallowcopy ofthenon-resources, followedbycopying overeachofthe elements.Finally,itreturns the left-hand-side object.Whilethisassignmentoperatorworksinmostcases,itfailsinthecaseof selfassignment .Anexpressionsuchas s2 = s2willdelete s2.elements beforeproceedingtoaccesstheelementsinthesubsequentloop.
Instead,theassignment shouldhavenoeffectwhenbothoperandsarethesameobject,soweneedtocheckforthiscasebeforedoinganywork. We do so as follows: template <typename T > UnsortedSet<T> & UnsortedSet<T>:: operator =(constUnsortedSet &rhs) { if(this== &rhs) { // self-assignment check return*this; } delete[] elements; // delete old array elements = newT[rhs.capacity]; // make new array of the required size capacity = rhs.capacity; // shallow copy non-resources num_elements = rhs.num_elements; for(inti = 0; i < num_elements; ++i) { // copy over the elements elements[i] = rhs.elements[i]; } return*this; // return LHS object } Thethispointer points to the left-hand-side operand, while the parameter rhsis an alias for the right-hand-side operand.We need to obtain the address of rhsto compare to the address stored in the thispointer.If the two addressesarethesame,thenthetwooperandsarethesameobject,soweimmediatelyreturntheleft-hand-sideobject.26.3.
Shallow and Deep Copies 174 Programming and Data Structures, Release 0.3 (We cannot return rhsbecause it is declared as a reference to const, while the return type is not.) 26.4 The Law of the Big Three We have seen that the implicitly defined copy constructor and assignment operator both do a shallow copy, and that thisbehaviorisincorrectforclassesthatmanageadynamicresource. Instead,weneedadeepcopy,whichrequiresus to write our own custom versions of the two functions.We also saw last time that resource management requires us to write our own custom destructor as well.It is not a coincidence that we needed to write custom versions of all three of the destructor, copy constructor, and assignment operator.The LawoftheBigThree (alsoknowasthe RuleofThree )isaruleofthumbinC++thatifacustomversionof anyofthedestructor,copyconstructor,orassignmentoperatorisrequired,almostcertainlyallthreeneedtobecustom.We refer to these three members as the big three.
By default, C++ provides implicit definitions of each of the big three: •The implicitly defined destructor does no special cleanup; it is equivalent to a destructor with an empty body. Like other destructors, it does implicitly destroy the members as well as the base class, if there is one.•The implicitly defined copy constructor does a member-by-member shallow copy.•The implicitly defined assignment operator does a member-by-member shallow copy.When a class manages a resource, however, the programmer must provide custom versions of the big three: •The destructor should free the resources.•The copy constructor should make a deep copy of the resources and shallow copy the non-resources.•The assignment operator should: –Do a self-assignment check.–Free the old resources.–Make a deep copy of the right-hand-side object’s resources.–Shallow copy the non-resources from the right-hand-side object.–Return the left-hand-side object with *this.
26.5 Example: Calls to the Big Three To better understand when the big three are invoked, we instrument the big three for the following class to print a message: class Foo { public: Foo( conststring &str_in) : str(str_in) { cout << "Foo ctor " << str << endl; } Foo( constFoo &other) : str(other.str) { cout << "Foo copy ctor " << str << endl; } Foo & operator =(constFoo &rhs) { (continues on next page) 26.4. The Law of the Big Three 175 Programming and Data Structures, Release 0.3 (continued from previous page) cout << "Foo assign " << rhs.str << " to " << str << endl; str = rhs.str; return*this; } ~Foo() { cout << "Foo dtor " << str << endl; } private: string str; }; TheFooclasshasa strmembervariablethatwewillusetodistinguishbetweendifferent Fooobjects.Theconstruc- tors, assignment operator, and destructor all print the value of str.
Let us take a look at a small program that uses Foo: voidfunc( constFoo &x, Foo y) { Foo z = x; } intmain() { Foo a("apple"); Foo b("banana"); Foo c("craisin"); func(a, b); Foo c2 = c; c2 = c; } This prints the following when run: Foo ctor apple Foo ctor banana Foo ctor craisin Foo copy ctor banana Foo copy ctor apple Foo dtor apple Foo dtor banana Foo copy ctor craisin Foo assign craisin to be craisin Foo dtor craisin Foo dtor craisin Foo dtor banana Foo dtor apple Inmain(), the variables a,b, andcare constructed in order, resulting in the Foo ctor outputs. Then func()is called.Thefirstparameterispassedbyreference,sonocopyismade.Thesecondparameterispassedbyvalue,sothe parameter object is initialized as a copy of the argument.This invokes the copy constructor, which prints Foo copy ctor banana .Withinthebodyof func(),zisinitializedasacopyof x,resultingin Foo copy ctor apple .
When func()returns, the local objects are destructed in reverse order of construction: zis destructed first, producing Foo 26.5. Example: Calls to the Big Three 176 Programming and Data Structures, Release 0.3 dtor apple , thenyis destructed, printing Foo dtor banana .Continuing in main(),c2is initialized as a copy of c, invoking the copy constructor and printing Foo copy ctor craisin.In the next line, c2already exists, so the expression is an assignment and calls the assignment operator, which prints Foo assign craisin to craisin .At the end of main(), the local objects are destructed in reverse order:c2, thenc, thenb, and then a.The last four lines of output are the result.26.6 Destructors and Polymorphism We saw previously that applying the deleteoperator to a pointer follows the pointer and kills the object at the given address.If the object is of class type, its destructor is run.
However, a subtle issue arises when the static and dynamic type of the object do not match: does the destructor use static or dynamic binding? Consider the following example: class Base { public: virtual void add( intx) = 0; ~Base() { cout << "Base dtor" << endl; } }; class Derived :publicBase { public: voidadd( intx)override { items.push_back(x); } ~Derived() { cout << "Derived dtor" << endl; } private: vector< int> items; }; intmain() { Base *bptr = newDerived; bptr->add(3); deletebptr; } Running this code results in: $ ./a.out Base dtor The destructor is statically bound, so ~Base() is invoked rather than ~Derived() .This is problematic: even though Derived itselfisnotmanagingdynamicmemory,itsmembervariable itemsis.Sincethedestructorfor Derived was notcalled,themembersintroducedby Derived werealsonotdestructed.RunningValgrindontheprogramillustrates the issue: 26.6.
Destructors and Polymorphism 177 Programming and Data Structures, Release 0.3 $ valgrind --leak-check=full ./a.out ==13359== Memcheck, a memory error detector ==13359== Copyright (C) 2002-2017, and GNU GPL 'd, by Julian Seward et al.
==13359== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info ==13359== Command: ./a.out ==13359== Base dtor ==13359== ==13359== HEAP SUMMARY: ==13359== in use at exit: 4 bytes in 1 blocks ==13359== total heap usage: 4 allocs, 3 frees, 73,764 bytes allocated ==13359== ==13359== 4 bytes in 1 blocks are definitely lost in loss record 1 of 1 ==13359== at 0x4C3017F: operator new(unsigned long) (in /usr/lib/valgrind/vgpreload_ ˓→memcheck-amd64-linux.so) ==13359== by 0x1098CD: __gnu_cxx::new_allocator<int>::allocate(unsigned long, void␣ ˓→const*) (in /home/akamil/tmp/a.out) ==13359== by 0x109782: std::allocator_traits<std::allocator<int> > ˓→::allocate(std::allocator<int>&, unsigned long) (in /home/akamil/tmp/a.out) ==13359== by 0x1095BB: std::_Vector_base<int, std::allocator<int> >::_M_ ˓→allocate(unsigned long) (in /home/akamil/tmp/a.out) ==13359== by 0x109163: void std::vector<int, std::allocator<int> >::_M_realloc_insert ˓→<int const&>(__gnu_cxx::__normal_iterator<int*, std::vector<int, std::allocator<int> >␣ ˓→>, int const&) (in /home/akamil/tmp/a.out) ==13359== by 0x109035: std::vector<int, std::allocator<int> >::push_back(int const&)␣ ˓→(in /home/akamil/tmp/a.out) ==13359== by 0x108F65: Derived::add(int) (in /home/akamil/tmp/a.out) ==13359== by 0x108E63: main (in /home/akamil/tmp/a.out) ==13359== ==13359== LEAK SUMMARY: ==13359== definitely lost: 4 bytes in 1 blocks ==13359== indirectly lost: 0 bytes in 0 blocks ==13359== possibly lost: 0 bytes in 0 blocks ==13359== still reachable: 0 bytes in 0 blocks ==13359== suppressed: 0 bytes in 0 blocks ==13359== ==13359== For counts of detected and suppressed errors, rerun with: -v ==13359== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0) The error message indicates that the memory allocated by the itemsvector is never freed.
The solution is to use dynamic binding for the destructor instead by declaring it as virtual: class Base { public: virtual void add( intx) = 0; virtual ~Base() { cout << "Base dtor" << endl; } }; class Derived :publicBase { (continues on next page) 26.6. Destructors and Polymorphism 178 Programming and Data Structures, Release 0.3 (continued from previous page) public: voidadd( intx)override { items.push_back(x); } ~Derived() { // virtual implicitly inherited cout << "Derived dtor" << endl; } private: vector< int> items; }; intmain() { Base *bptr = newDerived; bptr->add(3); deletebptr; } Now the following is printed when the code is run: $ ./a.out Derived dtor Base dtor Valgrind also no longer reports an error.Ingeneral, abaseclassshouldalwaysdeclarethedestructortobevirtualiftheclasswillbeusedpolymorphically (meaningthatabase-classpointerorreferencemaybeboundtoaderived-classobject).Ifthebaseclassdestructorhas no work to do, it may be defaulted.
The derived class destructor need not be explicitly defined, since “virtualness” is inherited even if the destructor is implicitly defined by the compiler. class Base { public: virtual void add( intx) = 0; virtual ~Base() = default; // use implicitly defined dtor, but make it virtual }; class Derived :publicBase { public: voidadd( intx)override { items.push_back(x); } // implicitly defined dtor inherits virtual private: vector< int> items; }; intmain() { Base *bptr = newDerived; bptr->add(3); deletebptr; } 26.6.Destructors and Polymorphism 179 Programming and Data Structures, Release 0.3 Valgrind does not show a memory leak: $ valgrind --leak-check=full ./a.out ==13479== Memcheck, a memory error detector ==13479== Copyright (C) 2002-2017, and GNU GPL 'd, by Julian Seward et al.
==13479== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info ==13479== Command: ./a.out ==13479== ==13479== ==13479== HEAP SUMMARY: ==13479== in use at exit: 0 bytes in 0 blocks ==13479== total heap usage: 3 allocs, 3 frees, 72,740 bytes allocated ==13479== ==13479== All heap blocks were freed -- no leaks are possible ==13479== ==13479== For counts of detected and suppressed errors, rerun with: -v ==13479== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0) 26.6. Destructors and Polymorphism 180 CHAPTER TWENTYSEVEN LINKED LISTS Asequential container is a container that holds elements and allows them to be accessed in sequential order.
The simplest sequential container is a built-in array, which stores its elements contiguously in memory: const int SIZE = 5; intarray[SIZE] = { 1, 2, 3, 4, 5 }; // iterate over elements in order with traversal by pointer for(int*ptr = array; ptr != array + SIZE; ++ptr) { cout << *ptr << endl; } We can also traverse over arrays by index, using random access to get to an element: const int SIZE = 5; intarray[SIZE] = { 1, 2, 3, 4, 5 }; // iterate over elements in order with traversal by index for(inti = 0; i < SIZE; ++i) { cout << array[i] << endl; } Thefactthattheelementsarestoredcontiguouslymakesrandomaccessefficient: ittranslatesdirectlytopointerarith- metic,sothatittakesthesameamountoftimetoaccessanelementinthemiddleofthearrayasoneatthebeginning. cout << *(array + i) << endl; However,arrayshavesignificantlimitations: theirsizeisfixeduponcreation,andfornon-dynamicarrays,thesizemust be known at compile time.
Avectoris a class template that provides an abstraction over a dynamically allocated array. Like UnsortedSet , it grows as needed by swapping out an old array for a new one.A vector also provides an interface for iterating over the elements in order: vector< int> data; // add elements to the vector for(inti = 1; i <= 5; ++i) { data.push_back(i); } // iterate over elements in order with traversal by iterator for(vector< int>::iterator it = data.begin(); it != vec.end(); ++it) { cout << *it << endl; } We will cover iterators and traversal by iterator next time.181 Programming and Data Structures, Release 0.3 Sequence abstractions based on contiguous memory have the drawback of inefficient insertion at the beginning or middle of the sequence.For instance, to insert an item at a particular position, we need to first move the elements at that position and later out of the way, as shown in Figure 27.1.
13401231340123234 Figure 27.1: Inserting in the middle of a contiguous data structure requires elements to be shifted out of the way. Thus, insertion at the beginning or middle is a linear-time operation.Ontheotherhand,ifwegiveuptheabstractionofcontiguousmemory,wecanplaceanewitemanywhereinmemory.Since the elements are no longer stored contiguously, we cannot move to the next element by just incrementing an address.Instead, we have to explicitly keep track of where the next element is through a pointer.0x90001 0x90300x9010420x90204 0x00x90303 0x90200x9040314150x90502800x90602 0x90300x90600x90001 0x90300x9010420x90204 0x00x90303 0x90200x9040314150x90502800x9060 Figure27.2: Anoncontiguousdatastructurecanusepointerstokeeptrackofeachelement’slocation.Insertinginthe middle can be done by just modifying a pointer.As illustrated in Figure 27.2, inserting in the middle now just involves changing the value of a pointer.
For each element in our sequence, we need to keep track of both the datum itself as well as a pointer to the next piece of the sequence. This is heterogeneous data, so we use a nodeclass-type object to keep track of the two values: struct Node { intdatum; Node *next; }; We define the Nodetype as plain-old data, using the structkeyword and accessing the members directly.For now, we will stick to intas the element type; later, we will convert our abstraction into a template.The remaining Node member is a pointer to the next Nodein our sequence.The sequence of Nodeobjects in Figure 27.3 represents the elements ( 1 2 3 4 ) .We use a null pointer as a sentineldenoting the end of the sequence, storing that in the nextpointer of the last node.We refer to the sequence of nodes as a linked list , as it consists of a list of items linked together by pointers.
Rather than exposing the nodes directly as part of an abstract data type, we define an IntList ADT that internally maintains a sequence of nodes. It need only keep track of the location of the first Node, since we can get to the others by following nextpointers: 182 Programming and Data Structures, Release 0.3 Node1datumnextNode2datumnextNode4datum0x0nextNode3datumnext Figure 27.3: Nodes representing a sequence of four elements.A null pointer represents the end of the sequence.class IntList { ...private: Node *first; } IntListfirstNode1datumnextNode2datumnextNode4datum0x0nextNode3datumnext Figure 27.4: An IntList object and its nodes.SincetheNodeobjectsarestoredindirectlyfromthe IntList object,theymustbeindynamicmemory,and IntList must ensure that their memory is properly managed.
Beforeweconsidertherepresentationof IntList further,wefirstwritesomecodethatuses IntList inordertowork out its interface: intmain() { IntList list; // ( ) list.push_front(1); // ( 1 ) list.push_front(2); // ( 2 1 ) list.push_front(3); // ( 3 2 1 ) cout << list.front(); // 3 (continues on next page) 183 Programming and Data Structures, Release 0.3 (continued from previous page) list.front() = 4; // ( 4 2 1 ) list.print(cout); // 4 2 1 list.pop_front(); // ( 2 1 ) list.pop_front(); // ( 1 ) list.pop_front(); // ( ) cout << list.empty(); // true (or 1) } The class should have a default constructor that makes the list empty. It should also have a push_front() member function to insert an item at the beginning, as well as front() to retrieve the first item.The latter must support both readingandwritingthefirstelement.Theremainingmemberfunctionsare print(),pop_front() toremovethefirst item, and empty().
The following is the resulting interface: class IntList { public: // EFFECTS: Constructs an empty list. IntList(); // EFFECTS: Returns true if the list is empty.boolempty() const; // REQUIRES: the list is not empty // EFFECTS: Returns (by reference) the first element.int& front(); // EFFECTS: Inserts datum at the front of the list.voidpush_front( intdatum); // REQUIRES: the list is not empty // EFFECTS: Removes the first element.voidpop_front(); // MODIFIES: os // EFFECTS: Prints the items in the list, each followed by a space.voidprint(std::ostream &os) const; ...}; Notice that Nodeappears nowhere in the interface.It is an implementation detail, so it should be defined as a private member of IntList.This makes it a nested class , which is a class (or struct) defined as a member of another class.class IntList { ...
private: struct Node { intdatum; Node *next; (continues on next page) 184 Programming and Data Structures, Release 0.3 (continued from previous page) }; Node *first; }; Nowthatwehavearepresentation,thenextstepistodeterminetherepresentationinvariants. Wehavealreadydecided to use a null pointer to denote the end of the sequence of nodes.Similarly, we can store a null pointer in firstto represent an empty list.Thus, the invariants are as follows:1 •firstis either null or a pointer to a valid Node •thenextmember of all but the last node points to another valid Node •thenextmember of the last node is null We can now proceed to implement the constructor and the remaining member functions.The constructor must ensure that the list is initialized to satisfy the representation invariants.
Since the default con- structor makes the list empty, it must initialize firstto be null: IntList::IntList() : first( nullptr) {} Theempty() function just needs to check whether firstis null: boolIntList::empty() const{ returnfirst == nullptr; // or just return !first; } Forfront(),wewillfirstasserttheREQUIRESclausethatthelistnotbeempty. Ifthatissatisfied,therepresentation invariants tell us that firstis pointing to a valid node.Its datummember holds the first element.int& IntList::front() { assert(!empty()); returnfirst->datum; } The return by reference is necessary to allow code such as: list.front() = 4; The left-hand side of an assignment must be an object, not a temporary value, so front() must return an object by reference.Forpush_front() , we need to consider two cases: •The list is empty, in which case firstis null.•The list is not empty, in which case firstpoints to a valid node.
Inbothcases,weconstructanew Nodeindynamicmemory,setits datumtobethevaluethatisbeinginserted,setits nextto be the existing value of first, and setfirstto point to the new Node. voidIntList::push_front( intdatum) { Node *p = newNode; p->datum = datum; (continues on next page) 1There are two further invariants: a node is associated with exactly one list, and there are no cycles among the nextpointers of the nodes.The latter makes it invalid, for instance, to have one node’s nextpoint to a second node and have the second’s nextpoint back to the first node.185 Programming and Data Structures, Release 0.3 IntList0x0firstNode-5datum0x0nextIntListfirstNode-5datum0x0nextNode3datumnext Figure 27.5: Inserting an element to the front of an empty and non-empty list.(continued from previous page) p->next = first; first = p; } Amoresuccinctwaytoaccomplishthisiswithaninitializerlistthatdirectlyinitializeseachmemberofthenew Node; this is permitted since Nodeis a C-style ADT.
voidIntList::push_front( intdatum) { first = newNode{ datum, first }; } Inpop_front() , we again assert the REQUIRES clause. We should then consider two possible cases: •The list has one item, in which case it will end up as empty.•The list has more than one item, and it will not end up empty.In the former case, the sole node is the last one, and the representation invariants tell us that its nextis null.Thus, settingfirsttothenode’s nextsuitablymakesthelistempty.Inthesecondcase,thefirstnode’s nextispointingto the second node in the list, so firstshould end up pointing at that node when the first one is removed.Thus, in both cases, we need to assign the value of first->next tofirst.Wealsoneedtoproperlymanagedynamicmemory;inparticular,wemustdeletethenodethatisbeingremoved, asit is memory that no longer will be used.
Consider the following implementation of pop_front() : voidIntList::pop_front() { assert(!empty()); deletefirst; first = first->next; } This code dereferences firstthrough the arrow operator after the underlying object has been deleted, resulting in undefined behavior. Let’s try to fix this by reordering the statements: voidIntList::pop_front() { assert(!empty()); first = first->next; (continues on next page) 186 Programming and Data Structures, Release 0.3 (continued from previous page) deletefirst; } Now, the assignment to firstorphans what previously was the first node; we no longer have a means to get to that object, resulting in a memory leak.The code then proceeds to delete what used to be the second node.Neither ordering works correctly on its own.What we need is a temporary to keep track of the first node, so that we canchangethevalueof firstbutstillbeabletodeletethenodethatisbeingremoved.
Thefollowingaretwocorrect implementations: voidIntList::pop_front() { assert(!empty()); Node *victim = first; // temporary keeps track of old first first = first->next; deletevictim; } voidIntList::pop_front() { assert(!empty()); Node *new_first = first->next; // temporary keeps track of new first deletefirst; first = new_first; } Figure 27.6 illustrates the first implementation of pop_front() . IntListfirstNode-5datum0x0nextNode3datumnextIntList::pop_frontthisStackvictim Figure 27.6: Removing an element from the front of a list.187 Programming and Data Structures, Release 0.3 27.1 Traversing a Linked List Iterating over a linked list’s elements from outside the class requires an iteratorabstraction that we will see next time: theNodestruct is private, so external code cannot use Nodes to iterate through the list.
Code within IntList, on the other hand, does have access to Node, so it can traverse the list by starting at the firstmember and following each node’snextpointer until reaching the null sentinel. The following print() member function uses this strategy: voidIntList::print(std::ostream &os) const{ for(Node *node_ptr = first; node_ptr; node_ptr = node_ptr->next) { os << node_ptr->datum << " "; } } The loop initializes node_ptr as a copy of first.If the list is empty, firstis null, so node_ptr will be initialized tonullaswell.Thetruthvalueofanullpointerisfalse,sotheconditionoftheloopwillevaluatetofalseandtheloop will exit.(Alternatively, node_ptr can be compared to nullptr instead:node_ptr != nullptr .) Ifthelistisnotempty, node_ptr willnotbeinitiallynull,anditstruthvaluewillbetrue.Thebodythenexecutes,and itusesthe ->operatortoaccessthe datummemberofthenodethat node_ptr pointsto.Theloopupdatethencopies the node’s nextpointer into node_ptr , movingnode_ptr to point to the next node.
When the iteration reaches the last node in the list, its nextis null, so the update sets node_ptr to be null. This results in the loop condition being false, so the loop exits.IntListfirstNode-5datum0x0nextNode3datumnextIntList::printthisStacknode_ptr1230x0 Figure27.7: Traversalofthenodesinalist,startingat first,following nextpointers,andendingatthenullsentinel.27.2 Linked List Big Three Insertinganelementintoalistallocatesa Nodeindynamicmemory,sothelistmustproperlymanagethenodeobjects to avoid a memory leak.The compiler-generated destructor does not free the nodes’ memory, so we need to write a custom destructor instead.The law of the big three then tells us that we need to write a custom copy constructor and assignment operator as well.Both the destructor and the assignment operator must free the list’s resources, and both the copy constructor and assignmentoperatorperformadeepcopyofanotherlist’sresources.
Toavoidcodeduplication,wewritea pop_all() member function to free all the elements and their nodes, and a push_all() function to copy all the elements from another list. These functions are not part of the interface, so we write them as private members: 27.1.Traversing a Linked List 188 Programming and Data Structures, Release 0.3 class IntList { ...private: // EFFECTS: Removes all the elements from this list.voidpop_all(); // EFFECTS: Adds all elements from other into this list.voidpush_all( constIntList &other); }; With these two functions, we can write the big three as follows: IntList::IntList( constIntList &other) : IntList() { push_all(other); } IntList & IntList:: operator =(constIntList &rhs) { if(this!= &rhs) { pop_all(); push_all(rhs); } return*this; } IntList::~IntList() { pop_all(); } The copy constructor delegates to the default constructor to make the list empty, then calls push_all() to copy all the elements from the other list.
The assignment operator does a self-assignment check, calls pop_all() to remove all the existing elements, and invokes push_all() to copy the elements from the other list. The destructor just calls pop_all() to remove all the elements and free their associated nodes.Theimplementationof pop_all() isstraightforward: wealreadyhavea pop_front() functionthatremovesasingle item, so we just need to repeatedly call it until the list is empty: voidIntList::pop_all() { while(!empty()) { pop_front(); } } Thepush_all() function needs to iterate over each of the elements in the other list, adding them one by one to the currentlist.
Wecanfollowthesameiterationpatternweusedin print(),andwehavea push_front() functionthat adds a single element: voidIntList::push_all( constIntList &other) { for(Node *node_ptr = other.first; node_ptr; node_ptr = node_ptr->next) { push_front(node_ptr->datum); } } However, this implementation ends up inserting the elements in reverse order: if othercontains the elements ( 1 2 3 ), the code would insert 1, then 2 before that, then 3 before that, resulting in ( 3 2 1 ) . 27.2.Linked List Big Three 189 Programming and Data Structures, Release 0.3 Rather than inserting each element at the beginning of the list, we need to insert at the end with a push_back() function.
voidIntList::push_all( constIntList &other) { for(Node *node_ptr = other.first; node_ptr; node_ptr = node_ptr->next) { push_back(node_ptr->datum); } } 27.3 Insertion and Removal at the End With our current list representation, push_back() must traverse the entire list to insert the new element: voidIntList::push_back( intdatum) { Node *new_node = newNode{ datum, nullptr }; if(empty()) { first = new_node; }else{ Node *node_ptr = first; for(; node_ptr->next; node_ptr = node_ptr->next); // find last node node_ptr->next = new_node; // set last node 's next to new_node } } Thisisaveryinefficientalgorithm;thecoreproblemisourlistimplementationonlykeepstrackofthefirstnode,butwe needtoinsertafterthelastnode. Wecanmake push_back() muchmoreefficientbychangingourlistrepresentation to keep track of the last node as well: class IntList { ...
private: Node *first; Node *last; }; IntListfirstNode1datumnextNode2datumnextNode4datum0x0nextNode3datumnextlast Figure 27.8: Double-ended list representation with firstandlastpointers. 27.3.Insertion and Removal at the End 190 Programming and Data Structures, Release 0.3 We update our representation invariants so that an empty list is represented by both lastandfirstbeing null, and thatlastpoints to the last node in the sequence for a non-empty list.We can then write push_back() as follows: voidIntList::push_back( intdatum) { Node *new_node = newNode{ datum, nullptr }; if(empty()) { first = last = new_node; }else{ last = last->next = new_node; } } In the case of inserting into an empty list, we need to set both firstandlastpointing at the new node.
(We would need to modify pop_front() to do this as well.) When inserting at the end of a non-empty list, we have to set the nextpointer of what used to be the last node to point to the new node, and we must also update the lastmember of theIntList so that it points to the new node. Nowthatwehave push_back() ,thelogicalnextstepistoprovide pop_back() aswell.Unfortunately, pop_back() requires setting the lastpointer to point to what used to be the second-to-last node, and we can only get to that node by traversing the entire list from the beginning.Here, the problem is that our nodes only have a nextpointer, so they allowustotraverseintheforwarddirectionbutnotinreverse.Wecanmodifyourrepresentationoncemoretoenable backwards traversal by adding a prevpointer to each node: class IntList { ...private: struct Node { intdatum; Node *prev; Node *next; }; Node *first; Node *last; }; Thisisnowa doublylinkedlist ,sinceeachnodehastwolinks,onetothepreviousnodeandonetothenextnode.
Our original list is a singly linked list . The standard library provides both implementations: std::forward_list is a singly linked list, while std::list is a doubly linked list.The former uses less space than the latter, since the nodes don’t have a pointer to the previous node, but it does not provide the ability to iterate backwards over the list.27.4 List Template We can generalize the IntList class to hold objects of other types by making it a template.Each instantiation is still homogeneous: List<int> only holds ints,List<string> only holds strings, and so on.template <typename T > class List { public: List(); (continues on next page) 27.4.List Template 191 Programming and Data Structures, Release 0.3 IntListfirstNode1datum0x0prevlastnextNode2datumprevnextNode3datumprevnextNode4datumprev0x0next Figure 27.9: Doubly linked list with nextandprevpointers in each node.
(continued from previous page) voidempty() const; T & front(); voidpush_front( constT &datum); voidpop_front(); voidpush_back( constT &datum); voidpop_back(); ... private: struct Node { T datum; Node *prev; Node *next; }; Node *first; Node *last; }; By placing the Nodestruct inside the Listtemplate, each instantiation of Listwill have its own Nodetype; List<int>::Node ,List<string>::Node , andList<Duck>::Node are all distinct types.Now that our container is a template, we pass elements by reference.For List<int> , the elements are small enough tocopy,butforclass-typeelementssuchasin List<string> orList<Duck> ,wewanttoavoidmakingunnecessary copies.Agoodruleofthumbistopassafunctionparameterbyreferenceifthefunctionparameter’stypeisatemplate parameter, since the latter may be instantiated with a large class type.27.4.
List Template 192 CHAPTER TWENTYEIGHT IMPLEMENTING ITERATORS Last time, we saw how to iterate over the elements of a linked list from within the list class itself: template <typename T > voidList<T>::print(std::ostream &os) const{ for(Node *node_ptr = first; node_ptr != nullptr; node_ptr = node_ptr->next) { os << node_ptr->datum << " "; } } Thestrategyistostartwiththefirstnodeinthelist,thenfollowthenodes’ nextpointersuntilreachingthenullsentinel. We can try to follow the same strategy from outside the class: List< int> list; ...for(Node *node_ptr = list.first; node_ptr != nullptr; node_ptr = node_ptr->next) { cout << node_ptr->datum << endl; } However, this strategy doesn’t work from outside the list because the nested Nodeclass is private – it is an implemen- tation detail, so outside code should not depend on it anyway.The firstmember is also private, so the initialization ofnode_ptr is invalid.Instead, we need to provide a different interface for iterating over a list.
We have seen two patterns for iterating over a sequential container, traversal by index and traversal by pointer. In traversalbyindex,weusealoopvariableofintegraltype,incrementitineachiteration,andaccessanelementbyusing the index as an offset into the container: const int SIZE = 5; intarray[SIZE] = { 1, 2, 3, 4, 5 }; // iterate over elements in order with traversal by index for(inti = 0; i < SIZE; ++i) { cout << array[i] << endl; } To use this pattern with a container, it must support random access , the ability to directly access an element through anindex.Array-basedsequentialcontainersgenerallysupportrandomaccess.Forbuilt-inarrays,ittranslatesdirectly topointerarithmetic.Array-basedclasstypessuchas std::array andstd::vector overloadthesubscriptoperator to index into the underlying array, which then turns into pointer arithmetic.
Linked lists do not provide random access; since they are not array-based, accessing an element in the middle of the list cannot be done with pointer arithmetic, but must traverse from the start of the list as in print(). Thus, traversal by index is not an appropriate pattern for a linked list.193 Programming and Data Structures, Release 0.3 Traversalbypointer,ontheotherhand,startswithapointertothebeginningofasequenceanditeratesbymovingthat pointer forward to each subsequent element, until that pointer reaches past the end of the sequence: const int SIZE = 5; intarray[SIZE] = { 1, 2, 3, 4, 5 }; // iterate over elements in order with traversal by pointer for(int*ptr = array; ptr != array + SIZE; ++ptr) { cout << *ptr << endl; } A similar pattern would work for a linked list: start off with something like a pointer that “points” to the beginning of the list, move it forward one element at a time, and stop when we get past the end of the list: List< int> list; ...
for(Iterator it = list.begin(); it != list.end(); ++it) { cout << *it << endl; } Weuseanobjectcalledan iteratortoiterateovertheelements. Thepatternaboveiscalled traversalbyiterator ,andit is a generalization of traversal by pointer.To traverse with an iterator, it must provide the following operations:1 •dereference (prefix *) •increment (prefix ++) •equality checks ( ==and!=) In addition, the container itself must provide two member functions: •begin() returns an iterator to the start of the sequence •end()returns a “past-the-end” iterator that represents a position that is past the last element of the sequence Aniteratorisaclass-typeobjectthathasthesameinterfaceasapointer.
Weprovidethesameinterfacebyoverloading the required operators: template <typename T > class Iterator { public: T & operator *() const; Iterator & operator ++(); bool operator ==(Iterator rhs) const; bool operator !=(Iterator rhs) const; }; Theunary *operatorisoverloadedtoreturntheelementtheiteratorispointingtobyreference. Theprefix ++operator movestheiteratortopointtothenextelementinthesequence,anditreturnstheiteratoritselfbyreference.Thisallows the operator to be chained: ++++it; 1There are many kinds of iterators in C++.We will only implement a subset of the operations required for an input iterator .194 Programming and Data Structures, Release 0.3 Theequalityoperatorsdetermineifthereceiverpointstothesameelementasthe rhsiterator.Unlikemostclasstypes, we pass iterators by value – they are generally small, and it is standard practice in C++ to make copies of them when we pass them to a function, just like we would for pointers.
Before we proceed to implement the operators, we need a data representation. The representation of an iterator is specific to a particular kind of container.For a linked list, traversal by iterator is just an abstraction over the traversal inprint(): •A list iterator is an abstraction over a pointer to a node.•The calllist.begin() returns an iterator constructed from first.•The past-the-end iterator returned by list.end() is represented by a null pointer.•Comparing two iterators compares their underlying node pointers.•Incrementing an iterator moves its node pointer to the next node using the original node’s nextmember.•Derferencing the iterator obtains the datummember of the underlying node.Thus, we represent an iterator with just a pointer to a node.template <typename T > class Iterator { ...
private: Node *node_ptr; }; List<int>firstList<int>::Node3datumnextList<int>::Node-5datumnextList<int>::Node4datum0x0nextList<int>::Node2datumnextlastIteratornode_ptr Figure 28.1: A list iterator is an abstraction of a pointer to a node. Asmentionedabove,weuseanullpointerforaniteratorthatispasttheendofalist.Theendconditionforthetraversal inprint() iswhenthenodepointerisnull–afterthetraversalreachesthelastnode,itsetsthepointertothevalueof thelastnode’s nextmember,whichisnullaccordingtothelist’srepresentationinvariant.Thus,itmakessensetouse a null pointer to represent a past-the-end iterator.Now that we have a representation, we should consider representation invariants.It is the case that node_ptr will either be null or point to a valid list node when the iterator is created.
However, we will see that an iterator may be 195 Programming and Data Structures, Release 0.3 List<int>firstList<int>::Node3datumnextList<int>::Node-5datumnextList<int>::Node4datum0x0nextList<int>::Node2datumnextlastIteratornode_ptr0x0 Figure 28.2: A list past-the-end iterator has a null pointer as its stored node pointer. invalidated , which will result in node_ptr pointing to an invalid node.Thus, there is no invariant that will hold for a list iterator’s representation.28.1 Iterator Definition Before we proceed to implement Iterator , observe the following issues with its definition: •Nodeis not a top-level type, but a member of the Listclass template, so it cannot be named from the outside without the scope-resolution operator.•TheNodestruct is private, so it cannot be accessed from outside code.•The iterator type is associated with List, so it should be encapsulated within the Listtemplate.
We can solve these issues by defining Iterator as a member of the Listtemplate: template <typename T > class List { ... private: struct Node { intdatum; Node *next; }; public: class Iterator { public: T & operator *() const; Iterator & operator ++(); (continues on next page) 28.1.Iterator Definition 196 Programming and Data Structures, Release 0.3 (continued from previous page) bool operator ==(Iterator rhs) const; bool operator !=(Iterator rhs) const; private: Node *node_ptr; }; private: Node *first; Node *last; }; Wemustdefinethe Iterator classafterthedefinitionofthe Nodestructsothat Nodeisinscopewhenitisreferenced in theIterator class.2Iterator itself is part of the interface for List, so it is defined as public within List.We can now implement the member functions of Iterator .28.1.1 Dereference and Increment Operators Thedereferenceoperatorrequiresthattheiteratoris dereferenceable ,whichmeansthatitispointingtoavalidelement inthecontainer.
Wecannotingeneralcheckthatthisisthecase,butwecancheckwhethertheiteratorisapast-the-end iterator: // REQUIRES: this is a dereferenceable iterator // EFFECTS: Returns the element that this iterator points to. template <typename T > T & List<T>::Iterator:: operator *() const{ assert(node_ptr); // check whether this is a past-the-end iterator returnnode_ptr->datum; } Theoperator*() function is a member of Iterator , which itself is a member of List<T> – thus, we need two scope-resolution operators when referring to the function.After asserting that the iterator is not past the end, the function just returns the datummember of the underlying node.The return is by reference, so that the element can be modified through the iterator: List< int> Iterator it = ...; *it = 3; // LHS of assignment must be an object The dereference operator does not modify the iterator.
In addition, while the function returns an object by reference to non-const, modifying that object does not modify the iterator, since the object is not a member of the iterator itself. Thus, the dereference operator can be declared as a const member function.Theoperator++() functionmodifiestheiteratorbymovingitto“pointto”thenextelement,soitcannotbedeclared as const.As with dereference, the past-the-end iterator cannot be incremented – node_ptr would be null, and there wouldn’t be a nextpointer to move the iterator to.// REQUIRES: this is a dereferenceable iterator // EFFECTS: Returns the element that this iterator points to.template <typename T > (continues on next page) 2The scope of a class member begins at the member declaration and includes the rest of the class body, all member-function bodies, and all member-initializer lists.28.1.
Iterator Definition 197 Programming and Data Structures, Release 0.3 (continued from previous page) typename List <T>::Iterator & List<T>::Iterator:: operator ++() { assert(node_ptr); // check whether this is a past-the-end iterator node_ptr = node_ptr->next; return*this; } Thefunctionmovestheiteratortothenextelementbyfollowingthe nextpointerofthecurrentnode.
Oncetheiterator has been moved, the function returns the iterator by reference, in keeping with the pattern for prefix increment .3 28.1.2 The typename Keyword The return type of operator++() is a reference to List<T>::Iterator ;Iterator is a member of a template that isdependent onthetemplateparameter T.C++requiresthe typename keywordbeforeadependentnamethatrefersto a type, so that the compiler knows that it is a type and not a value.4 The following illustrates when the typename keyword is required: template <typename U > voidfunc() { IntList list; // not a qualified type IntList::Iterator it1; // outer class does not depend on template parameter U List< int>::Iterator it2; // outer class does not depend on template parameter U typename List <U>::Iterator it3; // outer class depends on template parameter U intcapacity = SortedSet<U>::MAX_CAPACITY; // member is not a type } Anunqualified name, one without the scope-resolution operator, never needs the typename keyword.
In a qualified name, if the outer type does not depend on a template parameter, then no typename keyword is required. If the outer type does depend on a template parameter, then the typename keyword is required when the inner name refers to a type.If the inner name does not refer to a type, the typename keyword is erroneous to use, since it explicitly tells the compiler that the inner name is a type.Inpractice,compilerscanoftendeterminewhenthe typename keywordisrequired,andmanyC++programmersrely on the compiler to tell them that it is needed rather than learning the rules: $ g++ --std=c++17 foo.cpp foo.cpp:5:20: error: expected ';'after expression List<U>::Iterator it; ^ ; foo.cpp:5:21: error: use of undeclared identifier 'it' (continues on next page) 3Thepostfixincrementoperatorcanbeoverloadedaswell.
Todistinguishitssignaturefromprefix,C++usesadummy intparameterforpostfix: template <typename T > typename List <T>::Iterator List<T>::Iterator:: operator ++(int) { assert(node_ptr); // check whether this is a past-the-end iterator Iterator tmp = * this; // make a copy of this iterator node_ptr = node_ptr->next; returntmp; // return the copy } We need not provide a parameter name, since we are not actually using the parameter object. In keeping with the contract for postfix increment, the function returns a copy of the original iterator by value.4The reasons are beyond the scope of this course, but they have to do with the way the compiler instantiates templates.28.1.
Iterator Definition 198 Programming and Data Structures, Release 0.3 (continued from previous page) List<U>::Iterator it; ^ foo.cpp:5:3: error: missing 'typename 'prior to dependent type name 'List<int>::Iterator ' List<U>::Iterator it; ^~~~~~~~~~~~~~~~~ foo.cpp:9:3: note: in instantiation of function template specialization 'func<int> 'requested here func<int>(); ^ 3 errors generated. 28.1.3 Equality Comparisons Two iterators are defined as equal if either they are both past the end, or they “point to” the same element in the same list.Thus, they are equal exactly when their node_ptr members point to the same node.List<int>firstList<int>::Node3datumnextList<int>::Node-5datumnextList<int>::Node4datum0x0nextList<int>::Node2datumnextlastList<int>::Iteratornode_ptrList<int>::Iteratornode_ptr Figure 28.3: Two iterators are equal when their node pointers store the same address, pointing to the same node.
Comparing two iterators does not require them to be dereferenceable or even pointing to a valid element. Thus, the operators do not have a REQUIRES clause.template <typename T > boolList<T>::Iterator:: operator ==(Iterator rhs) const{ returnnode_ptr == rhs.node_ptr; } template <typename T > boolList<T>::Iterator:: operator !=(Iterator rhs) const{ returnnode_ptr != rhs.node_ptr; } 28.1.Iterator Definition 199 Programming and Data Structures, Release 0.3 We do not need to qualify Iterator in the parameter type – once the compiler knows that we are defining a member ofIterator , we can refer to the class with an unqualified name.28.1.4 Creating Iterators Wehavedefinedtheoperatoroverloadsfor Iterator .However,wehavenotprovidedameansofcreatingan Iterator object.Without a user-defined constructor, we do get an implicit default constructor, but it just initializes node_ptr with a junk value.
Instead, we define the following two constructors: •an explicit default constructor that makes the iterator a past-the-end iterator •a constructor that takes in a pointer to a node Thelatterisaprivateconstructor–the Nodeclassisnotpartoftheinterfaceforthelist,sotheconstructorthattakesa node pointer also is not part of the interface, and the outside world would not be able to call it even if it were. The constructor definitions are as follows: template <typename T > class List { ...public: class Iterator { public: // EFFECTS: Constructs a past-the-end iterator.Iterator() : node_ptr( nullptr) {} ...private: // EFFECTS: Constructs an iterator from the given node pointer.Iterator(Node *node_ptr_in) : node_ptr(node_ptr_in) {} Node *node_ptr; }; }; We can now implement begin() andend()member functions in Listthat return a start and past-the-end iterator, respectively.template <typename T > class List { ...
public: // EFFECTS: Returns an iterator that points to the first element, // or a past-the-end iterator if this list is empty. Iterator begin() { returnIterator(first); } // EFFECTS: Returns a past-the-end iterator.Iterator end() { returnIterator(); } }; 28.1.Iterator Definition 200 Programming and Data Structures, Release 0.3 Thebegin() functionreturnsaniteratorthatpointstothefirstelementinthelist.However,ifthelistisempty, first is null; this is the representation of a past-the-end iterator, so begin() returns such an iterator when the list is empty.Theend()function returns a default-constructed past-the-end iterator.Unfortunately, the implementation of begin() does not compile: ./List.hpp:122:12: error: calling a private constructor of class 'List<int>::Iterator ' return Iterator(first); ^ Aprivatememberisonlyaccessiblefromwithinthescopeoftheclassthatdefinesthemember.Theprivate Iterator constructor is a member of Iterator , but it is being accessed from outside the Iterator class.
On the other hand, Iterator iswithinthescopeof List,soitcanaccessprivate Listmemberssuchas Node. Thus,anestedclasscan access private members of the outer class, but not vice versa.28.2 Friend Declarations The solution to the problem above is a friend declaration , in which a class gives an outside entity access to the class’s private members.template <typename T > class List { ...public: class Iterator { friend class List ; ...}; }; A friend declaration can appear anywhere directly within a class body, and it tells the compiler that the given entity is allowed to access private members.The entity may be a function or a type; for instance, it is common practice to define the insertion operator as a friend: class Card { ...private: std::string rank; std::string suit; friendstd::ostream & operator <<(std::ostream &os, constCard &card); }; std::ostream & operator <<(std::ostream &os, constCard &card) { returnos << card.rank << " of " << card.suit; } Friendship is given, not taken.
For instance, class Cmay declare Fas a friend: friend class F ; This allows Fto access the private members of C, but it does not allow Cto access the private members of F. 28.2.Friend Declarations 201 Programming and Data Structures, Release 0.3 The friend declaration completes our iterator implementation, so we can now perform a traversal by iterator: List< int> list; for(inti = 1; i < 5; ++i) { list.push_back(i); } for(List< int>::Iterator it = list.begin(); it != list.end(); ++it) { cout << *it << endl; } This is just an abstraction over a loop that uses a node pointer directly: for(Node *node_ptr = list.first; node_ptr != nullptr; node_ptr = node_ptr->next) { cout << node_ptr->datum << endl; } The iterator starts at the firstmember, just like the traversal using a node pointer.Incrementing the iterator moves it to the next node, the same as in the loop above.Dereferencing the iterator accesses the respective node’s datum member, as in the body of the loop above.
The traversal ends when the iterator reaches a null pointer, just like the node-pointer loop. Thus, the iterator provides the same traversal as can be done from within the Listtemplate, but with the interface of a pointer rather than having the user rely on implementation details.28.3 Generic Iterator Functions Iteratorsprovideacommoninterfacefortraversingthroughasequenceofelements,andthestandard-librarysequences all support the iterator interface.vector< int> vec = { 1, 2, 3, 4 }; for(vector< int>::iterator it = vec.begin(); it != vec.end(); ++it) { cout << *it << endl; } The common interface allows us to write generic functions that work on any sequence.For instance, we can write a function template for finding the maximum element in a sequence: // REQUIRES: end is after or equal to begin // EFFECTS: Returns an iterator to the maximum element in [begin, end).// Returns begin when the sequence is empty.
template <typename Iter_type > Iter_type max_element(Iter_type begin, Iter_type end) { Iter_type max_so_far = begin; for(; begin != end; ++begin) { if(*max_so_far < *begin) { max_so_far = begin; } } returnmax_so_far; } Themax_element() function template takes a begin and end iterator of any type and returns an iterator to the max- imum element that is between the two iterators. As is standard in C++, the end iterator is an exclusive bound – the 28.3.Generic Iterator Functions 202 Programming and Data Structures, Release 0.3 function stops when it reaches endand does not dereference it.Then max_element() implements a standard find- the-max algorithm: start with the first element as the maximum so far, then update the max so far when a larger item is encountered.The iterators must be dereferenced to get to the elements to compare them, and the element type must support the <operator.
We can use max_element() with any iterator and element type, as long as the element type supports <: vector< int> vec; ..// fill vec with numbers cout << *max_element(vec.begin(), vec.end()) << endl; List< int> list; ..// fill list with numbers cout << *max_element(list.begin(), list.end()) << endl; List<Card> cards; ..// fill cards with Cards cout << *max_element(cards.begin(), cards.end()) << endl; int const SIZE = 10; doublearr[SIZE]; ..// arr fill with numbers cout << *max_element(arr, arr + SIZE) << endl; Asusualwithfunctiontemplates,thecompiler deducesthetemplateparameterfromthefunctionarguments. Thelast example illustrates that we can even use max_element() with an array; since a pointer has the same interface as an iterator,wejustneedtoprovide max_element() withapointertothefirstelementandanotherthatisjustpasttheend.The standard <algorithm> library contains many function templates such as std::max_element() that operate on iterators.
However, thestandard-library functiontemplates require aniterator to defineseveral membertype aliases to work: template <typename T > class List { ... public: class Iterator { ...public: usingiterator_category = std::input_iterator_tag; usingvalue_type = T; usingdifference_type = void; usingpointer = void; usingreference = T &; }; }; A discussion of these type aliases is beyond the scope of this course.Asanotherexample,thefollowingisafunctiontemplatethatdetermineswhetherasequencecontainsaduplicateitem.It compares every pair of elements with the ==operator to determine if any are equal: template <typename Iter_type > boolno_duplicates(Iter_type begin, Iter_type end) { for(; begin != end; ++begin) { (continues on next page) 28.3.
Generic Iterator Functions 203 Programming and Data Structures, Release 0.3 (continued from previous page) Iter_type other = begin; // copy iterator to current element ++other; // move copy one element forward for(; other != end; ++other) { if(*begin == *other) { // compare element with those that come after returnfalse; } } } returntrue; } 28.4 Iterator Invalidation Recallthatadanglingpointerpointstoaninvalidobject,onethatisnolongeralive. Sinceiteratorsrepresentindirection tosequenceelements,aniteratorcanalsoenduppointingtoaninvalidobject.Suchaniteratorissaidtobe invalidated .The following is an example: List< int> list; list.push_back(3); list.push_back(-5); list.push_back(2); list.push_back(4); List< int>::Iterator iter = list.begin(); cout << *iter << endl; list.pop_front(); // invalidates iter cout << *iter << endl; // UNDEFINED BEHAVIOR The code constructs a list and inserts elements into it.
It then creates an iterator that is pointing to the first element before proceeding to remove that element. This invalidates the iterator, so that dereferencing the iterator results in undefined behavior.In general, modifying a sequence can invalidate existing iterators.An iterator may be invalidated even if the element it is pointing to is not removed.For instance, a vector iterator is invalidated when a grow operation occurs, since the element the iterator is pointing to moves to a different location.A member function’s documentation should indicate whether it may invalidate iterators, as in the cppreference.com documentation for std::vector::push_back() : Ifthenew size()isgreaterthan capacity() thenalliteratorsandreferences(includingthepast-the-end iterator) are invalidated.Otherwise only the past-the-end iterator is invalidated.28.4.
Iterator Invalidation 204 Programming and Data Structures, Release 0.3 List<int>firstList<int>::Node3datumnextList<int>::Node-5datumnextList<int>::Node4datum0x0nextList<int>::Node2datumnextlastIteratornode_ptr Figure 28.4: Removing the element that an iterator is pointing to invalidates the iterator. 28.5 Type Deduction Suppose we wanted to write a function template that prints out the elements of a sequence.
We could write it to work with iterators: template <typename Iter_type > voidprint_all(Iter_type begin, Iter_type end) { for(Iter_type it = begin; it != end; ++it) { cout << *it << endl; } } On the other hand, we desire an interface that works directly on a sequence container: template <typename Sequence > voidprint_all( constSequence &sequence) { for(typename Sequence ::Iterator it = sequence.begin(); it != sequence.end(); ++it) { cout << *it << endl; } } Declaringtheiteratortypeisveryverbose,asitconsistsofbothaqualifiednameandthe typename keyword,sincethe qualifiednameisadependenttype. Furthermore,thedeclarationmakestheassumptionthattheiteratortypeisnamed Iterator , which is not true for standard-library containers that use lower-case type names.
Ratherthanwritingoutthetypeof itexplicitly,wecanaskthecompilertodeduceitforusbyusingthe autokeyword: template <typename Sequence > voidprint_all( constSequence &sequence) { for(autoit = sequence.begin(); it != sequence.end(); ++it) { cout << *it << endl; (continues on next page) 28.5. Type Deduction 205 Programming and Data Structures, Release 0.3 (continued from previous page) } } The compiler deduces the type from its initialization.If the return type of sequence.begin() is List<int>::Iterator , then the type of itis deduced to have type List<int>::Iterator .On the other hand, if thereturntypeis vector<Duck>::iterator ,thenthetypeof itisdeducedtobe vector<Duck>::iterator .The return type need not be a nested type; if it is char *, thenitwill be deduced to have type char *.Thus, not only does type deduction save us keystrokes for complicated types, it also abstracts over how the types are defined.28.5.
Type Deduction 206 Part IV Functional Programming 207 CHAPTER TWENTYNINE FUNCTION OBJECTS Lasttime,wesawiterators,whichareacommoninterfacefortraversingovertheelementsofasequence. Forinstance, the following function template works over any sequence of integers, determining if there is and odd element in the sequence: // REQUIRES: begin is before or equal to end // EFFECTS: Returns true if any element in the sequence // [begin, end) is odd.template <typename Iter_type > boolany_of_odd(Iter_type begin, Iter_type end) { for(Iter_type it = begin; it != end; ++it) { if(*it % 2 != 0) { returntrue; } } returnfalse; } We can then use any_of_odd() with any sequence type, as long as the elements are integers: List< int> list; vector< int> vec; intarray[10]; ...
cout << any_of_odd(list.begin(), list.end()) << endl; cout << any_of_odd(vec.begin(), vec.end()) << endl; cout << any_of_odd(array, array + 10)) << endl; Thetemplateisgenericovertheiteratortype,butitisnotgenericovertheconditionthatanelementmustmeet–itonly searches for odd elements and no other characteristic. Suppose we wanted instead to determine whether the sequence contains an even element.We could write an any_of_even() template: // REQUIRES: begin is before or equal to end // EFFECTS: Returns true if any element in the sequence // [begin, end) is even.template <typename Iter_type > boolany_of_even(Iter_type begin, Iter_type end) { for(Iter_type it = begin; it != end; ++it) { if(*it % 2 == 0) { returntrue; } } (continues on next page) 208 Programming and Data Structures, Release 0.3 (continued from previous page) returnfalse; } This code is almost exactly the same as that for any_of_odd() ; the only difference is the computation done in the test of the conditional.
Most of the code is duplicated, which is undesirable. Furthermore, if we wanted to determine whetherasequencecontainedanelementthatmetsomeothercondition,saywhetheranelementispositive,wewould have to write additional function templates that duplicate code.Ourgeneralstrategyforavoidingcodeduplicationinaproceduralabstractionistointroduceparametersforthepieces that differ.For a value that differs, we add a function parameter: intpower3( intx) { intresult = 1; for(inti = 0; i < 3; ++i) { result *= x; } returnresult; } intpower4( intx) { intresult = 1; for(inti = 0; i < 4; ++i) { result *= x; } returnresult; } intpower( intx,intn) { // add parameter to generalize intresult = 1; for(inti = 0; i < n; ++i) { result *= x; } returnresult; } intmain() { for(inti = 0; i < 10; ++i) { cout << power(42, i); // supply desired argument } } When it is a type that differs, we make the function a template and introduce a template parameter: intmax_int( intx,inty) { returnx < y ?
y : x; } Card max_card( constCard &x, constCard &y) { returnx < y ? y : x; } template <typename T > // add template parameter to generalize T max( constT &x, constT &y) { // pass objects of template-parameter type (continues on next page) 209 Programming and Data Structures, Release 0.3 (continued from previous page) // by reference returnx < y ?y : x; } intmain() { cout << max(3, -1) << endl; // template parameter deduced from arguments cout << max(Card(Card::RANK_TWO, Card::SUIT_SPADES), Card(Card::RANK_TOW, Card::SUIT_HEARTS)) << endl; } For a generic any_of() , however, it is an actual computation that differs: *it % 2 != 0 for odd numbers, *it % 2 == 0 for even numbers, *it > 0 for positive numbers, and so on.
We can use a function to represent such a computation: boolis_odd( intx) { returnx % 2 != 0; } boolis_even( intx) { returnx % 2 == 0; } boolis_positive( intx) { returnx > 0; } Once we have a function, the compiler translates it into machine code, which is placed in memory in the text segment when the program runs. Since the code is in memory, we can construct a pointer to it: bool(*func)( int) = &is_odd; func = &is_even; As the examples above demonstrate, we can apply the address-of operator to a function to obtain its address, just like for an object.Unlike an object, however, the address-of operator is optional: func = is_positive; The compiler implicitly inserts the operator for us.
We can call a function through a pointer by first dereferencing the pointer: bool(*func)( int) = is_odd; (*func)(-2); // returns false Like with the address-of operator, the compiler can implicitly insert this dereference for us: func(-2); // returns false 210 Programming and Data Structures, Release 0.3 Stack(grows down)THE BIG VOIDHeap(grows up)Static Storage(Fixed size)Text(The program)Address MAX Address 0 Figure 29.1: The memory for a program includes a segment that stores the program’s code. 29.1 Function-Pointer Types Before we proceed to implement a generic any_of() , let us examine the syntax of a function pointer more closely.bool(*func)( int); C++declarationsaregenerallyreadfromrighttoleft.However,theparenthesesaround *funcassociatethe *symbol with the name func.
Without the parentheses, we would have the following: bool*func2( int); Thisisadeclarationofafunctioncalled func2thattakesinan intandreturnsapointertoa bool–the*isassociated with the return type rather than the name func2. Withtheparentheses,the *hasthesamemeaningasforothervariables: itindicatesthatthevariablewearedeclaring isapointer.Thus, funcisapointer.Therestofthedeclarationtellsuswhatkindofpointeritis: apointertoafunction that takes an intas a parameter and returns a bool.To declare an appropriate function pointer, we can use the following steps: •Start with a function signature: intmax_int( intx,inty); •Remove the parameter names, which serve only as documentation in a declaration: intmax_int( int,int); 29.1.
Function-Pointer Types 211 Programming and Data Structures, Release 0.3 •Replace the function name with a variable name and the *symbol to indicate it is a pointer, surrounded by parentheses: int(*func3)( int,int); The result is that func3is a pointer to a function that takes two ints and returns an int. 29.2 Function-Pointer Parameters We can now write a generic any_of() that is parameterized both by an iterator type as well as a function to test an element: template <typename Iter_type > boolany_of(Iter_type begin, Iter_type end, bool(*func)( int)) { for(Iter_type it = begin; it != end; ++it) { if(func(*it)) { returntrue; } } returnfalse; } Since different iterators may have different types, we use a template parameter to allow an arbitrary kind of iterator.Forthetestofwhetheranelementsatisfiesacondition,weaddafunctionparameterthatisapointertoafunction.We call it using parentheses like any other function, and the compiler automatically dereferences the pointer to get to its code.
We can then specify which function to use when calling any_of() : List< int> list; vector< int> vec; intarray[10]; ... cout << any_of(list.begin(), list.end(), is_odd) << endl; cout << any_of(vec.begin(), vec.end(), is_even) << endl; cout << any_of(array, array + 10, is_positive)) << endl; The compiler implicitly takes the address of a function when we pass it to a function pointer.Functionsthattakeinanitemandreturnatruthvaluearequitecommon,andtheyarecalled predicates .Thus,abetter name for the function-pointer parameter in any_of() would bepredrather than func.// REQUIRES: begin is before or equal to end // EFFECTS: Returns true if pred returns true when applied to at // least one element in the sequence [begin, end).template <typename Iter_type > boolany_of(Iter_type begin, Iter_type end, bool(*pred)( int)) { for(Iter_type it = begin; it != end; ++it) { if(pred(*it)) { returntrue; } } returnfalse; } 29.2.
Function-Pointer Parameters 212 Programming and Data Structures, Release 0.3 29.3 Functors Withany_of() andis_positive() , we can determine whether a sequence contains an element that is greater than zero. What if we are interested in other thresholds, such as 32 or 212?
We don’t want to write separate functions for each value, as this duplicates code: boolgreater32( intx) { returnx > 32; } boolgreater212( intx) { returnx > 212; } Since what differs is just a value, we can write a function that has a parameter for the threshold value: boolgreater( intx,intthreshold) { returnx > threshold; } Unfortunately, we cannot use this with any_of() : it requires a pointer to a function that takes in one argument, not two: main.cpp:29:11: error: no matching function forcall to 'any_of ' cout << any_of(arr, arr + SIZE, greater) << endl; ^~~~~~ main.cpp:13:6: note: candidate function notviable: no known conversion from 'bool (int, int) 'to'bool (*)(int) 'for3rd argument bool any_of(Iter_type begin, Iter_type end, bool (*pred)(int)) { ^ 1 error generated. Furthermore,weneedsomewayofspecifyingthethreshold,andpassingthe greater() functiondirectlyto any_of() does not do so.
What we need is something that internally stores the threshold value and is callable with just one argument. More specifically, we want a first-class entity , which is an entity that supports the following: •It can store state.•It can be created at runtime.•It can be passed as an argument or returned from a function.Unfortunately,functionsarenotfirst-classentitiesinC++: theycannotbecreatedatruntime,andtheyareverylimited in how they can store information.1 Class types, on the other hand, do define first-class entities.A class-type object can store state in member variables, can be created at runtime, and can be passed between functions.So a class type could satisfy our needs, as long as therewereawaytocallitlikeafunction.Infact,C++doesallowaclass-typeobjecttobecallediftheclassoverloads the function-call operator.We refer to such a class as a functor.Afunctorisaclasstypethatprovidesthesameinterfaceasafunction,muchlikeaniteratorisaclasstypethatprovides the same interface as a pointer.
The following is a GreaterN class that stores a threshold and is also callable with a single argument: 1Afunctionmayhaveastaticlocalvariable,butitcanonlystoreasinglevalueatatime. Weneedanarbitraryamountofstorage–forinstance, we may have any number of threshold values we care about for greater() , so we need a way of creating multiple copies of the function that each have their own stored threshold value.29.3.Functors 213 Programming and Data Structures, Release 0.3 class GreaterN { public: // EFFECTS: Creates a GreaterN with the given threshold.GreaterN( intthreshold_in) : threshold(threshold_in) {} // EFFECTS: Returns whether or not the given value is greater than // this GreaterN 's threshold.bool operator ()(intx)const{ returnx > threshold; } private: intthreshold; }; Thefunction-calloperatormustbeoverloadedasamemberfunction,soithasanimplicit thispointerthatallowsusto accessamembervariable.
Wehavedeclaredthe thispointerasapointertoconst,sincethefunctiondoesnotmodify theGreaterN object. We also get to decide what the parameters are, as well as the return type.We have chosen a single parameter of type intand aboolreturn type, since we want a GreaterN object to act as a predicate on ints.We can create and use GreaterN objects as follows: intmain() { GreaterN greater0(0); GreaterN greater32(32); GreaterN greater212(212); cout << greater0(-5) << endl; // 0 (false) cout << greater0(3) << endl; // 1 (true) cout << greater32(9) << endl; // 0 (false) cout << greater32(45) << endl; // 1 (true) cout << greater212(42) << endl; // 0 (false) cout << greater212(451) << endl; // 1 (true) } We have declared GreaterN objects as local variables and initialized them by calling the constructor, the same as other class-type objects.We can then use a GreaterN object as the first operand of the function-call operator.
We pass whatever arguments are needed to invoke the overloaded member function, and as with any non-static member function, the thisparameter is implicitly passed. AGreaterN objectprovidesthesameinterfaceasthefunctionsrequiredby any_of() .However,itisnotafunctionor apointertoafunction;itstypeis GreaterN ,anditcannotbepassedtotheversionof any_of() wewrotepreviously.Instead, we need to write a new version that allows predicates of any type.Since it is a type that differs, we add a template parameter to refer to that type: // REQUIRES: begin is before or equal to end // EFFECTS: Returns true if pred returns true when applied to at // least one element in the sequence [begin, end).template <typename Iter_type ,typename Predicate > boolany_of(Iter_type begin, Iter_type end, Predicate pred) { for(Iter_type it = begin; it != end; ++it) { if(pred(*it)) { (continues on next page) 29.3.
Functors 214 Programming and Data Structures, Release 0.3 main StackGreaterN::operator()-5x greater212GreaterN212thresholdgreater32GreaterN32thresholdgreater0GreaterN0thresholdthis Figure 29.2: Invoking the overloaded function-call operator of a GreaterN object. (continued from previous page) returntrue; } } returnfalse; } Like iterators, functors are generally passed by value.We can now use any_of() with aGreaterN object: List< int> list; ...// fill list with numbers GreaterN greater0(0); cout << any_of(list.begin(), list.end(), greater0); // pass existing functor cout << any_of(list.begin(), list.end(), GreaterN(32)); // pass temporary functor Thecompilerdeducesthetemplateparameter Iter_type asList<int>::Iterator ,andtheparameter Predicate asGreaterN .We can still call any_of() with a function pointer: cout << any_of(list.begin(), list.end(), is_odd); // pass function In this case, the compiler deduces Predicate as the function-pointer type bool (*)(int) .
Byparameterizing any_of() withthepredicatetype,wecannowcallitonsequencesofobjectsthatareoftypesother thanint. As long as a sequence element can be passed to the predicate, the code will work.boolis_empty( conststring &s) { returns.empty(); } (continues on next page) 29.3.Functors 215 Programming and Data Structures, Release 0.3 (continued from previous page) intmain() { vector<string> vec; ...// fill vec with strings cout << any_of(vec.begin(), vec.end(), is_empty); } Exercise 1 Write a function list_count() that counts the number of elements in a list for which the given predicate returns true.Assume that Nodeis defined as struct Node { intdatum; Node *next; }; and use recursion to traverse the sequence of nodes.// EFFECTS: Returns the number of elements in the list that // starts at the given node for which the predicate // returns true.
template <typename Predicate > intlast( constNode *node, Predicate pred) { // your code here } 29.4 Comparators Recall the max_element() function template from last time: // REQUIRES: end is after or equal to begin // EFFECTS: Returns an iterator to the maximum element in [begin, end). // Returns begin when the sequence is empty.template <typename Iter_type > Iter_type max_element(Iter_type begin, Iter_type end) { Iter_type max_so_far = begin; for(; begin != end; ++begin) { if(*max_so_far < *begin) { max_so_far = begin; } } returnmax_so_far; } The function template uses the <operator to compare elements, so it only works on types that provide that operator.It will not work with a type such as Duckthat does not overload the less-than operator.However, we may still want to compareDucks according to some criteria, such as by their names or their ages.Thus, we need a way of specifying howmax_element() should compare objects.
We can do so by adding another parameter to represent a comparator , which takes two objects and returns a value that indicates how they compare to each other. // REQUIRES: end is after or equal to begin // EFFECTS: Returns an iterator to the maximum element in [begin, end) (continues on next page) 29.4.Comparators 216 Programming and Data Structures, Release 0.3 (continued from previous page) // according to the given comparator.Returns begin when // the sequence is empty.template <typename Iter_type ,typename Comparator > Iter_type max_element(Iter_type begin, Iter_type end, Comparator less) { Iter_type max_so_far = begin; for(; begin != end; ++begin) { if(less(*max_so_far, *begin)) { max_so_far = begin; } } returnmax_so_far; } Standard comparators in C++ do a less-than comparison, so we have modified max_element() to take in such a comparator.The type of the comparator is a template parameter so that either a functor or a function pointer can be used.
The code then calls the comparator with two arguments to determine if the first is less than the second. We can write a Duckcomparator that compares two ducks by name: class DuckNameLess { public: bool operator ()(constDuck &d1, constDuck &d2) const{ returnd1.get_name() < d2.get_name(); } }; Here, we have written the comparator as a functor; since it doesn’t require any storage, it could have been written as a function as well.2We can then call max_element() as follows: vector<Duck> vec; ...// fill vec with Ducks cout << (*max_element(vec.begin(), vec.end(), DuckNameLess())).get_name(); We pass a default-constructed DuckNameLess object as the comparator and get back an iterator to the Duckwith the maximum name.We then dereference the iterator to get to the Duckobject and call get_name() on it.3 Given our modifications to max_element() , we can no longer call it without a comparator argument, even for types that support the <operator.
However, the standard <algorithm> library provides a functor template std::less that just invokes the <operator, so we can use it with types that do have the operator: vector< int> vec; ... // fill vec with numbers cout << *max_element(vec.begin(), vec.end(), std::less< int>()); Itisalsopossibletowrite max_element() todefaulttousing std::less whenacomparatorisnotexplicitlyprovided, but that is beyond the scope of this course.2While either a functor or function would work, functors are actually more efficient since calling them does not require any indirection.The compiler can statically determine from the functor type which overloaded operator is called, while calling through a function pointer generally requires a dereference at runtime.Thus, functors are usually preferred over functions given a choice between the two.
3Standard-library iterators overload the ->operator, so we could use that operator to call get_name() directly rather than manually applying dereference followed by the dot operator. 29.4.Comparators 217 Programming and Data Structures, Release 0.3 29.5 Iterating over a Sequence Another common pattern is to iterate over a sequence, performing some operation on each element individually.We can write a for_each() function template that implements this pattern, taking in a function pointer or functor that applies to a single element: // REQUIRES: end is after or equal to end // EFFECTS: Applies func to each of the elements in the sequence // [begin, end) and returns func.template <typename Iter_t ,typename Func_t > Func_t for_each(Iter_t begin, Iter_t end, Func_t func) { for(Iter_t it = begin; it != end; ++it) { func(*it); } returnfunc; } We return the funcargument, in case it contains data that are useful to the caller.
For instance, the following functor stores the sum of integer elements: class Accumulator { public: void operator ()(intx) { sum += x; } intget_sum() const{ returnsum; } private: intsum = 0; }; We can then compute the sum of the elements in a sequence: vector< int> vec; ... // fill vec with numbers Accumulator summer; summer = for_each(vec.begin(), vec.end(), summer); cout << summer.get_sum() << endl; To print out the elements in a sequence to a stream, we can write a functor template for printing: template <typename T > class Printer { public: Printer(std::ostream &os) : output(os) {} void operator ()(constT &item) const{ output << item << std::endl; } (continues on next page) 29.5.Iterating over a Sequence 218 Programming and Data Structures, Release 0.3 (continued from previous page) private: std::ostream &output; }; The member variable must be a reference, since streams do not generally support copying.
We can then use Printer to print out each element in a sequence: intmain() { List< int> list; ... // fill list with numbers ofstream fout("list.out"); for_each(list.begin(), list.end(), Printer< int>(fout)); } 29.5.Iterating over a Sequence 219 CHAPTER THIRTY IMPOSTOR SYNDROME Inadditiontobuildingourprogrammingskills,itisalsoimportanttodevelopanappropriateawarenessofourownabil- ities.Unfortunately,manyofusencounter impostorsyndrome ,wherewedonotinternalizeourownaccomplishments.Despite demonstrating success in a course like this, we often fear being exposed as a “fraud.” Recognizingimpostorsyndromeisthefirststeptoovercomingit.Thefollowingarecommoncharacteristicsofpeople who have impostor syndrome: •They attribute their success to external factors.•They fear being revealed as a fraud.•They convince themselves that they are not good enough.•They have a hard time accepting compliments for their accomplishments.
Impostor syndrome differs from implicit bias in that the latter affects how we subconsciously view others, while the former affects how we view ourselves. The National Center for State Courts defines implicit bias as: The bias in judgment and/or behavior that results from subtle cognitive processes (e.g., implicit attitudes and stereotypes) that often operate at a level below conscious awareness and without intentional control.Ofcourse,theseimplicitattitudesalsoaffecthowweviewourselves,soeventhoughimpostorsyndromeaffectsevery- one, it tends to have a higher effect on people in underrepresented groups.The result of impostor syndrome is to doubt ourselves, having feelings such as: •“I was hired to fill a diversity quota.” •“Everyone else seems smarter than me.” •“If I’m not getting an A, how am I going to survive in future courses?” •“Nobody else here is like me – I don’t belong in this class”.
•“I don’t like asking questions in class because I’m afraid others will realize I don’t know what I’m doing.” •“Maybe EECS isn’t for me; I should drop.” Thetruthisthatalmosteveryonesuffersfromfeelingslikethis. Surveysonimpostorsyndromehavefoundthat“about 70 percent of people from all walks of life – men and women – have felt like impostors for at least some part of their careers.”4The likelihood is that many of us are experiencing this right now, in this course.There are steps we can take to overcome impostor syndrome: •Stop comparing ourselves to others.•Encourage each other.•Join student organizations and connect with other students.4Gravois, J.(2007).You’re not fooling anyone.The Chronicle of Higher Education, 54(11), A1.220 Programming and Data Structures, Release 0.3 •Accept our accomplishments.•Find a mentor.We do not have to experience this alone; instead, we should support each other and find others we can lean on.
The following are additional resources on impostor syndrome: •University of Michigan CAPS page on impostor syndrome •TED talk on how students of color confront impostor syndrome •American Psychological Association article on impostor syndrome 221 CHAPTER THIRTYONE RECURSION We have seen several forms of abstraction, where we use something for what it does rather than how it works. It can beusefultorefertoanabstractionwhenwearestillinthemiddleofimplementingit.Forinstance,ourdefinitionofa linked-list node refers to itself: struct Node { intdatum; Node *next; }; Such a definition is recursive, where it uses itself as part of its definition.Functions can also be recursive.As an example, consider the factorial of a nonnegative integer: 𝑛!={︃ 1 if𝑛= 0or𝑛= 1 𝑛*(𝑛−1)*···* 1otherwise We can implement an iterative function to compute this: // REQUIRES: n >= 0 // EFFECTS: Computes and returns n!.
intfactorial( intn) { intresult = 1; while(n > 0) { result *= n; --n; } returnresult; } Ontheotherhand,wecanobservethat (𝑛−1)! = ( 𝑛−1)*···* 1,sothatwecanmathematicallydefinefactorialin terms of itself: 𝑛!={︃ 1 if𝑛= 0or𝑛= 1 𝑛*(𝑛−1)!otherwise Such a mathematical definition is called a recurrence relation .It translates into code as follows: // REQUIRES: n >= 0 // EFFECTS: Computes and returns n!.intfactorial( intn) { if(n == 0 || n == 1) { return1; (continues on next page) 222 Programming and Data Structures, Release 0.3 (continued from previous page) }else{ returnn * factorial(n - 1); } } This function is recursive, since it calls itself as part of its definition.We can then call factorial() as follows: intmain() { intresult = factorial(3); cout << "3!= " << result << endl; } The activation records created by this program are shown in Figure 31.1.
Stackmain0x1000?resultStackmain0x1000?resultfactorial0x10043nStackmain0x1000?resultfactorial0x10043nfactorial0x10082n Stackmain0x1000?resultfactorial0x10043nfactorial0x10082nfactorial0x100c1n Figure 31.1: Activation records for a call to the recursive version of factorial() . Whenthecall factorial(3) isevaluated,anactivationrecordiscreated,andtheparameter nisinitializedwithvalue 3.Thebodyof factorial() runs,anditcalls factorial(2) .Thiscreatesanotheractivationrecord,anditsparam- eternisinitializedto 2.Withinthecontextofthatactivationrecord,thebodyof factorial() isexecuted,anditcalls factorial(1) .Anotheractivationrecordiscreated,with ninitializedto 1.Thebodyruns,returning 1,whichreplaces thefunctioncallinthecaller.Theactivationrecordfor factorial(1) isdestroyed,and factorial(2) resumes.The lattercomputes 2 * 1andreturns 2.Theactivationrecordfor factorial(2) isdestroyed,and factorial(3) con- tinues where it left off.It computes 3 * 2, returning 6.
Its activation record is reclaimed, and main()resumes, initializing resultto6, the correct value for 3!. Operationally,therecursivedefinitionworksbecauseeachinvocationof factorial() getsitsownactivationrecord, and the body of the function is executed within the context of that activation record.More conceptually, it works by usingfactorial() as an abstraction, even while we are still in the midst of implementing that abstraction!We call this “the recursive leap of faith” – we trust that the abstraction works, even if we haven’t finished writing it yet.
In general, a recursive abstraction requires the following: •base cases , which are cases we can implement directly without recursion •recursivecases ,wherewebreakdowntheprobleminto subproblems thataresimilartotheproblembut“smaller,” meaning closer to a base case As another example, the following recursive function prints out the integers between a start and end: 223 Programming and Data Structures, Release 0.3 // REQUIRES: end >= start // MODIFIES: cout // EFFECTS: Prints the numbers in [start, end) in order. voidprint_numbers( intstart, intend) { // base case if(start == end) { return; } // recursive case cout << start << endl; print_numbers(start + 1, end); } The base case is when the start and end are the same, in which case the function immediately returns without printing anything.Therecursivecaseprintsoutasinglenumberandthenrecursivelycomputesthesubproblemof printingthe numbers in [𝑠𝑡𝑎𝑟𝑡 + 1, 𝑒𝑛𝑑).
The latter is smaller than the original problem, since it requires printing out one fewer number. Let us consider another example, that of computing the number of ducks on a duck farm.Suppose the farm starts with five baby ducklings.Assume that a duck lays three eggs each month, once the duck is at least a month old itself.Furthermore, an egg takes a month to hatch, and our ducks never die.How many ducks does the farm have after 𝑛 months?Westartbyworkingoutthefirstfewmonthsbyhand.Inmonth0,thereare5babyducklings,whicharenotoldenough to lay eggs.In month 1, there are now 5 grown ducks, each of which lays 3 eggs, resulting in 15 eggs in total.Let’s use a table to keep track of what we have: Month Adult Ducks Ducklings Eggs Total Ducks 0 0 5 05 1 5 0 155 2 5 15 1520 3 20 15 6035 4 35 60 10595 5 95 105 285200 In month 2, the 15 eggs hatch, resulting in 15 ducklings.The 5 adult ducks lay 15 more eggs.In month 3, these eggs hatch, resulting in 15 ducklings.
The previous 15 ducklings are now adults, so that we have a total of 20 adult ducks, which lay 60 eggs. And so on in months 4 and 5.The total number of ducks is 200 at month 5.We observe that the number of adult ducks in any particular month is the same as the total number of ducks in the previous month.The number of ducklings in a month is three times the number of adult ducks in the previous month, which is the same as the total number of ducks in the month before.This results in the following recurrence relation for the total number of ducks: 𝑑𝑢𝑐𝑘𝑠 (𝑛) ={︃ 5 if𝑛= 0or𝑛= 1 𝑑𝑢𝑐𝑘𝑠 (𝑛−1) + 3*𝑑𝑢𝑐𝑘𝑠 (𝑛−2)otherwise Thebasecasesarethefirsttwomonths,whenthereare5totalducks.
(Wecannotapplytherecurrenceforthesecases, since it would rely on the number of ducks in month -1, which is ill-defined.) We can now write a function to compute the number of ducks: // REQUIRES: n >= 0 // EFFECTS: Computes the number of ducks in month n, assuming 5 (continues on next page) 224 Programming and Data Structures, Release 0.3 (continued from previous page) // ducklings to start. intnum_ducks( intn) { // base cases if(n <= 1) { return5; } // recursive case returnnum_ducks(n - 1) + 3 * num_ducks(n - 2); } Observethattherearetwosubproblemshere, ducks(n - 1) andducks(n - 2) .Bothareclosertoabasecasethan ducks(n) , so the recursive computation still works.Recursive algorithms are not just for math problems.
The following is an algorithm for lifting a box of heavy books: voidlift_box(Box &box) { if(too_heavy(box)) { // recursive case Book book = remove_book(box); lift_box(box); // "smaller" box add_book(box, book); }else{ // base case move_box(box); } } Here,thebasecaseiswhenwecandirectlymovethebox,suchaswhenitisempty. Otherwise,wereducetheproblem of moving a heavy box to the subproblem of a box with one less book, using recursion to solve that subproblem.We take the recursive leap of faith that the function will correctly solve that subproblem.We then need only add back the book we removed.Heavy BookHeavy BookHeavy Book Heavy BookHeavy BookHeavy BookHeavy BookHeavy BookHeavy BookHeavy BookHeavy BookHeavy BookHeavy BookHeavy Book Figure 31.2: Recursive algorithm for lifting a box of heavy books.Asanothernon-mathexample,wewritearecursivefunctiontoreversethecontentsofanarray.Foranemptyarrayor anarraywithoneelement,nothingneedstobedone,constitutingthebasecase.
Otherwise,wereverseasmallerarray, 225 Programming and Data Structures, Release 0.3 one that excludes the ends, and then swap the two ends: // EFFECTS: Reverses the array starting at 'left 'and ending at // (and including) 'right '. voidreverse( int*left, int*right) { if(left < right) { reverse(left + 1, right - 1); inttemp = *left; *left = *right; *right = temp; } } The function reverses the elements in [𝑙𝑒𝑓𝑡, 𝑟𝑖𝑔ℎ𝑡 ].The subproblem is the set of elements in [𝑙𝑒𝑓𝑡+ 1, 𝑟𝑖𝑔ℎ𝑡−1], whichisclosertothebasecaseofanarraywithzerooroneelement.Asalways,wetaketherecursiveleapoffaiththat the subproblem will be computed correctly.We can call reverse() as follows: intmain() { const int SIZE = 8; intarray[SIZE] = { 1, 2, 3, 4, 5, 6, 7, 8 }; reverse(array, array + SIZE - 1); // reverse whole array reverse(array + 1, array + 3); // reverse elements 1-3 } 31.1 Tail Recursion Consider the efficiency of the reverse() function above.
For an array of size 𝑛, it performs⌊𝑛/2⌋swap operations, taking O (𝑛)time. The algorithm also uses O (𝑛)space: each recursive call has an activation record, and there are ⌊𝑛/2⌋+ 1total calls.On the other hand, the following iterative algorithm uses only a single activation record, resulting in constant, O (1), space: // EFFECTS: Reverses the array starting at 'left 'and ending at // (and including) 'right '.voidreverse( int*left, int*right) { while(left < right) { inttemp = *left; *left = *right; *right = temp; ++left; --right; } } The fundamental difference is that this algorithm solves the subproblem afterdoing the extra work for the original problem, i.e.swapping the two ends.An equivalent recursive implementation would be the following: // EFFECTS: Reverses the array starting at 'left 'and ending at // (and including) 'right '.voidreverse( int*left, int*right) { (continues on next page) 31.1.
Tail Recursion 226 Programming and Data Structures, Release 0.3 (continued from previous page) if(left < right) { inttemp = *left; *left = *right; *right = temp; reverse(left + 1, right - 1); } } Here,therecursivecallisa tailcall,meaningthatthecallisthelastthingthathappensinthefunction,andnoworkis doneafterthetailcallreturns.1Sincenoworkisdoneafterthetailcall,thereisnoneedtoretaintheactivationrecord of the caller, and it can be discarded. Many compilers recognize tail calls and perform tail-call optimization (TCO) , where the activation record for the tail callreusesthespaceofthecaller’sactivationrecord.Inthe g++compiler,TCOisenabledatoptimizationlevel2( -O2).TCO is not restricted to recursive functions; as long as a function call is the last thing that happens in its caller, it is a tailcallandtheoptimizationcanapply.However,tail-calloptimizationismostimportantforrecursivefunctions,since it can reduce the space usage of the computation by a large factor.
A function is said to be tail recursive if it is recursive, and all recursive calls are tail calls. Rather than using a linear amount of space, a tail-recursive computation requires only constant space when tail-call optimization is applied.For instance, the tail-recursive version of reverse() uses space for only a single activation record under TCO.In order for a computation to be tail recursive, it must do all its work in the active flow of the computation, before makingarecursivecall.Acomputationthatdoesitsworkinthe passiveflow mustwaituntilarecursivecallcompletes before doing work, so that the recursive call is not a tail call.Asaconcreteexample,thepriorrecursiveimplementationof factorial() isnottailrecursive,sinceitdoesitswork in the passive flow: intfactorial( intn) { if(n == 0 || n == 1) { return1; }else{ returnn * factorial(n - 1); } } The multiplication must be done after the recursive call returns, so the function is not tail recursive.
Forthefunctiontobetailrecursive,weneedthemultiplicationtobeintheactiveflow. Todoso,wecompute 𝑛inthe initial call to factorial() on𝑛,𝑛*(𝑛−1)in the call on 𝑛−1,𝑛*(𝑛−1)*(𝑛−2)in the call on 𝑛−2, and so on until we reach 1.At each step, we keep track of the product so far: intfactorial( intn,intresultSoFar) { if(n == 0 || n == 1) { returnresultSoFar; }else{ returnfactorial(n - 1, n * resultSoFar); } } To call this function, we need to seed resultSoFar with the multiplicative identity of 1: 1Whether or not a function call is a tail call is not a syntactic property, but is determined by whether or not work must be done after the call returns.For example, if a nontrivial destructor for a local variable must be run after the call returns, the call is not a tail call.31.1.Tail Recursion 227 Programming and Data Structures, Release 0.3 cout << factorial(5, 1) << endl; However, this is a different interface than our previous versions of factorial() .
To retain the same interface, we move the actual computation to a helper function and abstract the call to it: static int factorial_helper( intn,intresultSoFar) { if(n == 0 || n == 1) { returnresultSoFar; }else{ returnfactorial_helper(n - 1, n * resultSoFar); } } intfactorial( intn) { returnfactorial_helper(n, 1); } Helper functions are a common pattern for tail-recursive computations that require a seed value. Not all tail-recursive algorithms require a helper function, however; the tail-recursive print_numbers() andreverse() functions above do not need a seed value, so they work without helper functions.31.2 Kinds of Recursion Wehavenowseenseveraldifferentkindsofrecursion.Afunctionis linearrecursive ifitisrecursive,buteachinvocation of the function makes at most one recursive call.Such a function reduces each recursive case to a single subproblem.The various recursive factorial() andreverse() functions above are all linear recursive.
Afunctionis tailrecursive ifitislinearrecursive,andeveryrecursivecallisthelastthingthathappensintheinvocation that makes the recursive call. We have seen both tail-recursive and non-tail-recursive variants of reverse() and factorial() .Afunctionis treerecursive ifasingleinvocationofthefunctioncanmakemorethanonerecursivecall.Suchafunction subdivides a recursive case into multiple subproblems.The num_ducks() function above is tree recursive.Drawing out the recursive call graph for a tree-recursive function, we end up with a branching structure that resembles a tree, explaining the nomenclature.num_ducks(4)num_ducks(2)num_ducks(1)num_ducks(0)num_ducks(3)num_ducks(2)num_ducks(1)num_ducks(1)num_ducks(0) Figure 31.3: Call structure of a tree-recursive function.31.2.Kinds of Recursion 228 Programming and Data Structures, Release 0.3 31.3 Iteration vs.Recursion Iteration and recursion are two approaches to solving complex problems.
Conceptually, an iterative algorithm often dividesacomputationintoindividualdiscretesteps,thecombinationofwhichformsasolutiontothewholeproblem. In contrast, recursive algorithms generally express a computation in terms of smaller versions of the same problem.Both iteration and recursion have the same computational power; an iterative algorithm can be converted to a tail- recursive implementation and vice versa.A non-tail-recursive computation can also be rewritten iteratively; however, theiterativeversionmayrequireexplicitstorage.Thenon-tail-recursivealgorithmcanstoredatainmultipleactivation records,whiletheiterativeoneonlyhasasingleactivationrecordtoworkwith,soitmayneedanexplicitdatastructure suchasavectortostoreitsdata.Techniquessuchas dynamicprogramming canbeusedingeneraltoconvertarecursive algorithm to an iterative one, but they are beyond the scope of this course.31.3.Iteration vs.
Recursion 229 CHAPTER THIRTYTWO STRUCTURAL RECURSION Last time, we discussed the concept of recursion, where an abstraction uses itself as part of its implementation, and we saw its application to procedural abstractions. We turn our attention now to structural recursion , where we use recursion in defining the representation of an abstract data type.32.1 Recursive Lists The data representation of a linked list is an example of structural recursion: the Nodetype uses itself in its own representation: struct Node { intdatum; Node *next; }; This representation satisfies the requirements for a recursive abstraction: •The empty list is the base case, represented by a null pointer.•Anon-emptylistisarecursivecase;itcanbesubdividedintothefirstnodeandtherestofthelist,whichrepresents a list in its own right.
Node1datumnextNode2datumnextNode4datum0x0nextNode3datumnextSmaller list Figure 32.1: The representation of a non-empty list consists of a node followed by the representation of a smaller list. Independent of its representation, a linked list can actually be defined recursively as either an empty list, or a datum followed by a smaller list.Given the recursive definition of a list, it is natural to process a list with a recursive function.The base case of the recursivefunctionwillbetheminimum-sizelistallowedbythefunction,andlargerlistswillbehandledintherecursive case.As an example, the following is a recursive function to compute the length of a list: 230 Programming and Data Structures, Release 0.3 datum sublist 1 2 3 4 Base caseRecursive case datumsublist Figure 32.2: Recursive definition of a list.// REQUIRES: node represents a valid list // EFFECTS: Computes the length of the list that starts at the // given node.
intlength( constNode *list) { if(list == nullptr) { // empty list return0; }else{ // non-empty list return1 + length(list->next); // list->next is a smaller list } } The length of an empty list is 0. The length of a non-empty list is one more than the length of the rest of the list; the elements in the list consist of the initial datum and the elements in the rest of the list.We use the length() function itselfasanabstractiontocomputethenumberofelementsintheremainderofthelist,takingtherecursiveleapoffaith that it will compute the right answer.Asanotherexample,considertheproblemoffindingthemaximumelementinalist.Unlikefor length() ,theminimal list is not an empty one, since an empty list has no elements in it.Instead, the minimum required size is a list with a singledatum,inwhichcasethemaximumelementisjustthatlonedatum,constitutingourbasecase.Foralargerlist, we can break it down recursively as follows: 1.Findthemaximumelementintherestofthelist.
Thiselementisatleastaslargeasanyotherelementintherest of the list. 2.Compare the first element to the max of the remainder.The larger of the two is transitively at least as large as the elements in the rest of the list.The following implements this algorithm: // REQUIRES: node represents a valid, non-empty list // EFFECTS: Returns the maximum element in the list that starts at // the given node.intlist_max( constNode *list) { if(list->next == nullptr) { // list has only one element returnlist->datum; }else{ // list has more than one element returnstd::max(list->datum, // compare first datum to (continues on next page) 32.1.Recursive Lists 231 Programming and Data Structures, Release 0.3 (continued from previous page) list_max(list->next)); // max of rest of list } } The base case is a list with one element.Such a list has an empty nextlist, so we check for that and return the list’s lone datum.
The recursive case computes the max of the rest of the list and then uses std::max() to determine the maximum of that item and the first item in the list. As always, we take the recursive leap of faith, assuming that the recursive call to list_max() computes the right answer for the smaller list.Exercise 2 Write a function list_sum() that recursively computes the sum of the elements in a list.// EFFECTS: Computes the sum of the elements in the list that // starts at the given node.intlist_sum( constNode *node) { // your code here } Exercise 3 Write a function last()that recursively finds and returns the last element of a non-empty list.// REQUIRES: node represents a valid, non-empty list // EFFECTS: Returns the last element in the list that starts at // the given node.intlast( constNode *node) { // your code here } 32.2 Trees A list is a linear-recursive data structure: each non-empty list is subdivided into a datum and a single smaller list.
A treeisadatastructurethatis,naturally,treerecursive. Anon-emptytreeissubdividedintoadatumandseveralsmaller trees.In this course, we only consider binary trees , where non-empty trees are subdivided into exactly two smaller trees.The term treestems1from the fact that its branching structure resembles that of a botanical tree.Terminology with respect to tree data structures borrows from both botanical and family trees.•Therootisthenodethatoriginatesthebranchingstructure.Inourdiagrams,therootispicturedatthetopofthe tree.•Anon-emptytreeconsistsofa parentnodeandtwo childnodes.Forabinarytree,thereisa leftchildandaright child.Nodes that have the same parent are siblings.•A node whose children are all empty is a leaf.•The size of a tree is the number of elements it contains.•Theheightof a tree is the number of levels at which it has elements.Equivalently, it is the length of the longest path from the root to a leaf node.
Algorithms on trees are often written as tree-recursive functions, so that the recursive case makes more than one recursive call. The general strategy is to directly compute the result for the smallest tree allowed by the function, constitutingthebasecase.Therecursivecasemakesrecursivecallstocomputetheresultsfortheleftandrightchildren, then combines those results with the datum at the root to compute the answer for the whole tree.1Pun intended.32.2.Trees 232 Programming and Data Structures, Release 0.3 leftsubtree rightsubtree datumBase caseRecursive case 3 5 9 8 7 4 6 leftsubtreerightsubtreedatum Figure 32.3: Recursive definition of a tree.A non-empty tree consists of a datum and two smaller trees.7 6 4 2 9 1 5 height=5 Figure32.4: Theheightofatreeisthenumberoflevelsthatcontainelements,orequivalently,thelengthofthelongest path from root to a leaf.32.2.
Trees 233 Programming and Data Structures, Release 0.3 As an example, the following algorithm computes the size of a tree: •The size of an empty tree is zero. •The size of a non-empty tree is the size of the left child, plus the size of the right child, plus one for the root datum.Before we can implement this algorithm in code, we need a data representation.As with a list, we use a Nodestruct, but it now has a datum and pointers to left and right Nodes: struct Node { intdatum; Node *left; Node *right; }; Like a list, we use a null pointer to represent an empty tree.Node5datumleft0x0right 5 8 4 2 Node8datumleftrightNode4datum0x0left0x0rightNode2datum0x0left0x0right Figure 32.5: Data representation of a tree, using a node for each element and null pointers for empty trees.We can now implement the size()function: // REQUIRES: node represents a valid tree // EFFECTS: Returns the number of elements in the tree represented // by the given node.
intsize( constNode *tree) { if(!tree) { // empty tree return0; }else{ // non-empty tree return1 + size(tree->left) + size(tree->right); } } Aswithotherrecursivefunctions,wetaketherecursiveleapoffaiththat size()computestherightansweronsmaller trees. The height of a tree is the number of levels it contains.An empty tree contains no levels, so its height is zero.For 32.2.Trees 234 Programming and Data Structures, Release 0.3 a non-empty tree, we exploit the alternate definition of height, that it is the length of the longest path from root to leaf.The longest such patch is just one node longer than the longest path in the child subtrees, since the root adds one additional node to the part of the path contained in a child.Thus, we compute the height as follows: // REQUIRES: node represents a valid tree // EFFECTS: Returns the height of the tree represented by the given // node.
intheight( constNode *tree) { if(!tree) { // empty tree return0; }else{ // non-empty tree return1 + std::max(height(tree->left), height(tree->right)); } } We usestd::max() to obtain the longer path from the two child trees, then add one to the result to account for the root node. Exercise 4 Writeafunction tree_contains() thatdetermineswhetherthegivenvalueiscontainedinthegiven tree.// EFFECTS: Returns whether the tree rooted at the given node // contains the given value.booltree_contains( constNode *node, intvalue) { // your code here } Exercise 5 Write a function count_leaves() that counts the number of leaf nodes in the given tree.Hint:You will likely need two base cases.// EFFECTS: Returns the number of leaf nodes in the tree rooted // at the given node.
intcount_leaves( constNode *node) { // your code here } 32.2.1 Tree Traversals The following function prints every element in a tree to standard output: // REQUIRES: node represents a valid tree // MODIFIES: cout // EFFECTS: Prints each element in the given tree to standard out, // with each element followed by a space. voidprint( constNode *tree) { if(tree) { // non-empty tree cout << tree->datum << " "; print(tree->left); print(tree->right); } } 32.2.Trees 235 Programming and Data Structures, Release 0.3 Thisalgorithmprocessesarootdatumbeforeprocessinganyofthedatainthechildren.Itthusimplementsa preorder traversal.For the tree in Figure 32.4, it prints the elements in the order 6 4 1 7 2 9 5 .Moving the print statement results in alternate orderings.The following implements an inorder traversal : if(tree) { // non-empty tree print(tree->left); cout << tree->datum << " "; print(tree->right); } Thedataintheleftchildisprocessedfirst,thentherootdatum,thenthedataintherightchild.
Forthetreewithheight 5, it prints 1 4 6 2 5 9 7 . Apostorder traversal processes the root datum after the data in the children: if(tree) { // non-empty tree print(tree->left); print(tree->right); cout << tree->datum << " "; } For the same tree, the postorder traversal prints 1 4 5 9 2 7 6 .The structure of a binary tree can be uniquely determined by knowing any two of these orderings.32.2.Trees 236 CHAPTER THIRTYTHREE BINARY SEARCH TREES (BSTS) Last time, we saw binary trees, which are a recursive data structure that is either empty, or consists of an element and twosubtrees.A binarysearchtree(BST) isabinarytreewhoseelementsarestoredinanorderthatmaintainsasorting invariant.Specifically, a binary search tree is either: •empty, or •a root datum with two subtrees such that: 1.The two subtrees are themselves binary search trees.2.Every element in the left subtree is strictly less than the root datum.3.
Every element in the right subtree is strictly greater than the root datum.1 Figure 33.1 shows an example of a binary search tree. 6 5 9 1 7 2 10 < xsubtree x > xsubtree Figure 33.1: A binary search tree.Every element in the left subtree is less that the root datum, and every element in the right subtree is greater than the root.Theleftandrightsubtreesmeettherequirementsforabinarysearchtree.Thus,thewholetreeisabinarysearch tree.1Our binary search trees do not permit duplicate elements, since we will be using them to build set and map abstractions.If a BST does permit duplicates, it will use a modified definition that allows items equal to the root in one of the subtrees.237 Programming and Data Structures, Release 0.3 Figure 33.2 depicts trees that do not meet the definition of a binary search tree.5 3 7 2 5 3 1 2 Figure 33.2: Trees that violate the invariants for a binary search tree.Inthetreeontheleft,theleftsubtreecontainstheelement7,whichisnotsmallerthantherootelement5.
Thisviolates thesecondconditionintherecursivedefinitionaboveofaBST.Inthetreeontheright,therightsubtreeisempty,which is a valid binary search tree. However, the left subtree is not a valid BST, since it does not meet the sorting invariant for a BST.Thus, the tree on the right is not a binary search tree.Abinarysearchtreeisthusnamedbecausesearchingforanelementcanbedoneefficiently,intimeproportionaltothe height of the tree rather than the size.A search algorithm need only recurse on one side of the tree at each level.For example, in searching for the element 2 in the BST in Figure 33.1, the element must be in the left subtree, since 2 is less than the root element 6.Within the left subtree, it must again be to the left, since 2 is less than 5.Within the next subtree, the 2 must be to the right of the 1, leading us to the actual location of the 2.
More generally, the following algorithm determines whether or not a BST contains a particular value: •If the tree is empty, it does not contain the value. •Otherwise, if the root datum is equal to the value, the tree contains the element.•If the value is less than the root element, it must be in the left subtree if it is in the tree, so we repeat the search on the left subtree.•Otherwise, the value is greater than the root element, so it is in the right subtree if it is in the tree at all.Thus, we repeat the search on the right subtree.Thefirsttwocasesabovearebasecases,sincetheydirectlycomputeananswer.Thelattertwoarerecursivecases,and we take the recursive leap of faith that the recursive calls will compute the correct result on the subtrees.The algorithm leads to the following implementation on our tree representation: // REQUIRES: node represents a valid binary search tree // EFFECTS: Returns whether or not the given value is in the tree // represented by node.
boolcontains( constNode *node, intvalue) { if(!node) { // empty tree returnfalse; }else if (node->datum == value) { // non-empty tree, equal to root returntrue; }else if (value < node->datum) { // less than root returncontains(node->left, value); }else{ // greater than root returncontains(node->right, value); } } 238 Programming and Data Structures, Release 0.3 This implementation is linear recursive, since at most one recursive call is made by each invocation of contains() . Furthermore,everyrecursivecallisatailcall,sotheimplementationistailrecursive.Thisexampleillustratesthatthe body of a linear- or tail-recursive function may contain more than one recursive call, as long as at most one of those calls is actually made.Let us consider another algorithm, that of finding the maximum element of a BST, which requires there to be at least one element in the tree.If there is only one element, then the lone, root element is the maximum.
The root is also the maximum element when the right subtree is empty; everything in the left subtree is smaller than the root, making the root the largest item. On the other hand, when the right tree is not empty, every element in that subtree is larger than therootandeverythingintheleftsubtree.Thenthelargestelementinthewholetreeisthesameasthelargestelement in the right subtree.Summarizing this, we have the following algorithm: •If the right subtree is empty, then the root is the maximum.•Otherwise, the maximum item is the maximum element in the right subtree.We implement the algorithm as follows: // REQUIRES: node represents a valid non-empty binary search tree // EFFECTS: Returns the maximum element in the tree represented by // node.inttree_max( constNode *node) { if(!node->right) { // base case returnnode->datum; }else{ // recursive case returntree_max(node->right); } } As withcontains() ,tree_max() is tail recursive, and it runs in time proportional to the height of the tree.
33.1 The BinarySearchTree Interface In the full linked-list definition we saw in Linked Lists , we defined a separate IntList class to act as the interface for the list, defining Nodeas a member of that class. We then generalized the element type, resulting in a Listclass template.We follow the same strategy here by defining a BinarySearchTree class template as the interface for a BST.template <typename T > class BinarySearchTree { public: // EFFECTS: Constructs an empty BST.BinarySearchTree(); // EFFECTS: Constructs a copy of the given tree.BinarySearchTree( constBinarySearchTree &other); // EFFECTS: Replaces the contents of this tree with a copy of the // given tree.BinarySearchTree & operator =(constBinarySearchTree &other); // EFFECTS: Destructs this tree.(continues on next page) 33.1.The BinarySearchTree Interface 239 Programming and Data Structures, Release 0.3 (continued from previous page) ~BinarySearchTree(); // EFFECTS: Returns whether this tree is empty.
boolempty() const; // EFFECTS: Returns the number of elements in this tree. intsize() const; // EFFECTS: Returns whether the given item is contained in this // tree.boolcontains( constT &value) const; // REQUIRES: value is not in this tree // EFFECTS: Inserts the given item into this tree.voidinsert( constT &value); private: // Represents a single node of a tree.struct Node { T datum; Node *left; Node *right; // INVARIANTS: left and right are either null or pointers to // valid Nodes }; // The root node of this tree.Node *root; // INVARIANTS: root is either null or a pointer to a valid Node }; As with a list, we define Nodeas a nested class of BinarySearchTree to encapsulate it within the latter ADT.Since it is an implementation detail and not part of the BST interface, we define Nodeas a private member.Thecontains() member function differs from the one we defined before; the member function just takes in a data item,whileourpreviousdefinitionoperatesonanodeaswell.
Wedefinethelatterasaprivatehelperfunctionandcall it with the root node: template <typename T > class BinarySearchTree { ... public: boolcontains( constT &value) const{ returncontains_impl(root, value); } private: boolcontains_impl( constNode *node, constT &value) { if(!node) { returnfalse; }else if (node->datum == value) { returntrue; }else if (value < node->datum) { (continues on next page) 33.1.The BinarySearchTree Interface 240 Programming and Data Structures, Release 0.3 (continued from previous page) returncontains_impl(node->left, value); }else{ returncontains_impl(node->right, value); } } Node *root; }; Observethat contains_impl() doesnotrefertoa BinarySearchTree oranyofitsmembers.Thus,thereisnoneed forittohavea thispointertoa BinarySearchTree object.Wecandeclarethefunctionasa staticmemberfunction to eliminate the thispointer.template <typename T > class BinarySearchTree { ...
public: boolcontains( constT &value) const{ returncontains_impl(root, value); } private: static bool contains_impl( constNode *node, constT &value) { if(!node) { returnfalse; }else if (node->datum == value) { returntrue; }else if (value < node->datum) { returncontains_impl(node->left, value); }else{ returncontains_impl(node->right, value); } } Node *root; }; Just like a static member variable is associated with a class rather than an individual object, a static member function is also not associated with an individual object, and it cannot refer to non-static member variables. A public static member function can be called from outside the class using the scope-resolution operator, the same syntax for referring to a static member variable: BinarySearchTree< int>::contains_impl( nullptr, -1); // compile error because contains_impl() is not public 33.1.
The BinarySearchTree Interface 241 Programming and Data Structures, Release 0.3 33.2 BST-Based Set Previously, we have seen array-based set implementations, one that used an unsorted array and another a sorted array. We can also implement a set using a binary search tree to store the data: template <typename T > class BSTSet { public: // EFFECTS: Inserts the given value into this set, if it is not // already in the set.voidinsert( constT &value) { if(!elts.contains(value)) { elts.insert(value); } } // EFFECTS: Returns whether value is in this set.boolcontains( constT &value) const{ returnelts.contains(value); } // EFFECTS: Returns the size of this set.intsize() const{ returnelts.size(); } private: BinarySearchTree<T> elts; }; IftheunderlyingBSTis balanced,meaningthateachsubtreewithintheBSThasclosetothesamenumberofelements initsleftandrightchild,thentheheightofthetreeisinO (log𝑛),where 𝑛isthesizeofthetree.
Thus,the contains() andinsert() operations take logarithmic time, rather than the linear time they would take on an unsorted set. Unfortunately,ourBSTimplementationdoesnotguaranteethatitwillbebalanced.Infact,insertingitemsinincreasing order results in a maximally unbalanced tree as in Figure 33.3, resembling a list rather than a tree structure.There are more complicated binary-search-tree implementations that do guarantee balance, but they are beyond the scope of this course.33.2.BST-Based Set 242 Programming and Data Structures, Release 0.3 1 2 3 4 5 … Figure33.3: Insertingelementsintoanon-balancingbinarysearchtreeinorderresultsinalinearstructure,withheight equal to the number of elements.33.2.BST-Based Set 243 CHAPTER THIRTYFOUR MAPS AND PAIRS Amapis a data structure that maps keystovalues.It is thus an associative data structure, since it associates a value with each key.
As an example, we may want to associate exam scores with individual test takers: aliceywu 100 akamil 23 taligoro 100 jjuett 73 We can store these data in a standard-library map: std::map<std::string, int> scores; scores["aliceywu"] = 100; scores["akamil"] = 23; scores["taligoro"] = 100; scores["jjuett"] = 73; cout << scores["akamil"] << endl; // prints 23 cout << scores["aliceywu"] << endl; // prints 100 Themapclass template has two required template parameters, the first for the key type and the second for the value type. We are mapping string IDs to integer scores, so we use a map<string, int> .We can then use the subscript operator with a key to insert a key-value pair into the map, or to look up the value associated with a key.A key feature of the standard-library map is that it is not erroneous to look up a non-existent key.Instead, the map inserts and returns a value-initialized datum for the key.For primitive types, value initialization produces the zero value for the type.
(This is distinct from default initialization, which produces an undefined value.) cout << scores["gmatute"] << endl; // prints 0 Amapissimilartoasetinthatthekeysinthemapareunique;eachkeyisassociatedwithatmostonevalue. However, the values themselves are not unique.The map above has two keys that are associated with the value 100.Giventhesimilaritywithaset,wecanalsoimplementamapusingabinarysearchtree.However,ratherthanusingthe key-valuepairfororderinganduniqueness,weneedtousejustthekey,andthevaluemerelytagsalongfortheride,as shown in Figure 34.1.Tomakethiswork,weneedaheterogeneousdatatypeforthe datummemberofanode,sothatitcanstoreseparatekey and value items.We can define our own struct or class, or we can use the pairtemplate in the standard <utility> library.
std::pair< int,bool> p1; // default constructor value initializes both items p1.first -= 5; // first now has value -5 (continues on next page) 244 Programming and Data Structures, Release 0.3 Node"aliceywu"100datumleftrightNode"akamil"23datum0x0left0x0rightNode"taligoro"100datumleft0x0rightNode"jjuett"73datum0x0left0x0right Figure 34.1: A map represented as a binary search tree. (continued from previous page) p1.second = false; std::pair<string, int> p2 = { "hello", 4 }; // explicit initialization cout << p2.first << ": " << p2.second << endl; // prints hello: 4 Apairstoresafirstandseconditem,whichcanbeofdifferenttypes.The pairtemplateisparameterizedbythetypes of these items.We can use a pair and a BST to implement a map: template <typename Key_type ,typename Value_type > class Map { public: // EFFECTS: Returns whether this map is empty.boolempty() const; // EFFECTS: Returns the number of key-value pairs in this map.
size_tsize() const; // EFFECTS: Returns the value associated with the given key. If // the key is not in the map, inserts the key, // associating it with a value-initialized object of type // Value_type, and returns the newly inserted value.Value_type& operator [](constKey_type& key); (continues on next page) 245 Programming and Data Structures, Release 0.3 (continued from previous page) private: // Type alias for a key-value pair.usingPair_type = std::pair<Key_type, Value_type>; // Comparator that compares pairs by their key components.class PairLess { public: bool operator ()(...) const; }; // Data representation.BinarySearchTree<Pair_type, PairLess> entries; }; Forthistowork,weneeda BinarySearchTree thatcantakeacustomcomparator,tocomparekey-valuepairsbyjust the value component.This comparator can be defaulted to std::less , which compares elements according to the < operator: template <typename T ,typename Compare =std::less<T>> class BinarySearchTree { ...
}; All comparisons within the tree now must use an object of the Compare type. We leave the details as an exercise for the reader.246 Part V Odds and Ends 247 CHAPTER THIRTYFIVE ERROR HANDLING AND EXCEPTIONS Thusfar,wehavelargelyignoredtheproblemofhandlingerrorsinaprogram.WehaveincludedREQUIRESclauses in many of our functions, specifying that the behavior is undefined when the requirements are violated.However, for functionsthatinteractwithdataexternaltotheprogramsuchasuserinput,files,orotherformsofI/O,itisunrealistic to assume that the data will always be available and valid.Instead, we need to specify well-defined behavior for what happens when the requirements for such a function are violated.In writing a complex program, we subdivide it into individual functions for each task.Each function only knows how to handle its own job, and it returns results to its caller.As a result, it generally is not the case that the function that detects an error is equipped to handle it.
Consider the following example: // EFFECTS: Opens the file with the given filename and returns the // contents as a string. string read_file_contents( conststring &filename) { ifstream fin(filename); if(!fin.is_open()) { ???// file did not open; now what?} ...} Thejobof read_file_contents() istoreaddatafromafile.Itdoesn’tknowanythingfurtherabouttheprogram,so itisn’tinapositiontodeterminewhatshouldbedoneincaseofanerror.Dependingontheprogram,therightcourse of action may be to just print an error message and quit, prompt the user for a new filename, ignore the given file and keep going, and so on.Furthermore, the read_file_contents() function may actually be used in several different contexts, each of which requires a different form of error recovery.The only thing that read_file_contents() should be responsible for is detecting and conveying that an error occurred, and a different function further up in the call stack should do what is required to handle the error.
Thus,weneedamechanismthatseparateserrordetectionfromerrorhandling,aswellasameansfornotifyingacaller that an error occurred. We will look at several different strategies for doing so.35.1 Global Error Codes AcommonstrategyintheClanguageistosetthevalueofaglobalvariabletoanerrorcode,whichprovidesinformation aboutthetypeoferrorthatoccurred.Forexample,manyimplementationsofCandC++functionsusethe errnoglobal variabletosignalerrors.
Thefollowingisanexamplethatcallsthe strtod() standard-libraryfunctiontoreadadouble from a C-style string: #include <cerrno> #include <cstdlib> (continues on next page) 248 Programming and Data Structures, Release 0.3 (continued from previous page) #include <iostream> usingstd::cout; usingstd::endl; intmain( intargc, char**argv) { char*end; errno = 0; // reset errno before call doublenumber = std::strtod(argv[1], &end); if(errno == ERANGE) { // check errno after call cout << "range error" << endl; }else{ cout << number << endl; } } When giventhe representationof anumber that isout ofrange of the doubletype,strtod() setserrnotoERANGE: $ ./main.exe 1e1000 range error Thestrategyofsettingaglobalerrorcodecanbe(pardonthepun)error-prone. Forexample, errnomustbesettozero before calling a standard-library function that uses it, and the caller must also remember to check its value after the functioncall returns.
Otherwise,it mayget overwrittenbysome othererror downthe line,masking theoriginal error. 35.2 Object Error States Another strategy used by C++ code is to set an error state on an object.This avoids the negatives of a global variable, since each object has its own error state rather than sharing the same global variable.C++ streams use this strategy: intmain( intargc, char**argv) { std::ifstream input(argv[1]); if(!input) { cout << "error opening file" << endl; } } As with a global variable, the user must remember to check the error state after performing an operation that may set it.35.3 Return Error Codes Return error codes are another strategy used in C and C++ code to signal the occurrence of an error.In this pattern, a value from a function’s return type is reserved to indicate that the function encountered an error.The following is an example of a factorial() function that uses this strategy: // EFFECTS: Computes the factorial of the given number.Returns -1 // if n is negative.
intfactorial( intn) { (continues on next page) 35.2. Object Error States 249 Programming and Data Structures, Release 0.3 (continued from previous page) if(n < 0) { return-1; // error }else if (n == 0) { return1; }else{ returnn * factorial(n - 1); } } Aswithaglobalerrorcodeoranobjectstate,itistheresponsibilityofthecallertocheckthecodetodeterminewhether an error occurred.Furthermore, a return error code only works if there is a value that can be reserved to indicate an error.Forafunction suchas atoi(),which convertsaC-style stringtoan int,there isnosuch value.In fact, atoi() returns 0 for both the string "0"and"hello", and the caller cannot tell whether or not the input was erroneous.35.4 Exceptions All three strategies above have the problem that the caller of a function must remember to check for an error; neither the compiler nor the runtime detect when the caller fails to do so.
Another common issue is that error checking is interleaved with the regular control flow of the caller, as in the following: intmain( intargc, char**argv) { doublenumber = std::stod(argv[1]); string input; cin >> input; if(!input) { cout << "couldn 't read input" << endl; }else if (input == "sqrt") { cout << std::sqrt(number) << endl; }else if (input == "log") { cout << std::log(number) << endl; } ... } The control flow for the error case is mixed in with that of non-error cases, making the code less readable and harder tomaintain.Furthermore,thecodeabovefailstocheckforerrorsin sqrt()orlog(),whichisnotimmediatelyclear due to the interleaving of control flow.What we want is a mechanism for error handling that: •Separates error detection from error handling, providing a general means for signaling that an error occurred.•Separates the control flow for error handling from that of non-erroneous cases.
•Detects when an error is not handled, which by default should cause the program to exit with a meaningful message. The mechanism provided by C++ and other modern languages is exceptions .The following is an example of code that uses exceptions: // Represents an exception in computing a factorial.class FactorialError {}; (continues on next page) 35.4.Exceptions 250 Programming and Data Structures, Release 0.3 (continued from previous page) // EFFECTS: Computes the factorial of the given number.Throws a // FactorialError if n is negative.intfactorial( intn) { if(n < 0) { // error case throwFactorialError(); // throw an exception } if(n == 0) { // non-error case return1; }else{ returnn * factorial(n - 1); } } intmain( intargc, char**argv) { try{ intn = std::stoi(argv[1]); intresult = factorial(n); cout << n << "!
= " << result << endl; }catch(conststd::invalid_argument &error) { cout << "Error converting " << argv[1] << " to an int: " << error.what() << endl; }catch(constFactorialError &error) { cout << "Error: cannot compute factorial on negative number" << endl; } } The individual components of the exception mechanism used above are: •TheFactorialError class is an exception type, and objects of that type are used to signal an error. •When the factorial() function detects an error, it throwsan exception object using the throwkeyword.In the example above, the function throws a default-constructed FactorialError .The standard-library stoi() function throws a std::invalid_argument object when given a string that does not represent an integer.•The compiler arranges for the exception to propagate outward until it is handled by a try/catch block.In the example above, the first catch block is executed when a std::invalid_argument is thrown, while the second is run when a FactorialError is thrown.
When an exception is thrown, execution pauses and can only resume at a catch block . The code that is between the throw and the catch that handles the exception is entirely skipped.This is a good thing; if the rest of the code in factorial() weretorun,thefunctionwouldtrytocomputethefactorialofanegativenumber,whichwouldrecurse indefinitely (or at least until either the program runs out of stack space, or nreaches the most negative int, at which point the subtraction n - 1would produce undefined behavior).The result of running this program on different inputs is as follows: $ ./main.exe 3 3!= 6 $ ./main.exe -1 Error: cannot compute factorial on negative number $ ./main.exe hello Error converting hello to an int: stoi: no conversion Theerrormessageinthelastexample,specificallythepartreturnedby error.what() ,isimplementation-dependent.35.4.Exceptions 251 Programming and Data Structures, Release 0.3 35.4.1 Exception Objects C++allowsanobjectofanytypetobethrownasanexception.
However,aproperexceptioncarriesinformationabout what caused the error, and using exceptions of different types allows a program to distinguish between different kinds of errors. More specifically, the example above illustrates that a program can perform different actions in response to each exception type.There are several exceptions defined by the standard library, such as invalid_argument orout_of_range .The standard-library exceptions all derive from std::exception , and it is common for user-defined exceptions to do so as well: class EmailError :publicstd::exception { public: EmailError( conststring &msg_in) : msg(msg_in) {} const char * what() const override { returnmsg.c_str(); } private: string msg; }; A user-defined exception is a class type, so it can carry any information necessary to pass between the function that detects an error and the one that handles it.
For EmailError above, the constructor takes a string and stores it as a member variable, allowing any message to be specified when creating an EmailError object: throwEmailError("Error sending email to: " + address); Thewhat()member function is a virtual function defined by std::exception , andEmailError overrides it to return the message passed to the constructor. We can call it when catching an exception to obtain the message: try{ ...}catch(constEmailError &error) { cout << error.what() << endl; } Exceptiontypesareoftendefinedinaninheritancehierarchy,withaderivedclassrepresentingamorespecifickindof error.Deriving from std::exception is an example of this, but we can also define exception types that derive from EmailError : class InvalidAddressError :publicEmailError { ...}; class SendFailedError :publicEmailError { ...}; We will shortly see how exception hierarchies interact with try/catch blocks.35.4.
Exceptions 252 Programming and Data Structures, Release 0.3 35.4.2 Try/Catch Blocks A try/catch block consists of a try block followed by one or more catch blocks: try{ intn = std::stoi(argv[1]); intresult = factorial(n); cout << n << "! = " << result << endl; }catch(conststd::invalid_argument &error) { cout << "Error converting " << argv[1] << " to an int: " << error.what() << endl; }catch(constFactorialError &error) { cout << "Error: cannot compute factorial on negative number" << endl; } The try/catch can only handle exceptions that occur within the try part of the block, including in functions called by codeinthetry.Whenathrownexceptionpropagatestoatryblock,thecompilerchecksthecorrespondingcatchblocks in order to see if any of them can handle an exception of the type thrown.Execution is immediately transferred to the first applicable catch block: •The catch parameter is initialized from the exception object.Declaring the parameter as a reference to const avoids making a copy.
•The body of the catch block is run. •Assumingthecatchblockcompletesnormally,executionproceedspasttheentiretry/catch.Theremainingcode in the try or in the other catch blocks is skipped.Inmatchinganexceptionobjecttoacatchblock,C++takesintoaccountsubtypepolymorphism–ifthedynamictype oftheobjectisderivedfromthetypeofacatchparameter,thecatchisablehandlethatobject,sotheprogramusesthat catch block for the exception.The following is an example: voidgrade_submissions() { vector<string> students = load_roster(); for(conststring &name : students) { try{ autosub = load_submission(name); doubleresult = grade(sub); email_student(name, result); }catch(constFileError &error) { cout << "Can 't grade: " << name << endl; }catch(constEmailError &error) { cout << "Error emailing: " << name << endl; } } } The first catch block above handles objects of any type derived from FileError , while the second handles objects of any type derived from EmailError .
C++ also has a “catch-all” that can handle any exception type: try{ // some code here }catch(...) { (continues on next page) 35.4. Exceptions 253 Programming and Data Structures, Release 0.3 (continued from previous page) cout << "Caught an unknown error" << endl; } The...as a catch parameter enables the catch block to handle any type of object.However, this should in general be avoided–instead,aparticulartry/catchshouldonlycatchthespecifickindsoferrorsthatitisabletorecoverfrom.For instance, consider the following implementation of the load_roster() function: vector<string> load_roster() { try{ csvstream csvin("280roster.csv"); // may throw an exception // Use the stream to load the roster...}catch(constcsvstream_exception &e) { cout << e.what() << endl; // return ???} } The code uses the csvstream library to read a spreadsheet in CSV format.The library may throw a csvstream_exception object when opening the file, such as if the file doesn’t exist.
However, the load_roster() functionisnotthebestplacetohandlethisexception;asdiscussedpreviously,theappropriateerrorrecoverydependson theapplication,anditisthecallerof load_roster() thatknowswhattodoincaseofanerror. Thus, load_roster() should avoid catching the exception, letting it propagate to its caller.35.4.3 Exception Propagation Whenanexceptionisthrown,ifthecurrentfunctionisnotwithinatryblock,theexceptionpropagatestothefunction’s caller.Similarly, if the current function is within a try block but there is no associated catch block that can handle an object of the exception’s type, the exception also propagates to the caller.Tohandleanexception,theprogramimmediatelypausesexecution,thenlooksforanexceptionhandlerasfollows.The process starts at the statement that throws the exception: •Determine if the current statement is within the try part of a try/catch block in the current function.If not, the function call is terminated, and the process repeats in the caller.
•Iftheexecutioniswithinatry,examinethecatchblocksinordertofindthefirstonethatcanhandleanexception of the given type. If no matching catch is found, the function call is terminated, and the process repeats in the caller.•If a matching catch block is found, the catch parameter is initialized with the exception object, and the body of the catch immediately runs.Assuming it completes successfully, execution proceeds past the entire try/catch.Asdescribedabove,ifthecodeisnotwithinatryblockthatcanhandletheexceptionobject,executionreturnsimme- diatelytothecaller,andtheprogramlooksforahandlerthere.Theexceptionpropagatesoutwarduntilaviablehandler is found.If the exception proceeds outward past main(), the default behavior is to terminate the program.This ensures that either the exception is handled, or the program crashes, informing the user that an error occurred.35.4.
Exceptions 254 Programming and Data Structures, Release 0.3 35.4.4 Exception Examples The following is a DriveThru class that keeps track of menu items and their prices: class InvalidOrderException :publicstd::exception {}; class DriveThru { public: // EFFECTS: Adds the given item to the menu. voidadd_item( conststring &item, doubleprice) { menu[item] = price; } // EFFECTS: Returns the price for the given item.If the item // doesn 't exist, throws an InvalidOrderException.doubleget_price( conststring &item) const{ autoit = menu.find(item); if(it != menu.end()) { returnit->second; } throwInvalidOrderException(); } private: // A map from item names to corresponding prices map<string, double> menu; }; Theget_price() member function looks up the price of an item, returning it if it is on the menu.If not, it throws an exception of type InvalidOrderException .We use the find()member function of mapto avoid inserting a value-initialized price into the map when an item does not exist.
The following is a program that reads order items from standard input, computing the total price: intmain() { DriveThru eats280; ... // add items to eats280 doubletotal = 0; string item; while(cin >> item && item != "done") { try{ total += eats280.get_price(item); }catch(constInvalidOrderException &e) { cout << "Sorry, we don 't have: " << item << endl; } } cout << "Your total cost is: " << total << endl; } Theprogramignoresitemsthataren’tonthemenu,printingamessageindicatingthatitisnotavailable.Insuchacase, get_price() throws an InvalidOrderException .Since the throw statement is not within a try in get_price() , theexceptionpropagatesoutwardto main().Thecallto get_price() iswithinatry,andthereisanassociatedcatch thatmatchesthetypeoftheexception.Executionproceedstothatcatch,whichprintsanerrormessage.Thenexecution continues after the full try/catch, ending an iteration of the loop and reading in a new item to start the next iteration 35.4.
Exceptions 255 Programming and Data Structures, Release 0.3 As another example, we write a subset of a program that loads and grades student submissions for an assignment. We use the following classes: // An exception signifying an error when reading a file.class FileError : std::exception { ...}; // An exception signifying an error when sending an email.class EmailError : std::exception { ...}; // A student submission.class Submission { ...public: // EFFECTS: Grades this submission and returns the result.doublegrade(); }; FileError andEmailError are exceptions that the program will use.We saw the definition of EmailError previ- ously, and FileError is similarly defined.A Submission object represents a student submission, and we elide the definition here.The following functions perform individual tasks in the grading program: // EFFECTS: Emails the given student the given grade.Throws // EmailError if sending the email fails.
voidemail_student( conststring &name, doublegrade); // EFFECTS: Loads the roster from 280roster.csv. Throws // csvstream_exception if the file cannot be read.vector<string> load_roster() { csvstream csvin("280roster.csv"); // may throw an exception vector<string> roster; // Use the stream to load the roster...returnroster; } // EFFECTS: Loads the submission for the given student.Throws // FileError if the submission cannot be loaded.Submission load_submission( conststring &name) { std::ifstream input(name); if(!input) { throwFileError(); } returnSubmission(input); } All three functions throw exceptions when they are unable to perform their task.The email_student() func- 35.4.Exceptions 256 Programming and Data Structures, Release 0.3 tion throws an EmailError if sending fails.
The load_roster() function throws a csvstream_exception if reading the roster file fails; in actuality, the exception will be thrown by the csvstream constructor, but since load_roster() allows the exception to propagate outward, it documents that such an exception may be thrown. Fi- nally,load_submissions() throws aFileError if a submission file fails to open.The function that directs the grading process is as follows: // EFFECTS: Loads and grades all submissions, sending email to each // student with their result.Throws csvstream_exception // if the roster cannot be loaded.
voidgrade_submissions() { vector<string> students = load_roster(); for(conststring &name : students) { try{ autosub = load_submission(name); doubleresult = sub.grade(); email_student(name, result); }catch(constFileError &e) { cout << "Can 't grade: " << s << endl; }catch(constEmailError &e) { cout << e.what() << endl; } } } This function handles FileError andEmailError exceptions by just printing a message to standard out. The try/catch is within the for loop so that failure for one student does not prevent grading of other students.If a csvstream_exception is thrown by load_roster() , it gets propagated to the caller of grade_submissions() .Lastly, we have the main()function: intmain() { try{ grade_submissions(); cout << "Grading done!" << endl; }catch(constcsvstream_exception &e) { cout << "Grading failed!
<< endl; cout << e.what() << endl; returnEXIT_FAILURE; } } This function handles a csvstream_exception by printing a message to standard out and then returning with a nonzero exit code, indicating a failure. Weconsiderafewmoresmallexamplestobetterunderstandhowexceptionsarepropagatedandhandled.Theexamples use the following exception types: class GoodbyeError {}; class HelloError {}; class Error { public: Error( conststring &s) : msg(s) {} (continues on next page) 35.4.Exceptions 257 Programming and Data Structures, Release 0.3 (continued from previous page) conststring & get_msg() { returnmsg; } private: string msg; }; Objects of GoodbyeError will generally be thrown by a goodbye() function, while HelloError objects will be thrown by hello().
The first example is as follows: voidgoodbye() { cout << "goodbye called" << endl; throwGoodbyeError(); cout << "goodbye returns" << endl; } voidhello() { cout << "hello called" << endl; goodbye(); cout << "hello returns" << endl; } intmain() { try{ hello(); cout << "done" << endl; }catch(constHelloError &he) { cout << "caught hello" << endl; }catch(constGoodbyeError &ge) { cout << "caught goodbye" << endl; } cout << "main returns" << endl; } Inthisexample, hello() iscalledfromwithinatryin main(). Soifanexceptionisthrownandpropagatesto main(), the associated catch blocks will attempt to handle the exception.Within hello(), the message hello called is printed, followed by a call to goodbye() .The latter prints out goodbye called and then throws a GoodbyeError object.Execution immediately pauses, and the program checks if it is within a try in goodbye() .It is not, so it then checksthecallertoseeifitiscurrentlyinatrythere.Thereisn’tonein hello(),sotheprogramthenchecksforatry inmain().
The execution state is indeed within a try in main(), so the program checks the catch blocks, in order, to seeifthere isonethatcanhandlea GoodbyeError . Thesecondcatchcando so,anditscodeis run,printing caught goodbye.Execution then proceeds past the try/catch, so the print of main returns executes.Observe that the remaining code in goodbye() ,hello(), and the try block in main()were skipped when handling the exception.The full output is as follows: hello called goodbye called caught goodbye main returns 35.4.
Exceptions 258 Programming and Data Structures, Release 0.3 Consider another example: voidgoodbye() { cout << "goodbye called" << endl; throwGoodbyeError(); cout << "goodbye returns" << endl; } voidhello() { cout << "hello called" << endl; try{ goodbye(); }catch(constGoodbyeError &ge) { throwHelloError(); }catch(constHelloError &he) { cout << "caught hello" << endl; } cout << "hello returns" << endl; } intmain() { try{ hello(); cout << "done" << endl; }catch(constHelloError &he) { cout << "caught hello" << endl; }catch(constGoodbyeError &ge) { cout << "caught goodbye" << endl; } cout << "main returns" << endl; } This is the same as the first example, except now the call to goodbye() is within a try in hello(). When the GoodbyeError objectisthrown,theprogramdeterminesthatitisnotwithinatryin goodbye() ,soitcheckswhether itisinatryin hello().Itis,sotheprogramcheckswhetherthereisacatchblockthatcanhandlea GoodbyeError .Thefirstcatchblockcandoso,soitscodeisrun.
Thisthrowsa HelloError ,sotheprogramcheckswhetherexecution is within a try in hello(). It is not – execution is within a catch block, not within a try.So the program proceeds to thecaller,checkingwhetherexecutionisinatryin main().Thecallto hello() isindeedwithinatry,sotheprogram examines the catch blocks.The first one handles a HelloError , so its body is executed, printing caught hello .Then execution proceeds past the try/catch to the print of main returns .Observethatatry/catchcanonlyhandleexceptionsthatarethrownwithinthetryblock;itdoesnotdealwithexceptions that are thrown from one of its catch blocks, so an outer try/catch must handle such exceptions instead.hello called goodbye called caught hello main returns The following example uses the Errorclass defined above, which has a constructor that takes a string: voidgoodbye() { cout << "goodbye called" << endl; throwError("bye"); (continues on next page) 35.4.
Exceptions 259 Programming and Data Structures, Release 0.3 (continued from previous page) cout << "goodbye returns" << endl; } voidhello() { cout << "hello called" << endl; try{ goodbye(); }catch(constError &e) { throwError("hey"); } cout << "hello returns" << endl; } intmain() { try{ hello(); cout << "done" << endl; }catch(constError &e) { cout << e.get_msg() << endl; }catch(...) { cout << "unknown error" << endl; } cout << "main returns" << endl; } The throw statement in goodbye() throws an Errorobject constructed with the string "bye". There is no try in goodbye() ,sotheprogramcheckswhetheritiscurrentlywithinatryin hello().Executionisindeedwithinthetry there, and the catch block can handle the Errorobject.The catch block throws a different Errorobject, initialized with the string "hey".As with the previous example, this throw statement is not within a try in hello(), so the programchecksforatryin main().
Bothcatchblockscanhandlethe Errorobject;thesecondisacatch-allthatcan handleanyexception. However,theprogramconsidersthecatchblocksinorder,soitisthefirstonethatruns.Itsbody retrieves the message from the Errorobject, printing out hey.Then execution proceeds past the try/catch.The full output is below: hello called goodbye called hey main returns One more example is the following: voidgoodbye() { cout << "goodbye called" << endl; throwGoodbyeError(); cout << "goodbye returns" << endl; } voidhello() { cout << "hello called" << endl; try{ goodbye(); }catch(constError &e) { (continues on next page) 35.4.
Exceptions 260 Programming and Data Structures, Release 0.3 (continued from previous page) throwError("hey"); } cout << "hello returns" << endl; } intmain() { try{ hello(); cout << "done" << endl; }catch(constError &e) { cout << e.get_msg(); cout << endl; }catch(...) { cout << "unknown error" << endl; } cout << "main returns" << endl; } Here,thegoodbye() functionthrowsa GoodbyeError ,andthethrowisnotwithinatryin goodbye() ,sotheprogram looks for a try in hello(). Execution is within a try there, so the program examines the catch blocks to see whether one can handle a GoodbyeError .The lone catch block cannot, so the program propagates the exception to the caller andlooksforatryin main().Thecodeiswithinatryin main(),sotheprogramexaminesthecatchblocksinorder.Thefirstcannothandlea GoodbyeError ,butthesecondcan,sothelatterrunsandprints unknown error .Execution continues after the try/catch, printing main returns .
The full result is the following: hello called goodbye called unknown error main returns 35.5 Error Handling vs. Undefined Behavior The error-detection mechanisms we discussed provide well-defined behavior in case of an error.As such, a function that uses one of these mechanisms should document it, describing when and what kind of error can be generated: // EFFECTS: Computes the factorial of the given number.Returns 0 if // n is negative.intfactorial( intn); // EFFECTS: Emails the given student the given grade.Throws // EmailError if sending the email fails.voidemail_student( conststring &name, doublegrade); ThesefunctionsdonothaveREQUIRESclausesthatrestricttheinput;violatingaREQUIRESclauseresultsinunde- fined behavior, whereas these function produce well-defined behavior for erroneous input.Ontheotherhand,whencodedoesproduceundefinedbehavior,itcannotbedetectedthroughanyoftheerror-handling mechanismsabove.
Forexample,dereferencinganulloruninitializedpointerdoesnotnecessarilythrowanexception, set a global error code, or provide any other form of error detection. It is the programmer’s responsibility to avoid undefinedbehavior,andtherearenoconstraintsonwhataC++implementationcandoifaprogramresultsinundefined behavior.35.5.Error Handling vs.Undefined Behavior 261 Part VI Supplemental Material 262 CHAPTER THIRTYSIX INTRODUCTION TO C++ This courses uses C++ as the language in which we explore fundamental concepts in programming.Here, we provide a basic overview of C++ for students who are familiar with other languages such as Python or Java.36.1 A Simple Program Let’s start with a simple program that prints Hello world!to the screen: #include <iostream> intmain() { std::cout << "Hello world!" << std::endl; return0; } TheentrypointofaC++programisthe main()function,whichisatop-level(global)functionthathasasignatureof theformint main() orint main(int argc, char *argv[]) .
Afunctionsignature consistsofareturntype,the nameofthefunction,andalistofparameters. The parameters arewhatthefunctiontakesasinput,andthe returntype is the kind of value that the function returns.For main(), it can either have no parameters, or it can have parameters that allow it to take command-line arguments , which are specified when the program is run.For simplicity, we start with amain()that does not have parameters.Following the signature of the function, we have the function body , which is the code that gets executed when the function is called.The body itself is comprised of statements , which are executed in order from top to bottom.In our program above, the body of main()has two statements: one that prints to the screen, and a second that exits the function with a return value of 0.Examining the first statement more closely, we see that it is composed of expressions and operators.An expression is a fragment of code that evaluates to some value.
The simplest expressions are literals, which hardcode a specific value in the program. For instance, "Hello world!" is a string literal that denotes the sequence of characters H, e, and so on.A nameis also an expression, and what it evaluates to depends on what the name is bound to in the environmentinwhichthenameisevaluated.Intheprogramabove, std::cout isboundtoanobjectrepresentingthe standard output stream (stdout) , which allows printing to the console(also referred to as shellorterminal) in which the program is run.Similarly, std::endl is bound to an object that causes a newline to be printed when inserted to an output stream.Finally, these expressions are connected via the binary <<operator; in this context, we refer to this as thestream-insertion operator .The code is inserting the string "Hello world!" into the standard output stream, followed by inserting std::endl to obtain a newline.Bothstd::cout andstd::endl aredefinedinthe iostream libraryheader .
Thefirstlineoftheprogram( #include <iostream> ) instructs the C++ compiler to includethe contents of the iostream library header, which makes std::cout andstd::endl available for us to use. 263 Programming and Data Structures, Release 0.3 A name such as std::cout is called a qualified name – it consists of the stdqualifier, followed by the ::scope- resolution operator , followed by the coutname.The stdqualifier refers to the stdnamespace , which is a scope in whichmoststandard-libraryentitiesaredefined.Thus,thequalifiedname std::cout referstothe coutthatisdefined within the stdnamespace, as opposed to some other coutthat might be defined in a different scope.Often, we place a directive in our program to be able to use an entity such as coutwithout qualifying it with std::.
The following does so for both coutandendl: usingstd::cout; // we can now use cout without qualification usingstd::endl; // we can now use endl without qualification The following does so for every entity defined in the stdnamespace: using namespace std ;// we can now use anything in std without qualification Use this with caution, however – there are lots of names defined in the stdnamespace, so this makes it much more likely for our names to conflict with those from the standard library. (In particular, a using namespace directive should never be used in a header file.) The last statement in our program is return 0; .This returns the value 0 from the main()function, which conven- tionally indicates that the program completed successfully.We would use a nonzero value instead to indicate an error if something went wrong.Inthespecificcaseofreturningfrom main(),areturnstatementisactuallyoptional.
(Thisisnotthecaseforreturning fromotherfunctions,unlesstheyhavea voidreturntype.) Ifwedon’thaveareturnstatementin main(),thecompiler implicitly adds a return 0; for us. Thus, the program above could be written equivalently as: #include <iostream> usingstd::cout; // we can now use cout without qualification usingstd::endl; // we can now use endl without qualification intmain() { cout << "Hello world!" << endl; }// implicit return 0; added by the compiler Nowthatwehaveexaminedallthepiecesofoursimpleprogram,let’scompileandrunitinashell.Assumingthecode is in the file hello.cpp , we can compile and run it as follows: $ g++ -std=c++17 -o hello.exe hello.cpp $ ./hello.exe Hello world!Here, we use the $symbol to denote the shell prompt , which is displayed by the shell to indicate that it is waiting for ourcommands.(Onmostmachines,thepromptismorecomplicated,butwesimplifyittojustadollarsign.) Wethen typethecompilationcommand g++ -std=c++17 -o hello.exe hello.cpp ,whichinvokesthe g++compiler.
The -std=c++17 tells the compiler to use the C++17 version of the language. The -o hello.exe tells the compiler to usehello.exe as the name of the resulting executable file.Finally, hello.cpp is the filename of our C++ program.Whenthecompilerhasfinished,wetype ./hello.exe toruntheresultingexecutable,andweseethemessage Hello world!printed to the screen.Inthiscourse,weencourageusingboththeshellaswellasan integrateddevelopmentenvironment(IDE) .Refertothis tutorial for how to set up and become familiar with using a shell and IDE on your machine.36.1.A Simple Program 264 Programming and Data Structures, Release 0.3 36.2 Static Typing We sawabove that thesignature of the main()function includesthe return type,which is intin thecase of main().ThereasonthereturntypeisincludedisthatC++isa staticallytypedlanguage ,meaningthateveryvalue’stypemust beknownatcompiletime.Todoso,thecompilergenerallyrequiresustospecifythetypeofavariable,aswellasthe parameter types and return type of a function.
For instance, the following introduces a local variable xwith type int and initial value 3: intx = 3; The syntax for defining a variable begins with the type of the variable, followed by the name, followed by an optional initialization. (Ifnoinitializationisprovided,thevariableundergoes defaultinitialization .Forprimitivetypessuchas int, that means the initial value of the variable is undefined.) The inttype is aprimitive type , which is a category consisting of the simplest types provided by a language.
Common primitive types in C++ include: •int: signed (positive, negative, or zero) integer values in some finite range, typically [−231,231−1] = [−2147483648 ,2147483647] on most machines •std::size_t : unsigned (positive or zero only) integer values in some finite range, typically [0,264−1] •double:double-precision floating-point values, typically using a 64-bit representation •bool: a boolean value, either true or false •char: a character value, generally representing at least the 128 values in the ASCII standard •void: used as the return type of a function to indicate that it does not return a value As another example, let’s define a square() function that computes the square of a number. We’ll write it to take a doublevalue as input and return a doublevalue as the result: doublesquare( doublex) { doubleresult = x * x; returnresult; } As withmain(), the signature for square() starts with the return type, which is double.
Then we have the name of thefunction,followedbytheparameterlist. Wetakeinasingle doublevalueasinput,sowehaveasingleparameter, which we are calling x.In the body of the function, we define a new variable resultthat is initialized with the value ofx * x, and we then return the value of the variable.Since we only use the variable once, we can simplify our function by eliminating it and using the expression x * x directly where we need it: doublesquare( doublex) { returnx * x; } Since an expression evaluates to a value, it has a type corresponding to that value.In the case of x * x, its type is doublesinceitistheproductoftwo doublevalues.Thus,thereturnstatementreturnsa doublevalue,matchingthe declared return type of the function.We can now invoke square() as follows: #include <iostream> doublesquare( doublex) { returnx * x; (continues on next page) 36.2.
Static Typing 265 Programming and Data Structures, Release 0.3 (continued from previous page) } intmain() { std::cout << square(3.14) << std::endl; doublex = square(4); std::cout << square(x) << std::endl; } Thesquare() functionmustbedeclaredabovewhereweuseitin main()–inC++,thescopeofaglobalfunctionor variableisfromthepointofitsdeclarationuntiltheendofthefile. (The scopeofanentityistheregionofcodewhere it may be used.) We can then invoke the function in main().Observe that in the definition doublex = square(4); weinvoke square() ontheliteral 4,whichactuallyhastype intratherthanthedeclared doubletypeoftheparameter of thesquare() function.In most cases, C++ automatically converts between intanddouble, so that we can use a value of one of these types where the other is expected.On the other hand, a call such as square(std::cout) as erroneous,sincethereisnoconversionbetweenthetypeof std::cout (whichhappenstobe std::ostream )andthe requireddoubletype.
36.3 Compound Data Inadditiontoprimitivetypes,C++hasdatatypesthatrepresentmorecomplexobjects. Forinstance,the std::ostream type(definedinthe iostream header)representsanoutputstream,anditisthetypeof std::cout .Thestd::string type is another common data type that represents string objects, and it is defined in the stringheader: #include <iostream> #include <string> intmain() { std::string s = "Hello world!"; std::cout << s << std::endl; } Often,wewanttokeeptrackofacollectionofobjectsofthesametype,suchasanarbitrarynumberofintegervalues.Wecanusea std::vector todoso,whichisanexampleofa templatethatisparameterizedbysomeothertype.For instance,std::vector<int> is a collection of intvalues, while std::vector<std::string> is a collection of std::string values.
The following demonstrates how to use a vector: #include <iostream> #include <vector> intmain() { std::vector< int> scores = { 84, 91, 77, 95, 83 }; for(std:: size_ti = 0; i < scores.size(); ++i) { std::cout << "Score " << i << " = " << scores[i] << std::endl; } } 36.3. Compound Data 266 Programming and Data Structures, Release 0.3 In this code, we define a scoresvariable of type std::vector<int> , and we provide an initial set of values as a comma-separated list enclosed by curly braces.We then iterate over the indices of the vector, which start at 0 and end at one less than the size of the vector, which we obtain via the expression scores.size() .We access an element of the vector using square brackets, with the vector object on the left-hand side and the index between the brackets (scores[i] ).Using this syntax, we have to be careful not to go past the end of the vector, which would result in undefined behavior , meaning that anything could happen – e.g.
crashing the program, overwriting some other piece of data, stealing your files, or even nothing at all. Alternatively, we can do scores.at(i) , which checks whether the index is in range and guarantees an error if it is not – the program crashes, but we get some useful information, and it definitely won’t steal our files.We can also add elements to a vector after it has been created: scores.push_back(42); This appends the element 42 at the end of the vector.Similarly, the expression scores.pop_back() removes the element at the end of the scoresvector (assuming there is at least one element in the vector; otherwise we get the dreaded undefined behavior).Vectors are useful for ordered collections of data that all have the same type.However, sometimes we want to keep trackofmultiplepiecesofdatathathaveindividualmeanings,andthatmightevenhavedifferenttypes.
Forinstance,a complex number has a real part and an imaginary part; while both might be represented as doubles, we want to keep trackofwhichpartiswhichthroughanameratherthanmaintaininganorderingbetweenthem. A struct1givesusthis abilitytointroduceacompoundobject,comprisedofmultiplepieceseachwithindividualnames.Thefollowingisan example of defining a new Complex type: struct Complex { doublereal; doubleimaginary; }; Westartwiththe structkeyword,followedbythenameofthetypewearedefining,followedbyanopencurlybrace.We then specify the components of the struct, using syntax similar to variable declarations.These components are calledmember variables in C++2.The struct definition is terminated by a closing curly brace and a semicolon.
Once we have this definition, we can write a function to print out a Complex value: voidComplex_print(Complex number) { std::cout << number.real; if(number.imaginary >= 0) { std::cout << '+'; } std::cout << number.imaginary << std::endl; } Asshownabove,wecanaccessamembervariableusingthedotoperator. Theexpression number.real accessesthe realcomponent of the numberobject, and number.imaginary refers to the imaginary component.The function prints the +character to separate the two components if the imaginary part is nonnegative – otherwise, the imaginary part would have a minus sign, so we wouldn’t want a +between the two components.We can create objects of Complex type and print them as follows: Complex c1 = { 3.14, -1.7 }; Complex c2; c2.real = 2.72; (continues on next page) 1Inotherlanguagestheterm classisusedinstead.InC++,the structandclasskeywordsarecloselyrelated,andwewill seethedetailslater .2Other languages uses the terms fieldsorattributes to refer to these components.36.3.
Compound Data 267 Programming and Data Structures, Release 0.3 (continued from previous page) c2.imaginary = -4; Complex_print(c1); Complex_print(c2); As the code demonstrates, we can use curly braces to initialize a Complex variable, which initializes the components in order:c1.real gets initialized to 3.14, andc1.imaginary gets initialized to -1.7. Alternatively, we can rely on default initialization as is the case for c2.However, this ends up initializing the two components to undefined values, so we need to replace their values before we can proceed to use them.As another example, we define a struct to keep track of a person’s exam score.
We need to keep track of the person’s name, as well as the score value itself: struct Grade { std::string name; intscore; }; We can now use the Gradetype as follows: Grade g1 = { "Sofia", 99 }; Grade g2; g2.name = "Amir"; g2.score = 23; std::cout << g1.name << " earned a " << g1.score << std::endl; std::cout << g2.name << " earned a " << g2.score << std::endl; 36.4 Value Semantics Oneofthedistinguishingfeaturesofaprogramminglanguageistherelationshipbetweenvariablesand objects,which are pieces of data in memory. In some languages, a variable is directly associated with an object, so that using the variable always accesses the same object (as long as the variable is in scope).We say that the language has value semantics if this is the case.In other languages, a variable is an indirect reference to an object, and the variable may be modified to refer to a different object.This scheme is known as reference semantics .
C++hasvaluesemantics,unlikeotherlanguagessuchasJava3orPythonthatprimarilyhavereferencesemantics. We can illustrate the difference between these semantic choices using the Complex type we defined previously.Consider the following code: #include <iostream> struct Complex { doublereal; doubleimaginary; }; voidComplex_print(Complex number) { std::cout << number.real; if(number.imaginary >= 0) { std::cout << '+'; } (continues on next page) 3Java actually has value semantics for primitive types and reference semantics for class types.36.4.Value Semantics 268 Programming and Data Structures, Release 0.3 (continued from previous page) std::cout << number.imaginary << std::endl; } intmain() { Complex c1 = { 3.14, -1.7 }; Complex c2 = c1; c2.real = 2.72; Complex_print(c1); Complex_print(c2); } In this code, we define a variable c1of typeComplex and give it an initial value.We then copy it to a c2variable.
If we modify c2, the change does not affect c1, since the two variables each have their own object with which they are associated. In memory, this looks something like the picture in Figure 36.1.mainc1Complex3.14real-1.7imaginaryc2Complex2.72real-1.7imaginary Figure 36.1: Two variables corresponding to separate Complex objects in memory.Compiling and running the program produces: $ g++ -std=c++17 -o complex.exe complex.cpp $ ./complex.exe 3.14-1.7 2.72-1.7 We see that as expected, the modification to c2does not affect c1.Compare this to a similar Python program: class Complex : def__init__(self, real, imaginary): self.real = real self.imaginary = imaginary defComplex_print(number): print(number.real, end= '') ifnumber.imaginary >= 0: print( '+', end= '') print(number.imaginary) (continues on next page) 36.4.
Value Semantics 269 Programming and Data Structures, Release 0.3 (continued from previous page) c1 = Complex(3.14, -1.7) c2 = c1 c2.real = 2.72 Complex_print(c1) Complex_print(c2) In memory, the variables look like the diagram in Figure 36.2. globalsc1c2Complex2.72real-1.7imaginary Figure 36.2: Two variables indirectly referring to the same Complex object.Running the program produces the following: $ python3 complex.py 2.72-1.7 2.72-1.7 This confirms that c1andc2refer to the same object, since the modification to c2.real also affected c1.We can also observe C++’s value semantics when we call a function.Suppose we want a function that modifies a Complex objecttobeitsconjugate,flippingthesignoftheimaginarycomponentofthecomplexnumber.
Thefollowing is an attempt to write this function: voidComplex_conjugate(Complex number) { number.imaginary = -number.imaginary; } Suppose we insert the following statement prior to the print statements in our program above: Complex_conjugate(c1); Compiling and running the code, we get: $ g++ -std=c++17 -o complex.exe complex.cpp $ ./complex.exe 3.14-1.7 2.72-1.7 Nothing changes! This is because the numberparameter of the Complex_conjugate() function is its own ob- ject, and it receives a copy of c1‘s value.The diagram in Figure 36.3 illustrates this in memory at the end of the Complex_conjugate() call.The copy within the Complex_conjugate() function does have its imaginary component modified, but not the object within the main()function.This behavior is called pass by value , since the value of c1(theargument of the function call) is copied into the numberparameter object.36.4.
Value Semantics 270 Programming and Data Structures, Release 0.3 mainc1Complex3.14real-1.7imaginaryc2Complex2.72real-1.7imaginaryComplex_conjugatenumberComplex3.14real1.7imaginary Figure 36.3: A function that received a copy of an argument object. C++ also supports another mechanism for passing arguments: pass by reference .In this scheme, the parameter is an aliasof the object passed in as an argument rather than being its own object.We specify that a parameter should use pass by reference by placing the ampersand ( &) symbol to the left of the parameter name: voidComplex_conjugate(Complex &number) { number.imaginary = -number.imaginary; } Compiling and running the code with this modified definition, gives us: $ g++ -std=c++17 -o complex.exe complex.cpp $ ./complex.exe 3.14+1.7 2.72-1.7 We see that c1has indeed been conjugated.The memory diagram in Figure 36.4 depicts what the code looks like in memoryattheendofthecallto Complex_conjugate() .
Inthefigure,wedenoteanaliaswithadashedline,andwe do not include a box next to the numbername to reflect the fact that it is not associated with a new object. 36.4.Value Semantics 271 Programming and Data Structures, Release 0.3 Complex_conjugatenumbermainc1Complex3.14real-1.7imaginaryc2Complex2.72real-1.7imaginary Figure 36.4: A function that received an alias to an existing argument object.36.5 Example: Stickman Having seen the basics of C++, let us proceed to write a larger C++ program that implements a stickman game (also calledhangman),whichinvolvesguessingthelettersinawordorphrase.First,let’ssketchouthowwewantthegame to run.If the puzzle is the word hello, an unsuccessful game may play out like the following: $ ./stickman.exe hello _ _ _ _ _ Enter a lowercase letter to guess: a o _ _ _ _ _ Enter a lowercase letter to guess: b o | _ _ _ _ _ Enter a lowercase letter to guess: c (continues on next page) 36.5.
Example: Stickman 272 Programming and Data Structures, Release 0.3 (continued from previous page) o /| _ _ _ _ _ Enter a lowercase letter to guess: d o /|\ _ _ _ _ _ Enter a lowercase letter to guess: e o /|\ _ e _ _ _ Enter a lowercase letter to guess: f o /|\ / _ e _ _ _ Enter a lowercase letter to guess: g o /|\ / \ _ e _ _ _ Better luck next time! We want to print out underscores corresponding to the letters in the puzzle, with a space between each of them.We prompt the player for a guess, reading from the standard input stream corresponding to input from the console.If the playerguessesaletterthatisnotinthepuzzle,werevealaportionofastickfigure.Iftheplayerguessesaletterthatis inthepuzzle,werevealalloccurrencesofthatletteranddonotaddtothestickfigure.Iftheplayerguessesincorrectly six times, the full stick figure is revealed, and the player loses.
The following is a successful run of the game (loosely following the frequency distribution of English letters): $ ./stickman.exe hello _ _ _ _ _ Enter a lowercase letter to guess: e (continues on next page) 36.5. Example: Stickman 273 Programming and Data Structures, Release 0.3 (continued from previous page) _ e _ _ _ Enter a lowercase letter to guess: t o _ e _ _ _ Enter a lowercase letter to guess: s o | _ e _ _ _ Enter a lowercase letter to guess: a o /| _ e _ _ _ Enter a lowercase letter to guess: i o /|\ _ e _ _ _ Enter a lowercase letter to guess: o o /|\ _ e _ _ o Enter a lowercase letter to guess: h o /|\ h e _ _ o Enter a lowercase letter to guess: r o /|\ / h e _ _ o Enter a lowercase letter to guess: (continues on next page) 36.5.Example: Stickman 274 Programming and Data Structures, Release 0.3 (continued from previous page) l o /|\ / h e l l o Congratulations!
36.5.1 Program Constants Now that we have a general sense of how the program should behave, we can go ahead and start on our design for its structure. First, let’s define some constants corresponding to the stick figure.The full figure is as follows: o /|\ / \ This spans three lines.Unfortunately, a string literal in C++ cannot directly include a newline (line break) character.However, we can use the escape sequence \nto tell the compiler we want a newline character.For instance, the following prints Helloon one line, followed by world!on the next line4: std::cout << "Hello \nworld!" << std::endl; EscapesequencesingeneralstartwithabackslashinC++.Ifweactuallywantabackslashcharacteritself,ittooneeds to be escaped: \\.
Thus, the stick figure can be represented with the following string: " o\n/|\\\n/\\" Thestringstartswithaspacetocentertheheadofthestickfigure,thenthenewlineescapesequence \ntoendtheline, thentherightarmandtorso,followedbythe \\escapesequenceforabackslashtorepresenttheleftarm,followedby another\nnewline, then the right leg, a space, and finally the escaped left leg. Wecannowworkourwaybackwardstoobtainpartiallyrevealedstickfigures.Therearetwothingsweneedtoensure so that the figures line up in the output: •Each figure has exactly two newline characters.•Each figure has exactly three characters on the third line.We can use a std::vector<std::string> to store the figures in order: conststd::vector<std::string> STICK_FIGURES = { "\n\n", " o\n\n", " o\n|\n", " o\n/|\n", " o\n/|\\\n", " o\n/|\\\n/ ", " o\n/|\\\n/\\" }; 4Notethatstd::endl isnotthesameasthenewlinecharacter.
Ithastheeffectofprintingthenewlinecharactertothetargetstream,butitalso flushesthestream,whichimmediatelytransferstheinserteddataintotheunderlyingoutput. Intheabsenceofaflush,thestreamisallowedtobuffer the data in memory, which generally allows for better performance than writing characters immediately.36.5.Example: Stickman 275 Programming and Data Structures, Release 0.3 We prefix the type with the constqualifier to denote that this is a constant, and the compiler will prevent us from modifying it.By convention, we name the constant using all capital letters, with underscores between words.We’ll also use a constant for the maximum number of wrong guesses: const int MAX_MISSES = 6; 36.5.2 The GameStruct Next, we consider what data we need to represent the state of a game.We have to keep track of both the answer to the puzzle, as well as what pieces have been guessed by the player and what pieces remain.We also need to track the number of missed guesses.
We will additionally keep a count of the number of letters remaining – this isn’t strictly necessary, as we can recompute it when we need it, but it will make our job easier to keep track of it separately. Before we define a struct, we also need to determine what underlying data types are appropriate to represent each member variable.The counts can be represented by the inttype, and the answer by the std::string type.We can alsorepresentwhattheplayerhasandhasn’tguessedwitha std::string –lettersthathavenotbeenguessedwillbe replaced with an underscore, while those that have been revealed will have the same values as in the answer.We can now define the struct: // A struct to represent the state of a game of stickman.struct Game { // The number of wrong guesses made so far.intmiss_count; // The number of remaining unguessed positions in the puzzle.intremaining_letters; // The current state of the puzzle, with underscores representing // unguessed letters.
std::string puzzle; // The answer to the puzzle. std::string answer; }; Here, we have documented each component with a comment above it that describes its purpose.36.5.3 Task Decomposition Let’snowthinkaboutthefunctionsweneedinourprogram.Weshouldbreakdowneachdiscretetaskintheprogram toitsownfunction,sothateachfunctionhasasmalljob,andsowecantesteachpieceindividually.Thefollowingare some tasks that our program needs to do: •Constructa Gameobjectfroma std::string answer,withtheappropriateinitialvaluesforeachmembervari- able.•Print the a Gameobject, showing the player the current state of the game.•Obtain a letter guess from the player, checking whether or not the guess is a valid letter.•Update the Gamebased on a guessed letter.•Perform the top-level game loop until the game ends.36.5.Example: Stickman 276 Programming and Data Structures, Release 0.3 Let’swritefunctionsignaturescorrespondingtoeachofthesetasks.
Wewillwritethemintheformofa declaration5, which excludes the body of a function, replacing it with a semicolon. •The function that constructs a Gametakes astd::string as an argument and returns a Game: Game make_game(std::string answer); •The function that prints a Gametakes aGameobject and does not return anything.voidprint_game(Game game); We actually don’t need a copy of the Gameobject, so we can specify pass by reference instead to obtain an alias to the existing object: voidprint_game(Game &game); •The function that obtains a guess from the player doesn’t take any arguments, and it returns a character value: charget_guess(); •The function that updates the game must take the Gameobject via pass by reference, so that we don’t get a copy of theGame.
It also takes in the guessed letter: voidupdate_game(Game &game, charguess); •The top-level function takes the answer as a string and does not return anything: voidplay_game(std::string answer); 36.5.4 Implementation We can now proceed to implement these functions, starting with make_game() . The function needs to define a Game object and set its member variables: Game game = { 0, 0, answer, answer }; We’ve initialized the puzzlemember variable to be a copy of the answerparameter to start, but we need to replace each letter with an underscore.Let’s assume that we only hide lowercase letters, and that other characters are shown to the player without needing to be guessed.This allows our puzzle to contain spaces and other punctuation.
We can write a separate function to determine whether or not a character is a lowercase letter: boolis_lowercase( charvalue) { returnvalue >= 'a'&& value <= 'z'; } This logic takes advantage of the fact that in the ASCII standard (and most other character standards), the lowercase letters are adjacent and in order. Thus, a lowercase letter must be both greater than or equal to the character 'a'and no more than the character 'z'.We can now loop over the puzzlemember variable, replacing each lowercase character with an underscore: 5Technically, a definition is also a declaration.A declaration that is not also a definition is more precisely called an incomplete orforward declaration.36.5.Example: Stickman 277 Programming and Data Structures, Release 0.3 for(std:: size_ti = 0; i < game.puzzle.size(); ++i) { if(is_lowercase(game.puzzle[i])) { game.puzzle[i] = '_'; ++game.remaining_letters; } } Iterating over a string works the same way as iterating over a vector.
We use a forloop from 0 up to the size of the string,andweusesquarebracketstoindexintothestringtoobtainthecharacteratthatposition. Unlikeinsomeother languages,C++stringsare mutable,meaningthattheycanbemodified,andwedosoherebyreplacingeachlowercase letter with an underscore character.We also increment the number of remaining letters each time we encounter a lowercase letter.Putting this all together, the following defines our make_game() function: Game make_game(std::string answer) { Game game = { 0, 0, answer, answer }; for(std:: size_ti = 0; i < game.puzzle.size(); ++i) { if(is_lowercase(game.puzzle[i])) { game.puzzle[i] = '_'; ++game.remaining_letters; } } returngame; } To print a game, we print out the stick figure corresponding to the current number of incorrect guesses: std::cout << STICK_FIGURES[game.miss_count] << " "; Weaddabitofspacebetweenthefigureandthepuzzle.
Wethenprintouteachofthecharactersinthepuzzle,separated by spaces: for(std:: size_ti = 0; i < game.puzzle.size(); ++i) { std::cout << " " << game.puzzle[i]; } In addition, we add extra newlines to visually separate the turns from each other. The full function definition is as follows: voidprint_game(Game &game) { std::cout << endl; std::cout << STICK_FIGURES[game.miss_count] << " "; for(std:: size_ti = 0; i < game.puzzle.size(); ++i) { std::cout << " " << game.puzzle[i]; } std::cout << " \n" << endl; } Next, we implement the get_guess() function to obtain a guess from the player.At a high level, this function needs to do the following: •Obtain a string from the standard input stream.•Check whether the string is a valid guess – it must be a single letter, and the letter must be lowercase.36.5.Example: Stickman 278 Programming and Data Structures, Release 0.3 •If the guess is invalid, repeat the process.•If the guess is valid, return the guessed letter.
There’s one more case we need to handle – what happens if we reach the end of the stream, when no more input is available? (On most systems, a user can manually end the standard input stream with the Ctrl-d keyboard input.
We will also see later that input can be redirected from a file , in which case the input stream ends when it reaches the end of the file.) In such a case, we will return immediately with an error value that is different from any valid guess: const char ERROR_CHAR = '\0'; // special "null" character The following is a definition of get_guess() : charget_guess() { std::cout << "Enter a lowercase letter to guess:" << std::endl; std::string input; while(std::cin >> input) { if(input.size() != 1) { cout << "Error: guess must be exactly one letter" << std::endl; }else if (!is_lowercase(input[0])) { cout << "Error: guess must be between a and z" << std::endl; }else{ returninput[0]; } } returnERROR_CHAR; } Thestd::cin object represents the standard input stream, similar to how std::cout is the standard output stream. Weextractfrom an input stream using the >>operator, which is called the stream-extraction operator in this context.
To extract a string, we use a std::string object as the right-hand side of the operator. It is common practice to perform this extraction in the condition of a loop.If the extraction succeeds, the condition has a true value, and the body of the loop runs.If the extraction fails (e.g.in the case of the end of the stream), the loop condition is false, and the loop exits.In this function, we return ERROR_CHAR when the extraction fails.The function starts by prompting the player to enter a guess.It then reads input in a loop, checking whether or not the inputisavalidguess.Iftheguessisinvalid,amessagedescribingtheproblemisprinted,andtheloopmovesontothe next iteration, reading another input.If the guess is valid, the lone character in the input string is returned.We now go ahead and implement the update_game() function.The function needs to iterate over the characters in theanswertocheckifanyarethesameastheguess.Ifso,weadditionallyneedtocheckwhethertheletterhasalready been guessed.
If it has not been guessed, the corresponding position in the puzzlestring has an underscore. In this case, we replace the underscore with the actual letter and decrement the count of remaining letters: for(std:: size_ti = 0; i < game.answer.size(); ++i) { if(game.answer[i] == guess && game.puzzle[i] == '_') { game.puzzle[i] = guess; // replace the _ with the actual letter --game.remaining_letters; } } The function also needs to update the miss_count member variable depending on whether the guess was a correct one or not.We can’t know this until we have traversed the entire puzzle, and we use a separate boolean to track this.The full function definition below demonstrates this logic: 36.5.
Example: Stickman 279 Programming and Data Structures, Release 0.3 voidupdate_game(Game &game, charguess) { boolcorrect_guess = false; for(std:: size_ti = 0; i < game.answer.size(); ++i) { if(game.answer[i] == guess && game.puzzle[i] == '_') { game.puzzle[i] = guess; // replace the _ with the actual letter --game.remaining_letters; correct_guess = true; } } if(!correct_guess) { ++game.miss_count; } } Lastly, we can write the top-level function that plays a game. It starts by creating a Gameobject via make_game() .It then has a loop that: •Prints the game using print_game() .•Obtains a guess from the player via get_guess() .IfERROR_CHAR is returned, the game immediately exits.•Updates the game using update_game() .Otherthanthe ERROR_CHAR condition,thegameterminateseitherwhenalllettershavebeenguessed,ortheplayerhas made the maximum number of incorrect guesses.
Thus, the following is the main loop: while(game.remaining_letters > 0 && game.miss_count < MAX_MISSES) { print_game(game); charletter = get_guess(); if(letter == ERROR_CHAR) { cout << "Quitting." << endl; return;// quit the game } update_game(game, letter); } After the game is over, we print the game once more to show its final state. We then print a message to the player depending on whether or not they won, as shown in the full function definition below: voidplay_game(std::string answer) { Game game = make_game(answer); while(game.remaining_letters > 0 && game.miss_count < MAX_MISSES) { print_game(game); charletter = get_guess(); if(letter == ERROR_CHAR) { std::cout << "Quitting." << std::endl; return;// quit the game } update_game(game, letter); } print_game(game); if(game.remaining_letters == 0) { std::cout << "Congratulations!" << std::endl; }else{ std::cout << "Better luck next time!" << std::endl; (continues on next page) 36.5.
Example: Stickman 280 Programming and Data Structures, Release 0.3 (continued from previous page) } } 36.5.5 Testing and File Organization Beforewewritea main()functionthatplaysthegame,wemightwanttowritesomecodethattestsindividualfunctions in our program. For example, the following code does a basic test of the make_game() function: #include <cassert> #include <string> voidtest_make_game() { std::string answer = "hello world!"; Game game = make_game(answer); assert(game.miss_count == 0); assert(game.remaining_letters == 10); assert(game.puzzle == "_____ _____!"); assert(game.answer == answer); } intmain() { test_make_game(); } Thetest_make_game() functioncreatesa Gameobjectfromthe "hello world!" answerstring.Itthenassertsthat each of the member variables of the Gameobject has the expected value.The assert() construct is defined in the cassert library header, which we have included at the top.
Observe that the test code has its own main()function, so it needs to be in a separate .cppsource file than the main()functionthatactuallyplaysagameofstickman. Let’sassumethatthefunctiondefinitionsaboveareplacedin stickman.cpp ,andourtestcodeisin test.cpp .Thecompilerwillprocessthesetwofilesindividually,evenifthey arebothprovidedinasinglecompilationcommand.Howcanwemakethecompilerawareofthefunctionsdefinedin stickman.cpp when it is compiling test.cpp ?The compiler actually only needs access to the declarations of the functions we use, not the definitions.It does need accesstothedefinitionofthe Gamestruct,sinceitneedstoknowwhatmembervariablesthestructhas.Thus,common practiceistoplacestructdefinitions,functiondeclarations,andconstantsinaseparate headerfile,conventionallywith a file extension such as .hpp.The following code can be placed in stickman.hpp : #include <string> #include <vector> // Stick figures corresponding to each possible number of misses.
conststd::vector<std::string> STICK_FIGURES = { "\n\n", " o\n\n", " o\n|\n", " o\n/|\n", " o\n/|\\\n", " o\n/|\\\n/ ", " o\n/|\\\n/\\" }; (continues on next page) 36.5. Example: Stickman 281 Programming and Data Structures, Release 0.3 (continued from previous page) // Maximum number of missed guesses.const int MAX_MISSES = 6; // Used to indicate an error when reading user input.const char ERROR_CHAR = '\0'; // special "null" character // A struct to represent the state of a game of stickman.struct Game { // The number of wrong guesses made so far.intmiss_count; // The number of remaining unguessed positions in the puzzle.intremaining_letters; // The current state of the puzzle, with underscores representing // unguessed letters.std::string puzzle; // The answer to the puzzle.std::string answer; }; // EFFECTS: Returns a properly initialized Game object corresponding // to the given answer phrase.
Game make_game(std::string answer); // REQUIRES: game.miss_count <= MAX_MISSES // MODIFIES: cout // EFFECTS: Prints the state of the game to standard output. voidprint_game(Game &game); // MODIFIES: cout, cin // EFFECTS: Repeatedly prompts the user for a guess consisting of a // single lowercase letter until a valid guess is provided, // or the end of stream is reached.Returns the guess in // the first case, or ERROR_CHAR in the second.charget_guess(); // MODIFIES: game // EFFECTS: Updates the game 's puzzle and miss count according to // whether the guess is a letter in the answer and has not // been previously guessed.voidupdate_game(Game &game, charguess); // MODIFIES: cout, cin // EFFECTS: Plays a game of stickman with the given answer, reading // guesses from standard in and writing game details to // standard out.
The game ends if the end of standard input // is reached, the player exhausts the maximum number of // incorrect guesses, or the player correctly guesses all // letters. (continues on next page) 36.5.Example: Stickman 282 Programming and Data Structures, Release 0.3 (continued from previous page) voidplay_game(std::string answer); Westartbyincludingthe stringandvectorstandardlibraries,sincethecodein stickman.hpp usesbothstringsand vectors.We then have our constant definitions, followed by the definition of the Gamestruct.Lastly, we have function definitions for each task in the game.We have included documentation in the form of RMEs(requires,modifies, and effects): •Therequiresclause specifies what is required to be true prior to calling the function.These are also called preconditions .All bets are off if these conditions are violated: we get the dreaded undefined behavior.
The function’s implementation is allowed to assume that these conditions are met – it is not required to check them in any way. •Themodifiesclause lists the objects outside the function that might modified by a call to the function.We generally include coutif the standard output stream is written to, and cinif input is read from the standard input stream.Pass-by-reference parameters are included if their contents might be modified.•Theeffectsclausetellsuswhatthefunctionactuallydoes,i.e.whatthereturnvaluemeansandhowanyobjects in themodifiesclause are actually modified.The effects are sometimes also called postconditions .This clause only specifies the “what”, not the “how”; we will come back to this later .Nowthatwehavethiscodein stickman.hpp ,wecanincludeitinboth test.cpp andstickman.cpp .
Thecontents oftest.cpp are as follows: #include <cassert> #include "stickman.hpp" voidtest_make_game() { std::string answer = "hello world!"; Game game = make_game(answer); assert(game.miss_count == 0); assert(game.remaining_letters == 10); assert(game.puzzle == "_____ _____!"); assert(game.answer == answer); } intmain() { test_make_game(); } The#include "stickman.hpp" directivepullsinthecodefrom stickman.hpp intothecurrentfile. Weusequotes around the filename rather than the angle brackets we use with a library header.Observe that we no longer need the #include <string> directive, since stickman.hpp already contains that.The full contents of stickman.cpp are as follows: #include <iostream> #include "stickman.hpp" usingstd::cin; usingstd::cout; usingstd::endl; usingstd:: size_t; usingstd::string; static bool is_lowercase( charvalue) { (continues on next page) 36.5.
Example: Stickman 283 Programming and Data Structures, Release 0.3 (continued from previous page) returnvalue >= 'a'&& value <= 'z'; } Game make_game(string answer) { Game game = { 0, 0, answer, answer }; for(size_ti = 0; i < game.puzzle.size(); ++i) { if(is_lowercase(game.puzzle[i])) { game.puzzle[i] = '_'; ++game.remaining_letters; } } returngame; } voidprint_game(Game &game) { cout << endl; cout << STICK_FIGURES[game.miss_count] << " "; for(size_ti = 0; i < game.puzzle.size(); ++i) { cout << " " << game.puzzle[i]; } cout << " \n" << endl; } charget_guess() { cout << "Enter a lowercase letter to guess:" << endl; string input; while(cin >> input) { if(input.size() != 1) { cout << "Error: guess must be exactly one letter" << endl; }else if (!is_lowercase(input[0])) { cout << "Error: guest must be between a and z" << endl; }else{ returninput[0]; } } returnERROR_CHAR; } voidupdate_game(Game &game, charguess) { boolcorrect_guess = false; for(size_ti = 0; i < game.answer.size(); ++i) { if(game.answer[i] == guess && game.puzzle[i] == '_') { game.puzzle[i] = guess; // replace the _ with the actual letter --game.remaining_letters; correct_guess = true; } } if(!correct_guess) { ++game.miss_count; } } (continues on next page) 36.5.
Example: Stickman 284 Programming and Data Structures, Release 0.3 (continued from previous page) voidplay_game(string answer) { Game game = make_game(answer); while(game.remaining_letters > 0 && game.miss_count < MAX_MISSES) { print_game(game); charletter = get_guess(); if(letter == ERROR_CHAR) { cout << "Quitting." << endl; return;// quit the game } update_game(game, letter); } print_game(game); if(game.remaining_letters == 0) { cout << "Congratulations!" << endl; }else{ cout << "Better luck next time!" << endl; } } Weinclude iostream ,sincethatisnotincludedby stickman.hpp . Wedon’thavestructorconstantdefinitions,since those are defined in the stickman.hpp header.Instead, we just have the definitions for each function.We made a few minor changes from before: •Weadded usingdirectivessothatwecanusespecificstandard-libraryentitieswithoutthe std::qualification.•Weprecededthedefinitionof is_lowercase() withthestatickeyword.
Thisiscommonpracticeforahelper function, and it prevents the function from conflicting with a function of the same name defined in some other source file. We can now compile and run the test code.We provide both .cppsource files to the compilation command, but not the.hppfile – its contents are pulled directly into the .cppfiles via the #include "stickman.hpp" directive: $ g++ -std=c++17 -o test.exe test.cpp stickman.cpp $ ./test.exe The assertions all succeed, so we don’t see any output.Lastly, we can write a separate play.cpp file that has a main()function to play the game.The following are the contents of the file: #include <iostream> #include "stickman.hpp" intmain( intargc, char*argv[]) { if(argc < 2) { std::cout << "Usage: " << argv[0] << " <answer> " << std::endl; return1; } play_game(argv[1]); } We use an alternate signature for main()that gives us access to the command-line arguments given to the program.The first argument is always the name of the program executable.
We take the game answer as the second argument, so we start by checking whether there are at least two arguments. If not, we print an error message and return with a nonzero value.If an answer is provided, we invoke the top-level play_game() function with the answer.36.5.Example: Stickman 285 Programming and Data Structures, Release 0.3 We compile and run the program as follows: $ g++ -std=c++17 -o play.exe play.cpp stickman.cpp $ ./play.exe world!_ _ _ _ _ !Enter a lowercase letter to guess: e o _ _ _ _ _ !Enter a lowercase letter to guess: t o | _ _ _ _ _ !Enter a lowercase letter to guess: s o /| _ _ _ _ _ !Enter a lowercase letter to guess: o o /| _ o _ _ _ !Enter a lowercase letter to guess: r o /| _ o r _ _ !Enter a lowercase letter to guess: a o /|\ _ o r _ _ !Enter a lowercase letter to guess: l (continues on next page) 36.5.Example: Stickman 286 Programming and Data Structures, Release 0.3 (continued from previous page) o /|\ _ o r l _ !
Enter a lowercase letter to guess: d o /|\ _ o r l d ! Enter a lowercase letter to guess: w o /|\ w o r l d !Congratulations!36.5.Example: Stickman 287 CHAPTER THIRTYSEVEN SOLVING PROBLEMS WITH RECURSION To conclude our discussion of recursion, we take a look at several complex problems and how to approach them from a recursive standpoint.Our strategy will be to: •Identify the cases we can solve directly.These are base cases.•Determine how to express a general case in terms of smaller subproblems.This is the recursive case.For the latter, the first step is to identify appropriate subproblems, and the second is to figure out how to express the solutionforthewholeproblemintermsofthesolutionstothesubproblems.Thisleadstoarecurrencerelation,which we can then implement in code.37.1 Pancake Sort Suppose you want to sort a stack of irregular pancakes such that they are in order, with the smallest at the top and the largestatthebottom.
Soasnottocontaminatethepancakes,youwouldliketodosojustbyrepeatedlyflippingasubset ofthepancakeswithaspatula,whichreversesthesetofpancakesabovethespatula,asshowninFigure37.1. Thegoal is to come up with a generalized algorithm for sorting the pancakes just by flipping substacks from any point in the stack to the top.StartGoalAllowed Move Figure37.1: Thepancakeproblemistosortastackofpancakes,wheretheonlyallowedmoveistoflipasubsetofthe stack from a point in the middle to the top.Westartbyidentifyingcaseswecansolvedirectly.Anemptystackoronewithjustasinglepancakearetriviallysorted, so these are the base cases.We then need to identify a subproblem.For a stack of 𝑛pancakes, a natural subproblem is to sort a stack of 𝑛−1 pancakes.
So we now have to figure out how to reduce the problem of sorting 𝑛pancakes to that of sorting 𝑛−1 288 Programming and Data Structures, Release 0.3 pancakes – we just need the largest pancake on the bottom, and then the substack above that has 𝑛−1pancakes that need sorting. Thefinalstepistocomeupwithawayofgettingthelargestpancaketothebottom.Weknowthatifthatpancakeisat thetop,wecanflipthewholestacktogetittothebottom.Sonowtheproblemishowtogetthelargestpancaketothe top.Placing the spatula under that pancake and flipping the stack above does the trick.Thus, we have identified our recurrence: •Nothing need be done for a stack of zero or one.•For𝑛pancakes where 𝑛 >1, we place the spatula under the largest pancake and flip, moving it to the top.We then flip the whole stack, moving the largest pancake to the bottom.We then repeat the process on the 𝑛−1 pancakes above the largest.Figure 37.2 illustrates this recurrence.
smaller stack Figure 37.2: The pancake-sort algorithm flips the largest pancake to the top, then the whole stack, then recurses on a smaller stack. We can implement this algorithm in code to sort an array of integers, considering the top of the stack to be at the beginningofthearrayandthebottomattheend.Wemakeuseofthe reverse() functionwewrotepreviously toflip a subset of the stack.voidpancake_sort( int*stack, intsize) { if(size > 1) { // find position of largest element int*largest = std::max_element(stack, stack + size); // flip the stack from the top to the largest element reverse(stack, largest); // flip the whole stack reverse(stack, stack + size - 1); // recurse on a smaller stack pancake_sort(stack, size - 1); } } Here, we use std::max_element() from the<algorithm> library to find the largest item in the stack.37.1.
Pancake Sort 289 Programming and Data Structures, Release 0.3 37.2 Tower of Hanoi TheTowerofHanoipuzzleconsistsofthreerodswith 𝑛disksofvaryingsizearrangedinsortedorderonthefirstrod, asshowninFigure37.3. Theobjectiveistomovetheentirestackofdiskstoanotherrod,whileobeyingthefollowing constraints: •Only one disk can be moved at a time.•Only the top disk at a rod can be moved.•A larger disk may never be placed on top of a smaller one.Figure 37.3: The Tower of Hanoi problem moves a stack of disks from an initial rod to a target rod.Tocomeupwithanalgorithmtosolvethispuzzle,wefirstidentifythebasecasesthatcanbesolveddirectly.For 𝑛= 1, the lone disk can be moved directly without violating the constraints, constituting our base case.For𝑛 > 1, the subproblem is moving 𝑛−1disks between rods.Then our task is to determine how to express the solutionformoving 𝑛disksintermsofthesolutiontomoving 𝑛−1disks.
Weobservethatwecancompletelyignore the largest disk when moving the 𝑛−1smaller disks; since any of the latter can be placed on the largest disk, the rod with the largest disk acts just like an empty rod. Thus, we can move the 𝑛−1smaller disks as a stack of their own, from the start rod to the middle rod.We can then move the largest disk directly to the empty target rod.Then all that is left is to move the stack of 𝑛−1smaller disks to the target rod.Figure37.4illustratesthisalgorithm.Wetaketherecursiveleapoffaith,assumingthatwecanmovethesmaller 𝑛−1 stack as a whole using recursion, without worrying about the details of how it is done.As long as the subproblem is closer to the base case than the original problem, we get to make the assumption that the subproblem will be solved correctly.smaller stack Figure37.4: AnalgorithmfortheTowerofHanoiistouserecursiontomoveasmallerstackandmovethelargestdisk on its own.
Thefollowingcodeimplementsthealgorithm,printingoutthemovesrequiredtomove 𝑛disksfromastarttoendrod: // MODIFIES: cout // EFFECTS: Prints a move of disk n from start to end. voidmove( intn,intstart, intend) { std::cout << "Move disk " << n << " from rod " << start << " to rod " << end << std::endl; (continues on next page) 37.2.Tower of Hanoi 290 Programming and Data Structures, Release 0.3 (continued from previous page) } // REQUIRES: n >= 1 // MODIFIES: cout // EFFECTS: Prints the sequence of moves required to move n disks // from start to end, using temp as the temporary rod.
voidhanoi( intn,intstart, inttemp, intend) { if(n == 1) { move(n, start, end); }else{ hanoi(n - 1, start, end, temp); move(n, start, end); hanoi(n - 1, temp, start, end); } } The result of hanoi(5, 1, 2, 3) is as follows: Move disk 1 from rod 1 to rod 3 Move disk 2 from rod 1 to rod 2 Move disk 1 from rod 3 to rod 2 Move disk 3 from rod 1 to rod 3 Move disk 1 from rod 2 to rod 1 Move disk 2 from rod 2 to rod 3 Move disk 1 from rod 1 to rod 3 Move disk 4 from rod 1 to rod 2 Move disk 1 from rod 3 to rod 2 Move disk 2 from rod 3 to rod 1 Move disk 1 from rod 2 to rod 1 Move disk 3 from rod 3 to rod 2 Move disk 1 from rod 1 to rod 3 Move disk 2 from rod 1 to rod 2 Move disk 1 from rod 3 to rod 2 Move disk 5 from rod 1 to rod 3 Move disk 1 from rod 2 to rod 1 Move disk 2 from rod 2 to rod 3 Move disk 1 from rod 1 to rod 3 Move disk 3 from rod 2 to rod 1 Move disk 1 from rod 3 to rod 2 Move disk 2 from rod 3 to rod 1 Move disk 1 from rod 2 to rod 1 Move disk 4 from rod 2 to rod 3 Move disk 1 from rod 1 to rod 3 Move disk 2 from rod 1 to rod 2 Move disk 1 from rod 3 to rod 2 Move disk 3 from rod 1 to rod 3 Move disk 1 from rod 2 to rod 1 Move disk 2 from rod 2 to rod 3 Move disk 1 from rod 1 to rod 3 37.2.
Tower of Hanoi 291 Programming and Data Structures, Release 0.3 37.3 Counting Change As a final example, let us consider the number of ways we can change a dollar into coins, using any quantity of half dollars (50 ¢), quarters (25 ¢), dimes (10 ¢), nickels (5 ¢), and pennies (1 ¢). The following are three possible ways: •$1 = 1 half dollar, 1 quarter, 2 dimes, 1 nickel •$1 = 2 quarters, 2 dimes, 30 pennies •$1 = 100 pennies There are too many ways to enumerate them all manually.Instead, let’s take a look at a smaller example of the same problem: the number of ways to make change for 11 ¢using dimes, nickels, and pennies.There are exactly four: •11¢= 1 dime, 1 penny •11¢= 2 nickels, 1 penny •11¢= 1 nickel, 6 pennies •11¢= 11 pennies We can categorize these solutions according to which coins they use, as shown in Figure 37.5.
101111111111115111111551Use a dimeNodimesUse a nickelNo nicklesMake 1¢ using 1, 5, 10Make 6¢ using 1, 5 Figure 37.5: The ways to count change can be subdivided into those that use a particular coin and those that don’t. If we decide to use a particular coin, we are left with the subproblem of making a smaller amount of change using the same set of coins.For example, if we choose to use a dime, we need only make 1 ¢using dimes, nickels, and pennies.On the other hand, if we choose not to use a particular coin, we must make the full amount of change with a smaller set ofcoins.In our example,if we decidenot to usea dime, wemust make the full11 ¢with onlynickels and pennies.If we then use a nickel, we are left with making 6 ¢with only nickels and pennies.Figure37.6illustratesadecisiontreeforhowtomakechange.Atanypointintime,wehaveatargetamountandasetof availablecoins.Wethendecidewhethertousethelargestofouravailablecoins.
Eitherdecisionleadstoasubproblem: •Making a smaller amount of change with the same set of available coins. •Making the same amount of change with a smaller set of available coins.Thus, we have a recurrence that expresses the solution for a full problem in terms of two subproblems.We also need to identify base cases that we can solve directly: •If the change amount is zero, there is only one way to do that: use no coins.•If the change amount is negative, there is no way to do that, since we do not have negative coins.37.3.
Counting Change 292 Programming and Data Structures, Release 0.3 Amount: 11 ¢Coins: 1, 5, 101 ¢1, 5, 10Use 10-9 ¢1, 5, 10Use 10-4 ¢1, 5Use 56 ¢1, 5Use 51 ¢1, 5Use 5-4 ¢1, 5Use 50 ¢1Use 10 ¢1Use 10 ¢1Use 10 ¢1Use 110 ¢1Use 111 ¢1, 5No 101 ¢1, 5No 101 ¢1No 56 ¢1No 511 ¢1No 5 1 ¢1No 51 ¢NoneNo 11 ¢NoneNo 111 ¢NoneNo 16 ¢NoneNo 1 ✔ ✔ ✔ ✔10 ¢NoneNo 1Make 1¢ using 1, 5, 10Make 11¢ using 1, 5 Figure 37.6: The decision tree for which coin to use consists of a subtree that uses a particular coin and another that doesn’t. 37.3.Counting Change 293 Programming and Data Structures, Release 0.3 •If the change amount is positive but we have no coins available, we cannot make that change.The following implements the resulting algorithm in code: // EFFECTS: Returns the number of ways to make amount in change // using only the coin denominations in kinds.
intcount_change( intamount, const int kinds[], intnum_kinds) { if(amount == 0) { // one way to make nothing: use no coins return1; }else if (amount < 0 || num_kinds < 1) { // cannot make negative amount, or anything with no coins return0; }else{ return // use the largest coin, reducing the amount of change to make count_change(amount - kinds[num_kinds - 1], kinds, num_kinds) + // don 't use the largest coin, reducing the available coins count_change(amount, kinds, num_kinds - 1); } } This tree-recursive implementation is very inefficient, repeating the same computations many times. Techniques such asmemoization anddynamicprogramming candrasticallyimprovetheefficiency,buttheyarebeyondthescopeofthis course.(With such a technique in place, the result is 292 for the number of ways to make change for a dollar.) 37.3.
Counting Change 294 CHAPTER THIRTYEIGHT CONTAINERS OF POINTERS Recall the linked-list class template we defined previously: template <typename T > class List { public: List(); voidempty() const; T & front(); voidpush_front( constT &datum); voidpop_front(); voidpush_back( constT &datum); voidpop_back(); ... private: struct Node { T datum; Node *prev; Node *next; }; Node *first; Node *last; }; We declared the parameters of push_front() andpush_back() to be passed by reference, avoiding making a copy of the argument value.However, a Nodestores a value of type T, so a copy is made when a node is created: template <typename T > voidList<T>::push_back( constT &datum) { Node *node = newNode{ datum, last, nullptr }; ...
} 295 Programming and Data Structures, Release 0.3 With this in mind, consider the following example that inserts local objects into a list: intmain() { Llama paul("Paul"); Llama carl("Carl"); List<Llama> todo; todo.push_back(paul); todo.push_back(carl); for(auto&llama : todo) { llama.feed(); } } The code creates two local Llamaobjects and inserts them into a list. It then iterates over the list to feed each llama.However,asshowninFigure38.1,thellamasinthelistarecopiesofthelocalobjects,sofeedingthemdoesnotaffect the original llamas, which go hungry.List<Llama>::NodenextStackpaulLlama"Paul"name 0x0nextmain llamacarlLlama"Carl"nametruehungrydatumLlama"Paul"namefalsehungryList<Llama>::NodedatumLlama"Carl"namefalsehungrytodoList<Llama>lastfirsttruehungry Figure 38.1: Inserting objects into a container creates copies of those objects.
We can use indirection to avoid making a copy, storing pointers to llamas in a list rather than llamas themselves: intmain() { Llama paul("Paul"); Llama carl("Carl"); List<Llama *> todo; todo.push_back(&paul); todo.push_back(&carl); for(autolptr : todo) { lptr->feed(); (continues on next page) 296 Programming and Data Structures, Release 0.3 (continued from previous page) } } Thecodeiteratesoverthelistbyvalueratherthanbyreference;however,thevaluesarepointers,sotheystillindirectly refer to the appropriate Llamaobjects when they are copied. Figure 38.2 illustrates the result in memory.Our llamas are properly fed and no longer go hungry.List<Llama *>::NodenextdatumList<Llama *>::Node0x0nextdatum StackpaulLlama"Paul"namemain lptrcarlLlama"Carl"namefalsehungrytodoList<Llama *>lastfirstfalsehungry Figure 38.2: Storing pointers in a container.By storing pointers in a container, we avoid making copies of the underlying objects.
Containers of pointers are also useful for keeping track of multiple orderings of the same objects. For instance, we maywanttostoreourllamasbothinorderofageaswellasalphabeticallybyname.Thefollowingcodecreates Llama objects in dynamic memory and stores pointers to them in two different lists: intmain() { List<Llama *> by_age; by_age.push_back( newLlama("Paul")); by_age.push_back( newLlama("Carl")); List<Llama *> by_name; by_name.push_back(by_age.back()); by_name.push_back(by_age.front()); } Figure 38.3 shows the resulting storage.The code above, however, has a memory leak; the destructors for the lists only free the memory for the Nodeobjects, so theLlamaobjects do not get deleted.
We need to manually delete them before the lists that we are using to track them go away: 297 Programming and Data Structures, Release 0.3 List<Llama *>::NodenextdatumList<Llama *>::Node0x0nextdatum StackLlama"Paul"namemainLlama"Carl"nametruehungryby_nameList<Llama *>lastfirsttruehungryby_ageList<Llama *>lastfirstList<Llama *>::NodenextdatumList<Llama *>::Node0x0nextdatum Figure 38.3: Two containers that store pointers to the same objects. intmain() { List<Llama *> by_age; by_age.push_back( newLlama("Paul")); by_age.push_back( newLlama("Carl")); List<Llama *> by_name; by_name.push_back(by_age.back()); by_name.push_back(by_age.front()); for(autollama : by_age) { deletellama; } for(autollama : by_name) { deletellama; // UNDEFINED BEHAVIOR } } This code is erroneous: it deletes each Llamaobject twice, resulting in undefined behavior.We need to be careful to avoid memory errors when we have multiple containers referring to the same dynamic objects.
What we should do is designateonecontainerasthecanonical“owner”oftheobjects,onlydeletingthemwhenthatcontainerisabouttodie: intmain() { List<Llama *> by_age; // "owner" of llama objects by_age.push_back( newLlama("Paul")); by_age.push_back( newLlama("Carl")); List<Llama *> by_name; by_name.push_back(by_age.back()); by_name.push_back(by_age.front()); for(autollama : by_age) { // delete llamas when by_age is dying deletellama; } } 298 Programming and Data Structures, Release 0.3 Alternatively,wecanstoretheobjectsdirectlyinthecontainerthat“owns”them,sothatthedestructorforthecontainer does the work of reclaiming those objects: intmain() { List<Llama> by_age; // "owner" of llama objects by_age.push_back(Llama("Paul")); by_age.push_back(Llama("Carl")); List<Llama *> by_name; by_name.push_back(&by_age.back()); by_name.push_back(&by_age.front()); } // llamas die automatically when by_age dies Here,weconstructthe Llamaobjectsastemporarieswhenpassingthemto push_back() .
Standard-librarycontainers haveemplace_back() functions that avoid creating temporaries, and we pass the constructor arguments directly to that function: intmain() { List<Llama> by_age; // "owner" of llama objects by_age.emplace_back("Paul"); by_age.emplace_back("Carl"); List<Llama *> by_name; by_name.push_back(&by_age.back()); by_name.push_back(&by_age.front()); } // llamas die automatically when by_age dies The result in memory is shown in Figure 38.4. Stackmain by_nameList<Llama *>lastfirstzooList<Llama>lastfirstList<Llama *>::NodenextdatumList<Llama *>::Node0x0nextdatumList<Llama>::Nodenext0x0nextdatumLlama"Paul"nametruehungryList<Llama>::NodedatumLlama"Carl"nametruehungry Figure 38.4: Storing pointers to elements of a different container.The llamas die automatically when the container in which they reside dies, at the end of main()in the code above.
299 Programming and Data Structures, Release 0.3 38.1 Sorting Containers of Pointers The following code stores pointers to llamas in a container and then sorts them: intmain() { vector<Llama *> llamas = { newLlama("Paul"), newLlama("Carl") }; std::sort(llamas.begin(), llamas.end()); ... } While this code compiles, it sorts the pointers in the container by the address values they store, not by some property of theLlamaobjects.This is because std::sort() uses the<operator by default, which for pointers just compares the addresses they contain.The result depends on where the two Llamaobjects were placed in memory, which is implementation-dependent.Instead, we need to supply our own comparator to std::sort() , and the comparator can use whatever property we choose of the underlying Llamaobjects: class LlamaPointerNameLess { public: bool operator ()(constLlama *l1, constLlama *l2) const{ returnl1->get_name() < l2->get_name(); } }; Here, we have chosen to sort llamas by name.
The comparator operates on pointers to Llamas, since that is what the container stores. We then call std::sort() as follows: std::sort(llamas.begin(), llamas.end(), LlamaPointerNameLess()); Thethirdargumentisadefault-constructed,temporary LlamaPointerNameLess object.Now std::sort() willuse that to compare the Llama * elements, resulting in them being ordered by the names of the respective llamas.We can use different comparators to maintain different orderings of the same objects: vector<Llama> llamas = { Llama("Paul"), Llama("Carl") }; vector<Llama *> by_age; for(auto&llama : llamas) { by_age.push_back(&llama); } std::sort(by_age.begin(), by_age.end(), LlamaPointerAgeLess()); vector<Llama *> by_name = by_age; std::sort(by_name.begin(), by_name.end(), LlamaPointerNameLess()); 38.1.
Sorting Containers of Pointers 300 Programming and Data Structures, Release 0.3 38.2 Containers of Polymorphic Objects Keeping track of polymorphic objects, meaning objects of different derived classes of the same base class, requires indirection as we saw previously . Containers of pointers enable this indirection: intmain() { vector<Animal *> zoo; zoo.push_back( newGorilla("Colo")); zoo.push_back( newLlama("Paul")); zoo.push_back( newPanda("Po")); for(autoanimal_ptr : zoo) { animal_ptr->talk(); // prints different messages for each animal } ...} As long as the talk()function is virtual, dynamic binding will be used, and each animal will print its own sound.When we are done with the objects, we need to delete them ourselves, since they are in dynamic memory: for(autoanimal_ptr : zoo) { deleteanimal_ptr; } As we saw previously , this requires the Animaldestructor to be declared as virtual so that dynamic binding is used to call the appropriate destructor for each object.38.2.
Containers of Polymorphic Objects 301 CHAPTER THIRTYNINE C AND C++ STRINGS Astringis a sequence of characters, and it represents text data. C++ has two string abstractions, which we refer to as C-style strings andC++ strings .39.1 C-Style Strings In the original C language, strings are represented as just an array of characters, which have the type char.The following initializes a string representing the characters in the word hello: charstr[6] = { 'h','e','l','l','o','\0'}; 0x1000'h'str[0]0x1001'e'str[1]0x1002'l'str[2]0x1003'l'str[3]0x1004'o'str[4]0x1005'\0'str[5]str: Figure 39.1: Array representation of a string.Characterliteralsareenclosedinsinglequotes.Forexample 'h'isthecharacterliteralcorrespondingtothelower-case letter h.The representation of the string in memory is shown in Figure 39.1.A C-style string has a sentinelvalue at its end, the special null character , denoted by '\0'.
This is not the same as a nullpointer,whichisdenotedby nullptr,northecharacter '0',whichdenotesthedigit0. Thenullcharactersignals the end of the string, and algorithms on C-style strings rely on its presence to determine where the string ends.A character array can also be initialized with a string literal: charstr2[6] = "hello"; charstr3[] = "hello"; If the size of the array is specified, it must have sufficient space for the null terminator.In the second case above, the sizeofthearrayisinferredas6fromthestringliteralthatisusedtoinitializeit.Astringliteralimplicitlycontainsthe null terminator at its end, so both str2andstr3are initialized to end with a null terminator.302 Programming and Data Structures, Release 0.3 Thechartype is an atomic type that is represented by numerical values.The ASCIIstandard specifies the numerical values used to represent each character.
For instance, the null character '\0'is represented by the ASCII value 0, the digit '0'is represented by the ASCII value 48, and the letter 'h'is represented by the ASCII value 104. Figure 39.2 illustrates the ASCII values that represent the string "hello".0x1000104str[0]0x1001101str[1]0x1002108str[2]0x1003108str[3]0x1004111str[4]0x10050str[5]str: Figure 39.2: ASCII values of the characters in a string.An important feature of the ASCII standard is that the digits 0-9 are represented by consecutive values, the capital letters A-Z are also represented by consecutive values, and the lower-case letters a-z as well.The following function determines whether a character is a letter: boolis_alpha( charch) { return(ch >= 'A'&& ch <= 'Z') || (ch >= 'a'&& ch <= 'z'); } InC++,atomicobjectswithvalue0areconsideredtohavefalsetruthvalues,whileatomicobjectswithnonzerovalues areconsideredtobetrue.Thus,thenullterminatoristheonlycharacterthathasafalsetruthvalue.
Wewillmakeuse of that when implementing algorithms on C-style strings. Since C-style strings are just arrays, the pitfalls that apply to arrays also apply to C-style strings.For instance, a char array turns into a pointer to charwhen its value is required.Thus, comparisons and assignments on C-style strings cannot be done with the built-in operators: charstr1[6] = "hello"; charstr2[6] = "hello"; charstr3[6] = "apple"; char*ptr = str1; // manually convert array into pointer; // ptr points to first character of str1 // Test for equality?str1 == str2; // false; tests pointer equality // Copy strings?str1 = str3; // does not compile; RHS turns into pointer // Copy through pointer?ptr = str3; // sets ptr to point to first character of str3 When initializing a variable from a string literal, the variable can be an array, in which case the individual characters are initialized from those in the string literal: charstr1[6] = "hello"; 39.1.
C-Style Strings 303 Programming and Data Structures, Release 0.3 The variable can also be a pointer, in which case it just points to the first character in the string literal itself. String literalsarestoredinmemory;however,theC++standardprohibitsusfrommodifyingthememoryusedtostoreastring literal.Thus, we must use the constkeyword when specifying the element type of the pointer: const char *ptr = "hello"; 39.1.1 String Traversal and Functions The conventional pattern for iterating over a C-style string is to use traversal by pointer : walk a pointer across the elementsuntilthe endisreached.However,unlikethe traversalpatternwesaw previouslywherewealreadyknew the length,wedon’tknowtheendofaC-stylestringuntilwereachthenullterminator.Thus,weiterateuntilwereachthat sentinel value: // REQUIRES: str points to a valid, null-terminated string // EFFECTS: Returns the length of str, not including the null // terminator.
intstrlen( const char *str) { const char *ptr = str; while(*ptr != '\0') { ++ptr; } returnptr - str; } Here, we compute the length of a string by creating a new pointer that points to the first character. We then increment that pointer1until reaching the null terminator.Then the distance between that pointer and the original is equal to the number of non-null characters in the string.We can also use the truth value of the null character in the test of the while loop: intstrlen( const char *str) { const char *ptr = str; while(*ptr) { ++ptr; } returnptr - str; } We can also use a for loop, with an empty initialization and body: intstrlen( const char *str) { const char *ptr = str; for(; *ptr; ++ptr); returnptr - str; } The built-in <cstring> header contains a definition for strlen() .WesawpreviouslythatwecannotcopyC-stylestringswiththeassignmentoperator.Instead,weneedtouseafunction: 1Thetypeconst char * denotesapointerthatispointingataconstantcharacter.
Thismeansthatthepointed-tocharactercannotbemodified through the pointer. However, the pointer itself can be modified to point to a different character, which is what happens when we increment the pointer.39.1.C-Style Strings 304 Programming and Data Structures, Release 0.3 // REQUIRES: src points to a valid, null-terminated string; // dst points to an array with >= strlen(src) + 1 elements // MODIFIES: *dst // EFFECTS: Copies the characters from src into dst, including the // null terminator.voidstrcpy( char*dst, const char *src) { while(*src) { *dst = *src; ++src; ++dst; } *dst = *src; // null terminator } The function takes in a destination pointer; the pointed-to type must be non-const, since the function will modify the elements.Thefunctiondoesnotneedtomodifythesourcestring,sothecorrespondingparameterisapointerto const char.Theneachnon-nullcharacterfrom srciscopiedinto dst.Thelastlinealsocopiesthenullterminatorinto dst.
Thestrcpy() function can be written more succinctly by relying on the behavior of the postfix increment operator. There are two versions of the increment operator, and their evaluation process is visualized in Figure 39.3: Side Effect+1Side Effect+1EvaluateEvaluate++xx++ 4 33x4x4x3x4x4x3tempPrefix IncrementPostfix Increment Figure 39.3: Evaluation process for prefix and postfix increment.•Theprefixincrementoperator,whenappliedtoanatomicobject,incrementstheobjectandevaluatestotheobject itself, which now contains the new value: intx = 3; cout << ++x; // prints 4 cout << x; // prints 4 •Thepostfixincrementoperator,whenappliedtoanatomicobject,incrementstheobjectbutevaluatestotheold value: 39.1.C-Style Strings 305 Programming and Data Structures, Release 0.3 intx = 3; cout << x++; // prints 3 cout << x; // prints 4 There are also both prefix and postfix versions of the decrement operator ( --).
A word of caution when writing expressions that have side effects, such as increment: in C++, the order in which subexpressions are evaluated within a larger expression is for the most part unspecified. Thus, the following results in implementation-dependent behavior: intx = 3; cout << ++x << "," << x; // can print 4,4 or 4,3 If the second xin the print statement is evaluated before ++x, then a 3 will be printed out for its value.On the other hand,ifthesecond xisevaluatedafter ++x,a4willbeprintedoutforitsvalue.Codelikethis,whereasinglestatement contains two subexpressions that use the same variable but at least one modifies it, should be avoided.
Anotherfeaturethatourshorterversionof strcpy() willrelyonisthatanassignmentevaluatesbacktotheleft-hand- side object: intx = 3; inty = -4; ++(x = y); // copies -4 into x, then increments x cout << x; // prints -3 cout << (y = x); // prints -3 The succinct version of strcpy() is as follows: voidstrcpy( char*dst, const char *src) { while(*dst++ = *src++); } Thetestincrementsbothpointers,butsinceitisusingpostfixincrement,theexpressionsthemselvesevaluatetotheold values. Thus,inthefirstiteration, dst++andsrc++evaluatetotheaddressesofthefirstcharacterineachstring.The restofthetestexpressiondereferencesthepointersandcopiesthesourcevaluetothedestination.Theassignmentthen evaluates to the left-hand-side object, so the test checks the truth value of that object’s value.As long as the character that was copied was not the null terminator, it will be true, and the loop will continue on to the next character.
When the null terminator is reached, the assignment copies it to the destination but then produces a false value, so the loop terminates immediately after copying over the null terminator. The<cstring> library also contains a version of strcpy() .39.1.2 Printing C-Style Arrays Previously, we say that printing out an array prints out the address of its first character, since the array turns into a pointer.Printing out a pointer just prints out the address value contained in the pointer.On the other hand, C++ output streams have special treatment of pointers to char.If a pointer to charis passed to cout,itwillassumethatthepointerispointingintoaC-stylestringandprintouteverycharacteruntilitreachesanull terminator: charstr[] = "hello"; char*ptr = str; cout << ptr; // prints out hello cout << str; // str turns into a pointer; prints out hello 39.1.
C-Style Strings 306 Programming and Data Structures, Release 0.3 Thismeansthatwemustensurethata char *isactuallypointingtoanull-terminatedstringbeforepassingitto cout. The following results in undefined behavior: chararray[] = { 'h','e','l','l','o'}; // not null-terminated charch = 'w'; // just a character cout << array; // undefined behavior -- dereferences past end of array cout << &ch; // undefined behavior -- dereferences past ch To print out the address value of a char *, we must convert it into a void *, which is a pointer that can point to any kind of object: cout << static_cast <void*>(&ch); // prints address of ch 39.2 C++ Strings C++ strings are class-type objects represented by the stringtype2.They are not arrays, though the implementation may use arrays under the hood.Thus, C++ strings are to C-style strings as vectors are to built-in arrays.
The following table compares C-style and C++ strings: C-Style Strings C++ Strings Library Header <cstring> <string> Declaration char cstr[];char *cstr; string str Length strlen(cstr) str.length() Copy Value strcpy(cstr1, cstr2) str1 = str2 Indexing cstr[i] str[i] Concatenate strcat(cstr1, cstr2) str1 += str2 Compare !strcmp(cstr1, cstr2) str1 == str2 A C++ string can be converted into a C-style string by calling .c_str() on it: const char *cstr = str.c_str(); A C-style string can be converted into a C++ string by explicitly or implicitly calling the stringconstructor: string str1 = string(cstr); // explicit call string str = cstr; // implicit call C++stringscanbecomparedwiththebuilt-incomparisonoperators,whichcomparethemlexicographically: theASCII valuesofelementsarecomparedonebyone,andifthetwostringsdifferinacharacter,thenthestringwhosecharacter has a lower ASCII value is considered less than the other.
If one string is a prefix of the other, then the shorter one is less than the longer (which results from comparing the ASCII value of the null terminator to a non-null character). C-stylestringscannotbecomparedwiththebuilt-inoperators–thesewouldjustdopointercomparisons.Instead,the strcmp() function can be used, and strcmp(str1, str2) returns: •a negative value if str1is lexicographically less than str2 •a positive value if str1is lexicographically greater than str2 •0 if the two strings have equal values 2Technically, stringis an alias for basic_string<char> , so you may see the latter in compiler errors.39.2.C++ Strings 307 Programming and Data Structures, Release 0.3 The expression !strcmp(str1, str2) is often used to check for equality – if the two strings are equal, strcmp() returns 0, which has truth value false.39.2.C++ Strings 308 CHAPTER FORTY ABOUT ThesenoteswerewrittenbyAmirKamilinWinter2019forEECS280.
TheyarebasedonthelectureslidesbyJames Juett and Amir Kamil, which were themselves based on slides by Andrew DeOrio and many others. This text is licensed under the Creative Commons Attribution-ShareAlike 4.0 International license.309
