'Page number,'Layout,'Text,'Reading Order,'Confidence score % (Layout)
'1,'Header 1,"'Programming and Data Structures",'0,'41.40625000
'1,'Text 1,"'Release 0.3",'1,'48.82812500
'1,'Text 2,"'Amir Kamil",'2,'82.61718750
'1,'Footer 1,"'Sep 08, 2024",'3,'51.46484375
'2,'Header 2,"'CONTENTS",'4,'44.84863281
'2,'Text 3,"'I Foundations",'5,'45.60546875
'2,'Text 4,"'2",'6,'96.53320313
'2,'Text 5,"'1 Introduction",'7,'53.71093750
'2,'Text 6,"'3",'8,'96.28906250
'2,'Text 7,"'2 C++ Fundamentals",'9,'63.76953125
'2,'Text 8,"'3 Types",'10,'63.62304688
'2,'Text 9,"'4",'11,'97.65625000
'2,'Text 10,"'9",'12,'97.55859375
'2,'Text 11,"'3.1 Arithmetic and Comparisons",'13,'84.71679688
'2,'Text 12,"'10",'14,'98.24218750
'2,'Text 13,"'3.2 Library Types",'15,'79.73632813
'2,'Text 14,"'12",'16,'98.43750000
'2,'Text 15,"'4 Control Structures",'17,'77.34375000
'2,'Text 16,"'15",'18,'97.85156250
'2,'Text 17,"'5 Procedural Abstraction",'19,'48.04687500
'2,'Text 18,"'18",'20,'97.26562500
'2,'Text 19,"'5.1 Code Organization in C++",'21,'81.10351563
'2,'Text 20,"'19",'22,'97.02148438
'2,'Text 21,"'5.2 The Compilation Process",'23,'74.75585938
'2,'Text 22,"'21",'24,'97.41210938
'2,'Text 23,"'5.3 Specification Comments (RMEs)",'25,'90.08789063
'2,'Text 24,"'21",'26,'97.07031250
'2,'Text 25,"'5.4 Properties of Procedural Abstraction",'27,'89.25781250
'2,'Text 26,"'23",'28,'96.97265625
'2,'Text 27,"'6 Testing",'29,'82.42187500
'2,'Text 28,"'24",'30,'96.82617188
'2,'Text 29,"'7 Machine Model I",'31,'72.55859375
'2,'Text 30,"'7.1 Pointers",'32,'86.03515625
'2,'Text 31,"'26",'33,'95.75195313
'2,'Text 32,"'30",'34,'95.16601563
'2,'Text 33,"'8 Machine Model II",'35,'75.34179688
'2,'Text 34,"'8.1 Pointer Errors",'36,'88.18359375
'2,'Text 35,"'34",'37,'94.82421875
'2,'Text 36,"'8.2 Function Calls and the Call Stack",'38,'89.45312500
'2,'Text 37,"'34",'39,'94.48242188
'2,'Section header 1,"'II Data Abstraction",'40,'46.19140625
'2,'Text 38,"'37",'41,'94.38476563
'2,'Text 39,"'9 The const Keyword",'42,'69.43359375
'2,'Text 40,"'42",'43,'94.58007813
'2,'Text 41,"'9.1 References and const",'44,'91.74804688
'2,'Text 42,"'43",'45,'93.84765625
'2,'Text 43,"'9.2 Pointers and const",'46,'74.75585938
'2,'Text 44,"'44",'47,'93.55468750
'2,'Text 45,"'9.3 const Conversions",'48,'81.44531250
'2,'Text 46,"'44",'49,'93.79882813
'2,'Text 47,"'45",'50,'93.16406250
'2,'Text 48,"'10 Structs",'51,'64.94140625
'2,'Text 49,"'47",'52,'92.77343750
'2,'Text 50,"'10.1 Compound Objects and const",'53,'87.20703125
'2,'Text 51,"'52",'54,'92.04101563
'2,'Text 52,"'11 Abstract Data Types in C",'55,'49.31640625
'2,'Text 53,"'54",'56,'91.65039063
'2,'Text 54,"'11.1 Representation Invariants",'57,'80.27343750
'2,'Text 55,"'58",'58,'89.74609375
'2,'Text 56,"'11.2 Plain Old Data",'59,'86.81640625
'2,'Text 57,"'59",'60,'88.13476563
'2,'Text 58,"'11.3 Abstraction Layers",'61,'87.20703125
'2,'Text 59,"'60",'62,'87.15820313
'2,'Page number 1,"'i",'63,'66.01562500
'3,'Text 60,"'11.4 Testing an ADT",'64,'65.13671875
'3,'Text 61,"'61",'65,'73.33984375
'3,'Text 62,"'12 Command-Line Arguments",'66,'51.07421875
'3,'Text 63,"'64",'67,'87.45117188
'3,'Text 64,"'13 Input and Output (I/O)",'68,'38.67187500
'3,'Text 65,"'66",'69,'95.65429688
'3,'Text 66,"'13.1 I/O Redirection",'70,'69.53125000
'3,'Text 67,"'66",'71,'95.84960938
'3,'Text 68,"'13.2 Example: Adding Integers",'72,'88.28125000
'3,'Text 69,"'13.3 File I/O",'73,'43.40820313
'3,'Text 70,"'14 More on Streams",'74,'45.23925781
'3,'Text 71,"'14.1 String Streams",'75,'72.50976563
'3,'Section header 2,"'15 Program Design",'76,'42.62695313
'3,'Text 72,"'16 Abstract Data Types in C++",'77,'37.98828125
'3,'Text 73,"'16.1 Implicit this->",'78,'72.41210938
'3,'Text 74,"'16.2 Member Accessibility",'79,'77.24609375
'3,'Text 75,"'16.3 Constructors",'80,'80.37109375
'3,'Text 76,"'16.4 Default Initialization and Default Constructors",'81,'71.87500000
'3,'Text 77,"'16.8 Member-Initialization Order",'82,'74.90234375
'3,'Text 78,"'16.9 Delegating Constructors",'83,'73.24218750
'3,'Section header 3,"'17 Derived Classes and Inheritance",'84,'39.50195313
'3,'Text 79,"'17.1 Ordering of Constructors and Destructors",'85,'79.10156250
'3,'Text 80,"'17.2 Name Lookup and Hiding",'86,'52.63671875
'3,'Text 81,"'18 Polymorphism",'87,'44.16503906
'3,'Text 82,"'18.1 Function Overloading",'88,'64.89257813
'3,'Text 83,"'18.2 Subtype Polymorphism",'89,'69.77539063
'3,'Text 84,"'101",'90,'78.41796875
'3,'Text 85,"'18.3 Static and Dynamic Binding",'91,'69.18945313
'3,'Text 86,"'18.4 dynamic_cast",'92,'92.67491913
'3,'Text 87,"'67",'93,'95.60546875
'3,'Text 88,"'68",'94,'95.65429688
'3,'Text 89,"'72",'95,'94.97070313
'3,'Text 90,"'73",'96,'95.70312500
'3,'Text 91,"'75",'97,'96.87500000
'3,'Text 92,"'76",'98,'95.55664063
'3,'Text 93,"'78",'99,'96.33789063
'3,'Text 94,"'80",'100,'96.53320313
'3,'Text 95,"'81",'101,'96.72851563
'3,'Text 96,"'83",'102,'96.04492188
'3,'Text 97,"'16.5 Get and Set Functions",'103,'80.81054688
'3,'Text 98,"'85",'104,'95.60546875
'3,'Text 99,"'16.6 Information Hiding",'105,'86.66992188
'3,'Text 100,"'87",'106,'93.99414063
'3,'Text 101,"'16.7 Testing a C++ ADT",'107,'81.73828125
'3,'Text 102,"'88",'108,'93.06640625
'3,'Text 103,"'89",'109,'92.08984375
'3,'Text 104,"'89",'110,'92.48046875
'3,'Text 105,"'91",'111,'90.13671875
'3,'Text 106,"'95",'112,'89.11132813
'3,'Text 107,"'97",'113,'89.99023438
'3,'Text 108,"'100",'114,'88.62304688
'3,'Text 109,"'100",'115,'84.66796875
'3,'Text 110,"'103",'116,'87.59765625
'3,'Text 111,"'104",'117,'79.05273438
'3,'Text 112,"'18.5 Member Lookup Revisited",'118,'65.67382813
'3,'Text 113,"'105",'119,'79.63867188
'3,'Text 114,"'18.6 The override Keyword",'120,'58.15429688
'3,'Text 115,"'107",'121,'80.61523438
'3,'Text 116,"'18.7 Abstract Classes and Interfaces",'122,'68.40820313
'3,'Text 117,"'108",'123,'76.85546875
'3,'Section header 4,"'III Containers and Dynamic Memory",'124,'71.53320313
'3,'Text 118,"'110",'125,'87.64648438
'3,'Section header 5,"'19 Containers and Iterators",'126,'40.82031250
'3,'Text 119,"'111",'127,'85.64453125
'3,'Text 120,"'19.1 Range-Based For Loops",'128,'78.41796875
'3,'Text 121,"'111",'129,'83.39843750
'3,'Text 122,"'20 Time Complexity",'130,'43.21289063
'3,'Text 123,"'114",'131,'86.03515625
'3,'Text 124,"'21 Arrays",'132,'50.39062500
'3,'Text 125,"'115",'133,'88.18359375
'3,'Text 126,"'21.1 Arrays and Pointers",'134,'79.19921875
'3,'Text 127,"'118",'135,'87.74414063
'3,'Text 128,"'21.2 Pointer Arithmetic",'136,'73.24218750
'3,'Text 129,"'119",'137,'88.08593750
'3,'Text 130,"'21.3 Array Indexing",'138,'82.03125000
'3,'Text 131,"'120",'139,'83.69140625
'3,'Text 132,"'21.4 More on Array Decay",'140,'87.10937500
'3,'Text 133,"'122",'141,'84.71679688
'3,'Text 134,"'21.5 The End of an Array",'142,'83.20312500
'3,'Text 135,"'122",'143,'87.98828125
'3,'Text 136,"'21.6 Array Traversal",'144,'71.92382813
'3,'Text 137,"'123",'145,'86.47460938
'3,'Text 138,"'21.7 Arrays and const",'146,'56.78710938
'3,'Text 139,"'124",'147,'81.15234375
'3,'Page number 2,"'ii",'148,'62.50000000
'4,'Table 1,"",'149,'28.90625000
'4,'Section header 6,"'28 Implementing Iterators",'150,'54.29687500
'4,'Text 140,"'193",'151,'73.09570313
'4,'Text 141,"'28.1 Iterator Definition",'152,'62.35351563
'4,'Text 142,"'196",'153,'65.13671875
'4,'Text 143,"'201",'154,'64.50195313
'4,'Text 144,"'28.3 Generic Iterator Functions 202",'155,'50.29296875
'4,'Text 145,"'28.2 Friend Declarations",'156,'67.91992188
'4,'Text 146,"'28.5 Type Deduction 205",'157,'42.43164063
'4,'Text 147,"'204",'158,'65.03906250
'4,'Text 148,"'28.4 Iterator Invalidation",'159,'43.67675781
'4,'Text 149,"'207",'160,'67.82226563
'4,'Section header 7,"'IV Functional Programming",'161,'61.23046875
'4,'Text 150,"'208",'162,'67.91992188
'4,'Section header 8,"'29 Function Objects",'163,'46.38671875
'4,'Text 151,"'211",'164,'56.88476563
'4,'Footer 2,"'iii",'165,'46.28906250
'4,'Text 152,"'29.1 Function-Pointer Types",'166,'64.25781250
'5,'Table 2,"",'167,'26.31835938
'5,'Text 153,"'iv",'168,'56.39648438
'6,'Header 3,"'Programming and Data Structures, Release 0.3",'169,'60.83984375
'6,'Section header 9,"'List of Lectures",'170,'82.32421875
'6,'List 1,"",'171,'81.29882813
'6,'Text 154 - Part of List 1,"'1) Introduction and C++",'172,'97.85156250
'6,'Text 155 - Part of List 1,"'2) Types, Control Structures, and Procedural Abstraction",'173,'97.46093750
'6,'Text 156 - Part of List 1,"'3) Machine Model I",'174,'97.31445313
'6,'Text 157 - Part of List 1,"'4) Machine Model II",'175,'97.46093750
'6,'Text 158 - Part of List 1,"'5) Const, Structs, and ADTs in C",'176,'98.09570313
'6,'Text 159 - Part of List 1,"'6) Streams and I/O",'177,'97.75390625
'6,'Text 160 - Part of List 1,"'7) Program Design",'178,'97.36328125
'6,'Text 161 - Part of List 1,"'8) Abstract Data Types in C++",'179,'97.02148438
'6,'Text 162 - Part of List 1,"'9) Derived Classes and Inheritance",'180,'96.58203125
'6,'Text 163 - Part of List 1,"'10) Polymorphism",'181,'95.84960938
'6,'Text 164 - Part of List 1,"'11) Containers and Iterators",'182,'94.92187500
'6,'Text 165 - Part of List 1,"'12) Time Complexity, Arrays, and Pointer Arithmetic",'183,'94.82421875
'6,'Text 166 - Part of List 1,"'13) Array-based Containers I",'184,'93.55468750
'6,'Text 167 - Part of List 1,"'14) Array-based Containers II",'185,'94.23828125
'6,'Text 168 - Part of List 1,"'15) Memory Models and Dynamic Memory",'186,'92.43164063
'6,'Text 169 - Part of List 1,"'16) Managing Dynamic Memory",'187,'94.48242188
'6,'Text 170 - Part of List 1,"'17) The Big Three",'188,'95.06835938
'6,'Text 171 - Part of List 1,"'18) Linked Lists",'189,'94.72656250
'6,'Text 172 - Part of List 1,"'19) Implementing Iterators",'190,'93.21289063
'6,'Text 173 - Part of List 1,"'20) Function Objects and Impostor Syndrome",'191,'92.33398438
'6,'Text 174 - Part of List 1,"'21) Recursion",'192,'94.09179688
'6,'Text 175 - Part of List 1,"'22) Structural Recursion",'193,'92.72460938
'6,'Text 176 - Part of List 1,"'23) Binary Search Trees and Maps",'194,'91.74804688
'6,'Text 177 - Part of List 1,"'24) Error Handling and Exceptions",'195,'92.13867188
'6,'Footer 3,"'CONTENTS",'196,'87.30468750
'6,'Page number 3,"'1",'197,'71.48437500
'7,'Title 1,"'Part I Foundations",'198,'37.84179688
'7,'Page number 4,"'2",'199,'86.81640625
'8,'Header 4,"'CHAPTER",'200,'44.94628906
'8,'Header 5,"'ONE",'201,'38.20800781
'8,'Title 2,"'INTRODUCTION",'202,'42.52929688
'8,'Text 178,"'Welcome to EECS 280: Programming and Introductory Data Structures! This course covers several fundamental concepts in programming, including basic principles such as procedural and data abstraction, resource management, and basic data structures. The following is the official course description:",'203,'96.43554688
'8,'Text 179,"'Techniques and algorithm development and effective programming, top-down analysis, structured pro- gramming, testing, and program correctness. Program language syntax and static and runtime semantics. Scope, procedure instantiation, recursion, abstract data types, and parameter passing methods. Structured data types, pointers, linked data structures, stacks, queues, arrays, records, and trees.",'204,'94.18945313
'8,'Text 180,"'This course, and Computer Science in general, is not about computers, as stated by Hal Abelson, author of the seminal textbook Structure and Interpretation of Computer Programs:",'205,'89.01367188
'8,'Text 181,"'[Computer science] is not really about computers - and it's not about computers in the same sense that physics is not really about particle accelerators, and biology is not about microscopes and Petri dishes and geometry isn't really about using surveying instruments.",'206,'93.11523438
'8,'Text 182,"'Instead, the purpose of this course is to examine the generalizable concepts in programming. To understand what a generalizable concept is, let's take a diversion from programming and consider a concept in baking. How many eggs do you put in a cake (assuming a single-layer, eight-inch cake)? Eggs serve several functions in a cake, including providing structure, influencing the texture and smoothness, providing moisture, and contributing to the taste of the cake. As an experiment, Summer Stone of The Cake Blog varied the number of eggs in a recipe between zero and four, finding the following:",'207,'97.26562500
'8,'List 2,"",'208,'93.31054688
'8,'Text 183 - Part of List 2,"'0 eggs: The cake was short and dense, and it fell apart when cut. It also tasted very much like flour.",'209,'97.94921875
'8,'Text 184 - Part of List 2,"'1 egg: The cake was dense and compact, but held together when cut and had a pleasant taste.",'210,'97.60742188
'8,'Text 185 - Part of List 2,"'2 eggs: The cake had a greater height and lighter texture and also had a pleasant taste.",'211,'97.55859375
'8,'Text 186 - Part of List 2,"'3 eggs: The cake was even taller and lighter, with a slightly spongy texture, and still had a pleasant taste.",'212,'97.46093750
'8,'Text 187 - Part of List 2,"'4 eggs: The cake was short, dense, and rubbery and tasted very much like egg.",'213,'95.99609375
'8,'Text 188,"'The generalizable concept here is that eggs provide structure to a cake, and that more eggs results in a lighter cake, up to a point. Thus, the structure and texture of a cake can be manipulated by varying the number of eggs, as long as there aren't too few or too many.",'214,'94.92187500
'8,'Text 189,"'The topics that we will cover in this course concern the generalizable concepts in programming, including procedural abstraction, data abstraction, dynamic resource management, object orientation, and many others. We will use C++ as our vehicle for learning these concepts, and we will implement several large programming projects to develop our experience and understanding of the concepts. However, learning C++ and implementing projects aren't the end goal; rather, they are the mechanisms we use to explore the topics.",'215,'95.84960938
'8,'Page number 5,"'3",'216,'82.17773438
'9,'Header 6,"'CHAPTER TWO",'217,'31.03027344
'9,'Title 3,"'C++ FUNDAMENTALS",'218,'70.65429688
'9,'Text 190,"'C++ is a programming language, a language designed for expressing programs at a higher level than machine code, which is what directly runs on a computer's central processing unit (CPU). For example, Intel and AMD processors (typically used in Windows machines) implement the x86_64 instruction set architecture (ISA), which results in ma- chine code that looks like the following:",'219,'99.02343750
'9,'Table 3,"",'220,'84.17968750
'9,'Text 191,"'Apple CPUs, as well as most mobile processors, implement the AArch64 ISA, with code like:",'221,'91.16210938
'9,'Table 4,"",'222,'96.82617188
'9,'Text 192,"'Machine code is extremely low level, SO rather than writing programs in it directly, we prefer to use a higher-level programming language that allows us to write more readable code that can work on many different CPU architectures. We can then use a compiler to translate the program into the equivalent machine code to run directly on a CPU. Examples of compilers for C++ include g++ (the GNU C++ compiler), Clang, and MSVC (Microsoft Visual C++).",'223,'97.85156250
'9,'Text 193,"'Alternatively, we can run a higher-level program through an interpreter, which rather than translating the program into machine code, directly emulates the behavior of the program. Lobster is an example of an interpreter for (a subset of) C++.",'224,'97.46093750
'9,'Text 194,"'To illustrate the compilation process, let's start with a small C++ program that prints to standard output (typically displaying in a console/terminal):",'225,'96.38671875
'9,'Text 195,"'#include <iostream>",'226,'91.35742188
'9,'Text 196,"'using namespace std;",'227,'87.74414063
'9,'Text 197,"'int main() { // print a greeting",'228,'81.44531250
'9,'Text 198,"'(continues on next page)",'229,'90.82031250
'9,'Page number 6,"'4",'230,'77.39257813
'10,'Header 7,"'Programming and Data Structures, Release 0.3",'231,'65.77148438
'10,'Text 199,"'(continued from previous page)",'232,'51.85546875
'10,'Text 200,"'cout << ""Hello World!"" << endl;",'233,'32.20214844
'10,'Text 201,"'// Declare some variables int x = 10 + 5; int y = 0; y = x; X = 20; // Print out the result cout << ""x = "" << < << "", y = "" << y << endl;",'234,'36.30371094
'10,'Text 202,"'}",'235,'82.13966370
'10,'Text 203,"'We will momentarily discuss what each part of the program means, but first let's compile and run the code. Assuming that the code is located in the file hello. cpp, we can compile it from the terminal (or command line) with g++:",'236,'80.90820313
'10,'Text 204,"'g++ --std=c++17 hello.cpp -0 hello.exe",'237,'56.00585938
'10,'Text 205,"'The items following g++ are arguments (or command-line arguments to be precise) to the compiler:",'238,'93.94531250
'10,'List 3,"",'239,'92.87109375
'10,'Text 206 - Part of List 3,"'--std=c++17 tells the compiler to use the C++17 version of the language",'240,'96.82617188
'10,'Text 207 - Part of List 3,"'hello. cpp is our program",'241,'93.89648438
'10,'Text 208 - Part of List 3,"'-0 hello. exe tells the compiler to name the resulting machine-code file, or executable, as hello.exe",'242,'96.04492188
'10,'Text 209,"'After running the above command, we can now run the resulting executable from the command line:",'243,'79.10156250
'10,'Text 210,"'/hello.exe",'244,'73.24218750
'10,'Text 211,"'Here, / tells the terminal that the executable is in the current directory (or folder). The terminal runs the program and displays the printed output:",'245,'93.89648438
'10,'Text 212,"'Hello World! X = 20, y = 15",'246,'92.43164063
'10,'Text 213,"'Returning to the program source code, the first line (#include <iostream>) imports functionality from the C++ standard library, allowing us to write output to the screen and read input from the keyboard. In particular, it defines cout, which we can use with the insertion operator << to print values to standard output. The cout variable is actually defined inside the std (short for ""standard"") namespace, which is a way to organize names to avoid conflicts with other libraries. There are several ways we can use a name defined within a namespace:",'247,'96.82617188
'10,'Text 214,"'with a qualified name that includes the namespace, as in std: : cout:",'248,'95.06835938
'10,'Text 215,"'#include <iostream>",'249,'45.89843750
'10,'Text 216,"'int main() { // print a greeting std::cout << ""Hello World!"" << std: : endl; }",'250,'95.31250000
'10,'Text 217,"'by first importing each name we want to use directly via using declarations, after which we can use the name without qualification:",'251,'96.04492188
'10,'Text 218,"'#include <iostream>",'252,'75.78125000
'10,'Text 219,"'(continues on next page)",'253,'56.29882813
'10,'Page number 7,"'5",'254,'92.28515625
'11,'Header 8,"'Programming and Data Structures, Release 0.3",'255,'71.38671875
'11,'Text 220,"'(continued from previous page)",'256,'68.94531250
'11,'Text 221,"'using std: cout; using std: endl int main() { // print a greeting cout << ""Hello World!"" << endl; }",'257,'39.59960938
'11,'Text 222,"'by importing all the names from a namespace at once:",'258,'87.35351563
'11,'Text 223,"'#include <iostream> using namespace std;",'259,'43.67675781
'11,'Text 224,"'int main() { // print a greeting cout << ""Hello World!"" << endl; }",'260,'85.59570313
'11,'Text 225,"'Be careful with the last option, as there can be many names defined within a namespace, and importing them all increases the likelihood of there being a conflict with names defined outside of the namespace. For simplicity, we will use it here.",'261,'94.97070313
'11,'Text 226,"'After the initial two lines, we have a definition of a main() function, which is the entry point of a C++ program. The function returns an integer, represented by the int type, and that comes before the function name itself. For now, we define main () to not take any arguments. (If the function takes arguments, there would be function parameters between the parentheses; we will return to this later.) Then we have the body of the function, enclosed by a pair of matching curly braces. Within the body, we have a sequence of statements, which are executed in order. The first line of the body is actually a comment rather than a statement:",'262,'95.89843750
'11,'Text 227,"'// print a statement",'263,'49.12109375
'11,'Text 228,"'This does not do anything, but it serves as documentation for someone reading the code. We can write a comment by starting it with double slashes, in which case the rest of the line comprises the comment. Alternatively, we can use the sequence /* to open a comment and */ to close it, which allows a comment to span multiple lines or part of a line:",'264,'96.28906250
'11,'Text 229,"'int main() a comment here */ { 1* here is a multiline comment */ }",'265,'92.04101563
'11,'Text 230,"'After the initial comment, we have a statement that prints to standard output:",'266,'92.72460938
'11,'Text 231,"'cout ""Hello World!"" endl;",'267,'83.20312500
'11,'Text 232,"'We use the insertion operator << to insert the string ""Hello World!"" - a string is a sequence of characters, and we can write one directly in our program by enclosing it in double quotes. (Be aware that unlike some other languages, C++ strings cannot span multiple lines in the source code.) After inserting the string, we chain another insertion of endl, which is defined by <iostream> in the std namespace. Inserting endl writes a newline, and it also flushes the output, meaning that it forces the output to appear immediately. (Without flushing, the output can be buffered until a later time, which can result in better performance at the expense of delaying output.) Finally, we end the statement with a semicolon, which is required at the end of simple statements in C++. Unlike Python and some other languages,",'268,'95.26367188
'11,'Page number 8,"'6",'269,'83.98437500
'12,'Header 9,"'Programming and Data Structures, Release 0.3",'270,'50.29296875
'12,'Text 233,"'whitespace is not generally significant in C++ programs, SO the end of a line does not automatically end a statement. We can see what happens if we forget a semicolon:",'271,'98.09570313
'12,'Text 234,"'#include <iostream>",'272,'48.53515625
'12,'Text 235,"'using namespace std;",'273,'42.16308594
'12,'Text 236,"'int main() { // print a greeting cout << ""Hello World!"" << endl // oops }",'274,'89.89257813
'12,'Text 237,"'Attempting to compile the program results in the following:",'275,'77.09960938
'12,'Text 238,"'hello. cpp: 7:33: error: expected ';' after expression cout << ""Hello World!"" << endl // oops ^ ; 1 error generated.",'276,'60.10742188
'12,'Text 239,"'This is a compile error, and it is the compiler informing us that we have a mistake in our code. The compiler does not produce an executable in such a case, and we have to fix our error and recompile.",'277,'94.82421875
'12,'Text 240,"'Continuing where we left off in our program, we have the following line:",'278,'89.55078125
'12,'Text 241,"'int x = 10 + 5;",'279,'71.63085938
'12,'Text 242,"'This is a variable declaration, which introduces a new variable, and in C++, it has three components:",'280,'95.70312500
'12,'List 4,"",'281,'89.16015625
'12,'Text 243 - Part of List 4,"'the type of the variable (int for an integer in this case)",'282,'96.58203125
'12,'Text 244 - Part of List 4,"'the name of the variable (x here)",'283,'94.04296875
'12,'Text 245 - Part of List 4,"'an optional initialization expression (10 + 5 above), which specifies the initial value of the variable",'284,'95.31250000
'12,'Text 246,"'Unlike languages like Python, C++ is statically typed, meaning that the type of a variable must be known at compile time, generally by explicitly specifying the type in the variable's declaration. And the type of the variable never changes - for as long as it exists, it will have the type specified in its declaration.",'285,'91.60156250
'12,'Text 247,"'A variable's initialization is an expression, which is a fragment of code that evaluates to some value. (An expression may also have a side effect, which modifies the state of the program in some way, such as by printing to the screen or changing the value of an existing variable.) Expressions may be composed of the following elements:",'286,'89.11132813
'12,'List 5,"",'287,'87.89062500
'12,'Text 248 - Part of List 5,"'literals, which specify a value directly in source code, such as 42 or ""Hello World!""",'288,'96.48437500
'12,'Text 249 - Part of List 5,"'variables",'289,'93.99414063
'12,'Text 250 - Part of List 5,"'functions calls, such as sqrt (x)",'290,'95.75195313
'12,'Text 251 - Part of List 5,"'operators such as + and",'291,'93.99414063
'12,'Text 252,"'In the case of the variable declaration above, the initialization expression 10 + 5 evaluates to the value 15, which then becomes the initial value of the variable X.",'292,'90.47851563
'12,'Text 253,"'We will see later when initialization expressions are required. For now, we note that for a variable of type int, without an initialization expression, the variable would have an undefined value, which would result in undefined behavior if we were to use its value. Undefined behavior means that we cannot rely on the outcome - the program might work, or it might crash, or it might empty your bank account. Thus, undefined behavior should be avoided at all costs.",'293,'92.87109375
'12,'Text 254,"'Examining the following lines,",'294,'78.41796875
'12,'Page number 9,"'7",'295,'86.42578125
'13,'Header 10,"'Programming and Data Structures, Release 0.3",'296,'56.59179688
'13,'Text 255,"'int y = 0; y=x; X = 20;",'297,'76.75781250
'13,'Text 256,"'we see that the variable y is introduced with initial value 0. Then we have an assignment, which copies the value from the right-hand side into the left - in this case, the value of X, which is 15, is copied into y. The next line then assigns the value 20 to X. This, when the last line",'298,'97.60742188
'13,'Key value 1,"",'299,'85.98632813
'13,'Text 257,"'executes, we see that X has the value 20 and y the value 15.",'300,'90.28320313
'13,'Text 258,"'A variable can only be used when it is in scope. A scope is a region of source code where names are meaningful, and such a region often corresponds to a block of code delimited by curly braces. A variable is in scope starting at its declaration until the end of the scope region in which it is defined. For example, consider the following code:",'301,'95.84960938
'13,'Text 259,"'int main() { int X = 5; // X is now in scope cout << y << endl; // COMPILE ERROR -- y is not in scope int = -3; // y is now in scope Ex(s) int a = x - y; // a is now in scope cout a << endl; } // a is no longer in scope cout << a << endl; // COMPILE ERROR -- a is not in scope }",'302,'46.87500000
'13,'Text 260,"'The variable y is not in scope until its declaration, SO attempting to use it in the second statement is an error. Below, the curly braces associated with the conditional define a new scope region, in which the variable a is introduced. Outside of the curly braces, a is no longer in scope, SO using it in the last statement is erroneous. The compiler checks for us whether or not variables are in scope, reporting errors if we try to use one that is not.",'303,'97.60742188
'13,'Text 261,"'We have seen a simple program, how to compile and run it, and some fundamental C++ elements. We proceed to discuss more complex C++ features, such as type conversions, standard-library types, functions, and control flow.",'304,'97.60742188
'13,'Page number 10,"'8",'305,'91.06445313
'14,'Text 262,"'CHAPTER",'306,'51.26953125
'14,'Text 263,"'THREE",'307,'40.82031250
'14,'Text 264,"'TYPES",'308,'93.35937500
'14,'Text 265,"'Previously, we saw that in C++, a variable is declared with its type, and the remains its type as long as the variable exists. C++ has several fundamental (also called primitive or atomic) types that are built-in to the language and always available, without any #include lines. The following are a few such types:",'309,'97.75390625
'14,'List 6,"",'310,'91.40625000
'14,'Text 266 - Part of List 6,"'int represents a signed (positive, negative, or zero) integer, and in most implementations, can represent integers between 2-31 and 231 - 1, inclusive",'311,'97.65625000
'14,'Text 267 - Part of List 6,"'int X = 3;",'312,'96.48437500
'14,'Text 268 - Part of List 6,"'double represents a floating-point number1",'313,'96.67968750
'14,'Text 269 - Part of List 6,"'double y = 2.5;",'314,'94.67773438
'14,'Text 270 - Part of List 6,"'bool represents a Boolean value, i.e. true or false",'315,'95.89843750
'14,'Text 271 - Part of List 6,"'bool Z = true;",'316,'92.43164063
'14,'Text 272 - Part of List 6,"'char represents a single character (as opposed to a string, which is a sequence of characters), and a character literal is written with single quotes",'317,'86.08398438
'14,'Text 273 - Part of List 6,"'char c = 'w';",'318,'43.87207031
'14,'Text 274,"'As with int, a variable of fundamental type must be explicitly initialized - otherwise its value is undefined.",'319,'94.58007813
'14,'Text 275,"'int x; // undefined value double y ; // undefined value bool z; // undefined value char C; // undefined value",'320,'88.42773438
'14,'Text 276,"'The compiler's type system detects misuse of types. For instance, the following attempts to initialize a double with a string literal, which is not a compatible type:",'321,'95.65429688
'14,'Text 277,"'double y = ""llama""; // COMPILE ERROR",'322,'51.17187500
'14,'Text 278,"'On the other hand, there are some combinations of types for which C++ performs an implicit conversion, allowing one to be used where the other is expected. For instance, an int can be converted to a double, and vice versa:",'323,'95.75195313
'14,'Text 279,"'int X = 3.1; // narrowing conversion - - truncated to 3 double y = 42; // widening conversion - - value unchanged",'324,'70.65429688
'14,'Text 280,"'Similarly, numeric types can be converted to bool, with zero values converted to false and non-zero values to true.",'325,'90.28320313
'14,'Text 281,"'1 C++ also has a float type that represents floating-point numbers. A double typically uses twice the memory space of a float (hence the name), and it can represent a much larger range of values.",'326,'68.06640625
'14,'Page number 11,"'9",'327,'89.69726563
'15,'Header 11,"'Programming and Data Structures, Release 0.3",'328,'38.03710938
'15,'Key value 2,"",'329,'73.92578125
'15,'Text 282,"'Implicit conversions, while often useful, can also be a source of error. Consider the following code, which introduces a max () function that computes the maximum of two values. (We will discuss function definitions shortly.)",'330,'98.04687500
'15,'Text 283,"'double max (double X, double y) { int result = x; if (y x x) { result = y; } return result; }",'331,'84.27734375
'15,'Text 284,"'Suppose we have the call max (3.4, 3.1). The first line of the function implicitly converts the value of X, which is 3.4, to an int, SO that result contains the value 3. Then it is the case that y, whose value is 3.1, is larger than result, SO result is assigned the truncated value of y, which again results in 3. Thus, the function returns the value 3 instead of 3.4.",'332,'96.04492188
'15,'Text 285,"'Rather than relying on implicit conversions, which can be hard to detect when reading code, we can also do an explicit conversion via a cast. Depending on the types involved, C++ may require a cast, while in other cases it is optional. The following is an example of casting a double value to an int:",'333,'96.14257813
'15,'Text 286,"'double X = 4.2; int y = x; // implicit conversion - - easy to miss int Z = static_cast<int> (x) // explicit conversion -- obvious in code",'334,'62.59765625
'15,'Text 287,"'While there are other kinds of casts, static_cast is the most common and the one we recommend.",'335,'96.53320313
'15,'Section header 10,"'3.1 Arithmetic and Comparisons",'336,'93.21289063
'15,'Text 288,"'C++ supports common arithmetic operations, such as addition (+), subtraction (-), multiplication (*), division (/), and modulo (%). The behavior of these operators depends on the types of the operand - for example, adding two int values together produces an int, while adding two double values produces a double. The same holds for division, where dividing two int values truncates the result to produce another int value:",'337,'97.41210938
'15,'Key value 3,"",'338,'62.35351563
'15,'Text 289,"'We can obtain a double value by ensuring that one of the operands is a double:",'339,'95.94726563
'15,'Key value 4,"",'340,'49.60937500
'15,'Text 290,"'When the operand types differ as above, one operand is promoted to the type of the other, generally to the one that allows for more precision. In the cases above, the int operand is promoted to double as part of the division operation.",'341,'96.19140625
'15,'Text 291,"'The modulo operator requires both operands to be integers. The std: :modf() function in the <cmath> library can be used on floating-point operands. (Similarly, the std: : pow() function in <cmath> does exponentiation C++ does not have an operator for that.)",'342,'96.48437500
'15,'Text 292,"'As an example of modulo, the following functions convert a total number of seconds to whole minutes and leftover seconds, respectively:",'343,'95.31250000
'15,'Footer 4,"'3.1. Arithmetic and Comparisons",'344,'84.71679688
'15,'Page number 12,"'10",'345,'80.66406250
'16,'Title 4,"'Programming and Data Structures, Release 0.3",'346,'38.86718750
'16,'Text 293,"'int minutes (int seconds) { return seconds / 60; }",'347,'38.03710938
'16,'Text 294,"'int remaining_seconds (int seconds) { return seconds % 60; }",'348,'30.32226563
'16,'Text 295,"'int main() { int total = 153; int min = minutes(total) ; // 2 int sec = remaining_seconds(total) ; // 33 }",'349,'25.24414063
'16,'Text 296,"'We rely on integer division to truncate the result in minutes (), and we use the modulo operator in remaining_seconds to compute the remainder of the total number of seconds with 60.",'350,'75.63476563
'16,'Text 297,"'C++ also has standard comparison operators: equality (==), inequality (!=), less (<), less or equal (<=), greater (>), and greater or equal (>=). However, avoid two pitfalls when using these operators:",'351,'81.00585938
'16,'List 7,"",'352,'25.41503906
'16,'Text 298 - Part of List 7,"'Be wary about comparing floating-point numbers that result from arithmetic operations - floating-point numbers cannot in general be represented exactly on a computer, SO we can get unexpected results due to the loss of precision:",'353,'82.66601563
'16,'Key value 5,"",'354,'45.70312500
'16,'Text 299,"'In such cases, values should be compared to within some margin of error rather than exactly:",'355,'85.54687500
'16,'Text 300,"'bool almost_equal (double X, double y, double epsilon) { return std::abs(x - y) < - epsilon; } cout << almost_equal (0.1 0.2, 0.3, 0.00001) << endl; // prints 1 (true)",'356,'48.14453125
'16,'Text 301,"'Here, we use std: : abs () to compute the absolute value of the difference between the two values, then compare against our margin of epsilon.",'357,'93.65234375
'16,'Text 302,"'C++ does not support Python-style chaining of comparisons:",'358,'87.79296875
'16,'Text 303,"'int X = 10; cout (3 < X << endl; // prints 1 (true)",'359,'62.59765625
'16,'Text 304,"'In this example, 3 < X produces true, which is then promoted to the integer value of 1 for the subsequent com- parison with 7. Since 1 < 7, the result is true.",'360,'89.69726563
'16,'Text 305,"'Rather than chaining comparisons, we need to use Boolean logic to combine the results of two separate compar- isons:",'361,'81.39648438
'16,'Key value 6,"",'362,'52.63671875
'16,'Text 306,"'More on logical operations below.",'363,'58.88671875
'16,'Footer 5,"'3.1. Arithmetic and Comparisons",'364,'79.93164063
'16,'Page number 13,"'11",'365,'88.28125000
'17,'Header 12,"'Programming and Data Structures, Release 0.3",'366,'80.12695313
'17,'Title 5,"'3.2 Library Types",'367,'45.70312500
'17,'Text 307,"'Aside from the fundamental types that are always available to C++ programs, individual headers in the standard library define additional types. For instance, some commonly used types include std: string defined by the <string> header, std: vector defined by the <vector> header, and std: pair defined by the <utility> header.",'368,'97.31445313
'17,'Text 308,"'The std: string type represents an ordered sequence of characters. Similar to the initial program we saw last time, we first need to import the relevant header to get access to the type. We can then either use the qualified name with the std:: prefix, or include a using declaration to allow us to use string without qualification. The following is an example:",'369,'95.75195313
'17,'Text 309,"'#include <iostream> #include <string>",'370,'36.62109375
'17,'Key value 7,"",'371,'25.87890625
'17,'Text 310,"'We start by declaring and initializing two string variables. We can compare them with < and other operators - the strings are compared lexicographically, meaning that the characters at each position are compared in order according to the underlying numerical value for the character. In the case above, since 'm' comes before 'w', strl compares less than str2. We can obtain the length of a string by calling .size() on it (the dot here is necessary, and we'll see how this gets implemented later when we discuss classes and member functions). We can concatenate two strings with the + operator and use square brackets to read or write an individual character in a string. In the code above, we concatenate str1 and str2 to produce ""make a wish"". Then we copy the character at index 7, which is 'w`, to position 0, resulting in ""wake a wish"". Finally, we set the character at index 7 to 'f', which gives us the string ""wake a fish"".",'372,'97.41210938
'17,'Text 311,"'Aside from characters, we might want to keep track of a sequence of other elements, such as int values. A std: vector is a generic sequence type that allows us to specify the type of element it holds. For instance, the following creates both a vector of double values and one that holds string values:",'373,'95.60546875
'17,'Text 312,"'#include <vector>",'374,'43.31054688
'17,'Text 313,"'using namespace std; vector<double> nums = {1, 5, 3.5, 6.5}; vector<string> pets = {""cat"", ""dog"", ""fish""};",'375,'60.93750000
'17,'Text 314,"'Here, we initialize each vector with an explicit set of values. There are other ways to initialize a vector:",'376,'93.06640625
'17,'Footer 6,"'3.2. Library Types",'377,'61.62109375
'17,'Page number 14,"'12",'378,'89.30664063
'18,'Header 13,"'Programming and Data Structures, Release 0.3",'379,'61.52343750
'18,'Key value 8,"",'380,'66.11328125
'18,'Text 315,"'As with a string, we can use square brackets to index into a vector:",'381,'92.96875000
'18,'Text 316,"'vector<int> v = {3, 5, 42, 28}; cout << v[O] << endl; v[3] = 7; v[4] = 100; // out of bounds undefined behavior!",'382,'68.75000000
'18,'Text 317,"'Be careful not to access an index that is out of bounds - such an access results in undefined behavior. Alternatively, we can use the at () function, which checks whether we are within the bounds and throws an exception if we are not:",'383,'95.89843750
'18,'Text 318,"'vector<int> V = {3, 5, 42, 28}; cout << v[O] << endl; v.at(3)=7; v.at(4) = 100; // out of bounds. throws an exception",'384,'65.82031250
'18,'Text 319,"'Assuming we don't handle the exception, this causes the program to crash, which is better than undefined behavior - the crash immediately tells us we did something wrong, and we can run the code through a debugger to get more details.",'385,'97.36328125
'18,'Text 320,"'We can also modify the size of a vector by adding and removing elements. In particular, the push_back( function adds an element to the end, and the pop_back() function removes the last element. We can also remove all elements with .clear():",'386,'97.26562500
'18,'Table 5,"",'387,'26.46484375
'18,'Text 321,"'A few other useful vector functions are the following:",'388,'87.20703125
'18,'List 8,"",'389,'91.16210938
'18,'Text 322 - Part of List 8,"'size() returns the number of elements in the vector",'390,'98.04687500
'18,'Text 323 - Part of List 8,"'front () returns a reference to the first element",'391,'97.31445313
'18,'Text 324 - Part of List 8,"'back () returns a reference to the last element",'392,'96.72851563
'18,'Text 325 - Part of List 8,"'empty () returns whether or not the vector is empty",'393,'96.09375000
'18,'Text 326,"'For both strings and vectors, size returns the size as the size_t type, which is an unsigned integer, meaning that it cannot represent negative values. If we compare to a signed integer such as an int, the compiler may warn us that we are comparing a signed and unsigned integer, which might produce surprising results:",'394,'95.70312500
'18,'Footer 7,"'3.2. Library Types",'395,'78.46679688
'18,'Page number 15,"'13",'396,'86.27929688
'19,'Title 6,"'Programming and Data Structures, Release 0.3",'397,'36.03515625
'19,'Key value 9,"",'398,'82.56835938
'19,'Text 327,"'The following is an example of a compiler warning for this:",'399,'82.95898438
'19,'Key value 10,"",'400,'48.04687500
'19,'Text 328,"'To avoid this, we can use a cast to ensure that we are comparing values with the same ""signedness"":",'401,'91.35742188
'19,'Key value 11,"",'402,'62.69531250
'19,'Text 329,"'One last library type we examine now is std: : pair, which represents a pair of values rather than an arbitrary sequence. The following is an example of using pairs:",'403,'95.21484375
'19,'Section header 11,"'#include <utility>",'404,'67.48046875
'19,'Key value 12,"",'405,'46.67968750
'19,'Text 330,"'}",'406,'42.62695313
'19,'Footer 8,"'3.2. Library Types",'407,'86.18164063
'19,'Page number 16,"'14",'408,'89.40429688
'20,'Header 14,"'CHAPTER",'409,'37.67089844
'20,'Text 331,"'FOUR",'410,'32.69042969
'20,'Title 7,"'CONTROL STRUCTURES",'411,'74.56054688
'20,'Text 332,"'C++ is an imperative language, meaning that we specify computation as a sequence of statements. Like other languages, we often organize statements into functions, which we can then use as abstractions; we will return to this shortly. The syntax of a function definition is as follows:",'412,'97.02148438
'20,'Text 333,"'<return type> <function name> (<optional parameters>) { <body statements> }",'413,'78.51562500
'20,'Text 334,"'The return type is specified first, and it corresponds to the type of value that the function returns. In some cases, a function does not return a value at all, in which case we use the special type void to specify that this is the case:",'414,'94.48242188
'20,'Text 335,"'void print_value(intx) cout endl ; }",'415,'90.08789063
'20,'Text 336,"'If a function has a non-void return type, we explicitly provide the return value using a return statement:",'416,'96.77734375
'20,'Section header 12,"'double square (double x) {",'417,'66.45507813
'20,'Text 337,"'return X * x; }",'418,'31.66503906
'20,'Text 338,"'We need to ensure that every path through a non-void function reaches a return statement that provides a value com- patible with the return type. Otherwise, the behavior of the function is undefined, and the compiler may generate a warning or error.² 2",'419,'95.70312500
'20,'Text 339,"'After the return type, we specify the name of the function, and if it takes arguments, the function parameters within the following parentheses. A parameter specifies both the type of the value it expects, as well as the name we use to refer to the corresponding argument within the function body. Finally, we have the body consisting of a sequence of statements enclosed by curly braces.",'420,'96.33789063
'20,'Text 340,"'We can specify more complex control flow within a function through the use of compound statements such as condi- tionals and loops. The following demonstrates a conditional:",'421,'93.99414063
'20,'Section header 13,"'double abs (double x) {",'422,'44.36035156
'20,'Text 341,"'if (x ( ) ) { return -x; } else { return x; } }",'423,'84.03320313
'20,'Text 342,"'2 The one exception in C++ is the main () function, which implicitly returns the value 0 if no return statement is reached. However, this is not the case for any other function, even if its return type is int.",'424,'75.97656250
'20,'Page number 17,"'15",'425,'79.29687500
'21,'Header 15,"'Programming and Data Structures, Release 0.3",'426,'49.90234375
'21,'Text 343,"'We use the if keyword to introduce a conditional, followed by a test expression within parentheses. The ""then"" branch can be a single statement, or it can be a block of statements enclosed by curly braces. We recommend using blocks, as that makes it clear what is part of a branch and what isn't. For the ""else"" branch, we use the else keyword followed by a statement or block. We can also chain conditionals using else if:",'427,'99.26757813
'21,'Section header 14,"'double describe(int x)",'428,'37.93945313
'21,'Text 344,"'if (x < 0) { cout << ""negative"" endl; } else if (x > 0) { cout << ""positive"" << endl; } else { cout << ""zero"" << endl; } }",'429,'85.93750000
'21,'Text 345,"'At most one branch a conditional chain may execute.",'430,'90.82031250
'21,'Text 346,"'A for statement can be used to express a loop that repeats until some condition is false. Its syntax is as follows:",'431,'96.14257813
'21,'Text 347,"'for (<initialization>; <test>; <update>) { <body statements> }",'432,'88.42773438
'21,'Text 348,"'The initialization is run once at the beginning of the loop, and it can introduce new variables - the scope of such a variable is just the loop itself. The test is run before each iteration of the loop - if the test is true, the loop body runs, otherwise the loop exits. The update is run after each loop iteration completes.³ As with a conditional, the body may be a single statement or a block - we recommend the latter.",'433,'97.90039063
'21,'Text 349,"'As an example, let's compute the sum of the elements in a vector:",'434,'92.87109375
'21,'Text 350,"'vector<double> values = /* fill with some values */; double sum = O; for (size_t i = O; i < values.size(); ++i) { sum += values[i]; }",'435,'93.60351563
'21,'Text 351,"'We initialize a new variable i with value 0, representing the current index into the vector. We declare i to be of type size_t, SO that we don't get a compiler warning by comparing it against values.size(), which produces a size_t. We execute the loop body as long as our index i is less than the size of the vector. After each iteration, i gets incremented, and the loop exits once its value is equal to values.size().",'436,'97.46093750
'21,'Text 352,"'In addition to for loops, C++ has while loops, which are a simplification of for loops:",'437,'92.67578125
'21,'Text 353,"'while (<test>) { <body statements> }",'438,'95.70312500
'21,'Text 354,"'The loop will execute the body as long as the test is true, and it will exit when the test becomes false. We can translate our for loop above to a while loop as follows:",'439,'96.33789063
'21,'Section header 15,"'size_t i = 0;",'440,'49.12109375
'21,'Text 355,"'while (i < values.size()) { sum values [i] ;",'441,'83.64257813
'21,'Text 356,"'(continues on next page)",'442,'84.57031250
'21,'Text 357,"'3 Any of the initialization, test, or update may be omitted, but the semicolons separating them must still be present. If the test is omitted, it is assumed to always be true.",'443,'86.18164063
'21,'Page number 18,"'16",'444,'86.71875000
'22,'Header 16,"'Programming and Data Structures, Release 0.3",'445,'67.13867188
'22,'Text 358,"'(continued from previous page)",'446,'44.65332031
'22,'Header 17,"'++i;",'447,'46.19140625
'22,'Header 18,"'}",'448,'25.75683594
'22,'Text 359,"'Depending on the computation, it may be more naturally expressed using one loop construct or the other. In this case, iterating over the elements of a vector arguably is more cleanly expressed with a for loop than a while loop.",'449,'96.82617188
'22,'Text 360,"'In addition to the normal behavior of a loop, we further control execution through the loop with return, break, and continue statements. A return statement immediately exits the enclosing function. A break statement exits the (most inner) loop, proceeding past the loop:",'450,'96.72851563
'22,'Text 361,"'// Print elements until the first 0 for (size_t i = 0; < values. size ++i) { if (values[i] == 0) break; } cout << values [i] << endl ; }",'451,'94.72656250
'22,'Text 362,"'A continue statement skips the rest of the current loop iteration, but does not immediately exit the loop:",'452,'85.49804688
'22,'Text 363,"'// Print the square root of non-negative numbers for (size_t i = 0; i < v.size() ++i) { if (v[i] 0)) continue; } cout << v[i] << endl; }",'453,'96.58203125
'22,'Text 364,"'Often, a loop can be restructured to avoid break or continue statements, but in other cases, a computation may be more easily expressed using them. For the second loop above, we can rewrite it as follows:",'454,'96.82617188
'22,'Text 365,"'// Print the square root of non-negative numbers for (size_ti=0;i<v.size(); ++i) { if (v[i] >=0)) cout v[i] << endl; } }",'455,'97.02148438
'22,'Text 366,"'For the first loop that uses a break statement, we can use logical operations instead:",'456,'87.45117188
'22,'Text 367,"'// Print elements until the first 0 for (size_t i = O; < values. size( && values [i] != 0; ++i) { cout << values[i << endl; }",'457,'96.48437500
'22,'Text 368,"'We can use either && or and to specify a conjunction (an ""and"" of two conditions), either | I or or for a disjunction (an ""or"" of two conditions), and either ! or not to negate a truth value. Conjunction and disjunction are short-circuiting, meaning that the right-hand side will only be evaluated if necessary to compute the result. In our example here, values [i] ! = 0 only gets evaluated when i values.size() - good thing, because otherwise we could access an element past the end of the vector, producing the dreaded undefined behavior.",'458,'95.99609375
'22,'Page number 19,"'17",'459,'81.34765625
'23,'Header 19,"'CHAPTER",'460,'36.74316406
'23,'Header 20,"'FIVE",'461,'41.47949219
'23,'Title 8,"'PROCEDURAL ABSTRACTION",'462,'79.73632813
'23,'Text 369,"'Abstraction is the principle of separating what something is or does from how it does it. It is the primary tool for managing complexity in Computer Science and other fields. As a non-programming example, consider the task of making a sandwich. In order to make a sandwich, we don't need to know how bread is made, nor peanut butter nor jelly. All we need to know is how to put those ingredients together to construct a sandwich. Thus, we rely on the abstractions of bread, peanut butter, and jelly to make a sandwich. Similarly, the person who eats our sandwich doesn't need to know how it's made - all they need to know is that it is a delicious sandwich.",'463,'98.53515625
'23,'Figure 1,"",'464,'94.62890625
'23,'Text 370,"'Figure 5.1: Abstraction layers for making a sandwich.",'465,'93.70117188
'23,'Text 371,"'In a complex system, there are multiple layers of abstraction, each of which relies on the ""what"" knowledge of the lower layers without needing to know the ""how."" In the case of a sandwich, the top layer is the consumer of the sandwich, who only needs to know that it is a sandwich. The layer below is the maker of the sandwich, who needs to know what bread, peanut butter, and jelly are and how to combine them into a sandwich. They do not need to know how to make each of the ingredients. The jelly manufacturer needs to know how to combine fruit and other ingredients into a container and apply heat to make jelly. However, they do not need to know how to grow fruit. That's a farmer's job, who needs to know how to use plants, water, and pollinators in order to produce fruit.",'466,'97.46093750
'23,'Text 372,"'Computer programs are similarly built using layers of abstraction. When it comes to computational procedures, func- tions are our mechanism for defining procedural abstractions. The user of a function need only know what the function does without caring about how the function accomplishes its task. Specifically, the user needs to know the interface of the function, including its actual code interface and the documentation of what the function does. The user does not",'467,'96.77734375
'23,'Page number 20,"'18",'468,'89.69726563
'24,'Header 21,"'Programming and Data Structures, Release 0.3",'469,'62.59765625
'24,'Text 373,"'need to concern themselves with the implementation of the function, the actual details of how the function works.",'470,'94.87304688
'24,'Section header 16,"'5.1 Code Organization in C++",'471,'54.29687500
'24,'Text 374,"'In general, we organize a program by decomposing it into independent modules, defined in separate files. In C++, a single module is further decomposed into a header file and a source file. In this course, we will use the hpp extension for header files and the cpp extension for source files4. The header contains the interface of the module, while the source file contains the actual implementation.",'472,'97.65625000
'24,'Text 375,"'As an example, the following is a subset of stats. hpp from Project 1:",'473,'87.40234375
'24,'Text 376,"'#include <vector>",'474,'35.30273438
'24,'Text 377,"'//REQUIRES: V is not empty //EFFECTS: returns the arithmetic mean of the numbers in V double mean(std: : vector<double> v);",'475,'87.50000000
'24,'Text 378,"'Only a declaration of the mean( function appears in the header, along with its documentation. The actual definition goes in stats. cpp, the source file for the module:",'476,'95.94726563
'24,'Text 379,"'#include ""stats.hpp"" #include ""p1_library.hpp"" using namespace std;",'477,'78.12500000
'24,'Text 380,"'double mean(vector<double>v) return sum(v) / count(v); }",'478,'90.42968750
'24,'Text 381,"'Other source files that use the functions in the stats module need only include the header file (stats.hpp) with the #include directive:",'479,'95.60546875
'24,'Text 382,"'#include <iostream> #include ""stats.hpp"" using namespace std; int main() { vector<double> data = { 1, 2, 3 }; cout << mean(data) << endl; }",'480,'63.52539063
'24,'Text 383,"'A source file that uses the stats module only needs to know about the interface of the module. As long as the interface remains the same, the implementation of a module can change arbitrarily without affecting the behavior of a source file that uses it.",'481,'94.43359375
'24,'Text 384,"'The #include directive actually pulls in the code from the target into the current file. So the end result is as if the declarations for the stats functions actually were written in this source file as well. We get access to those functions' declarations without having to manually repeat them.",'482,'94.43359375
'24,'Text 385,"'Library modules such as vector and iostream are surrounded by angle brackets (e.g. #include <vector>) in a #include directive. Non-library headers that are located in the same directory are surrounded by double quotes (e.g.",'483,'91.65039063
'24,'Text 386,"'4 The extensions . .hxx and .h are other common conventions for header files, and CXX and CC are also common for source files.",'484,'80.56640625
'24,'Footer 9,"'5.1. Code Organization in C++",'485,'74.07226563
'24,'Page number 21,"'19",'486,'85.00976563
'25,'Header 22,"'Programming and Data Structures, Release 0.3",'487,'58.15429688
'25,'Text 387,"'#include ""stats.hpp""). For the purposes of this course, we never #include anything other than header files and standard libraries - we never #include a cpp source file.",'488,'98.68164063
'25,'Text 388,"'The using namespace std; directive allows us to refer to standard-library entities without prefixing them with std:: An alternative is to avoid the prefix for specific entities with individual using declarations:",'489,'98.14453125
'25,'Key value 13,"",'490,'48.24218750
'25,'Text 389,"'It is considered bad practice among C++ programmers to include a using namespace std; directive, or generally other using declarations, in a header file - this forces those directives and declarations on anyone who #includes the header. On the other hand, they are fine to place in a source file, since source files are generally not #included.",'491,'93.11523438
'25,'Text 390,"'The overall file structure for Project 1 is shown in Figure 5.2, excluding testing modules.",'492,'72.16796875
'25,'Figure 2,"",'493,'96.24023438
'25,'Text 391,"'Figure 5.2: File structure for Project 1.",'494,'94.33593750
'25,'Text 392,"'Arrows are shown between header files and the source files that #include them.",'495,'97.85156250
'25,'Text 393,"'When compiling the project, only source files are passed to the compiler. The header files are folding into the source files through the #include directives:",'496,'97.70507813
'25,'Text 394,"'$ g++ --std=c++17 -pedantic -g -Wall -Werror p1_library.cpp stats. cpp main. cpp -o main. -exe",'497,'94.38476563
'25,'Text 395,"'Any number of source files can be passed to the compiler, but only one of those may contain a main() function.",'498,'97.41210938
'25,'Footer 10,"'5.1. Code Organization in C++",'499,'87.89062500
'25,'Page number 22,"'20",'500,'84.66796875
'26,'Header 23,"'Programming and Data Structures, Release 0.3",'501,'58.59375000
'26,'Section header 17,"'5.2 The Compilation Process",'502,'79.68750000
'26,'Text 396,"'Consider the compilation command above. The elements of the command are:",'503,'93.06640625
'26,'List 9,"",'504,'91.74804688
'26,'Text 397 - Part of List 9,"'g++ is the C++ compiler we are invoking.",'505,'95.41015625
'26,'Text 398 - Part of List 9,"'The --std=c++17 argument tells it to compile according to the C++17 language standard.",'506,'95.50781250
'26,'Text 399 - Part of List 9,"'The -pedantic argument tells the compiler to adhere strictly to the C++ standard. Without this flag, compilers often provide extensions or allow behavior that is not permitted by the standard.",'507,'96.58203125
'26,'Text 400 - Part of List 9,"'The -g argument tells the compiler to produce an executable that facilitates debugging.",'508,'96.14257813
'26,'Text 401 - Part of List 9,"'The -Wall argument asks the compiler to generate warnings about possible programming errors.",'509,'95.16601563
'26,'Text 402 - Part of List 9,"'The -Werror argument configures the compiler to treat warnings as errors, SO that it does not compile code that has warnings.",'510,'95.80078125
'26,'Text 403 - Part of List 9,"'The arguments -0 main. exe tell the compiler to produce the output file main. exe.",'511,'92.72460938
'26,'Text 404 - Part of List 9,"'The remaining three arguments are the source files for our program - p1_library. stats. cpp, and main. cpp.",'512,'93.01757813
'26,'Text 405,"'For the source files, the compiler will compile each of them separately, producing temporary object files. It will then attempt to link the object files together into the output executable. The linking step can fail if:",'513,'88.57421875
'26,'Text 406,"'A function is declared and used in the source files, but no definition is found. For example, if the definition for percentile() is missing, a linker error such as the following results:",'514,'88.57421875
'26,'Text 407,"'Undefined symbols for architecture x86_64: ""percentile(std: 1: vector<double, std: _1::allocator<double> >, , double)"", +referenced from: _main in main-dc223c.o ld: symbol(s) not found for architecture x86_64 clang: error: linker command failed with exit code 1 (use -V to see invocation)",'515,'34.64355469
'26,'Text 408,"'Multiple definitions of the same function are found. For example, if we try to compile and link multiple source files that define a main() function, we get a linker error like the following:",'516,'85.59570313
'26,'Text 409,"'duplicate symbol _main in: /var/folders/gc/0lqwygqx381fmx9hhvj0373h0000gp/T/main-9eba7c.o /var/folders/gc/0lqwygqx381fmx9hhvj0373h0000gp/T/stats_tests-b74225.o ld: 1 duplicate symbol for architecture x86_64 clang: error: linker command failed with exit code 1 (use -V to see invocation)",'517,'79.44335938
'26,'Text 410,"'Upon success, the result of the linking step is the final program executable, main. exe for the compilation command above.",'518,'92.52929688
'26,'Section header 18,"'5.3 Specification Comments (RMEs)",'519,'77.92968750
'26,'Text 411,"'The interface of a function includes its signature, which consists of the function's name and parameter types. The return type of the function5 is also part of its interface. Another part of a function's interface is documentation about what it does, as in the following:",'520,'29.73632813
'26,'Text 412,"'5 Technically, the return type of a regular (i.e. non-template) function is not part of its signature as defined by the C++ standard (see [defns.signature] in the standard). It is, however, part of the function's interface.",'521,'70.06835938
'26,'Footer 11,"'5.2. The Compilation Process",'522,'50.09765625
'26,'Page number 23,"'21",'523,'88.08593750
'27,'Header 24,"'Programming and Data Structures, Release 0.3",'524,'61.96289063
'27,'Text 413,"'//REQUIRES: V is not empty //EFFECTS: returns the arithmetic mean of the numbers in V double mean(std: : vector<double> v);",'525,'77.92968750
'27,'Text 414,"'This documentation describes the what of the function, SO it is an integral part of what a user of the function needs to know.",'526,'97.26562500
'27,'Text 415,"'The documentation format we use in this course is an RME, which consists of a REQUIRES clause, a MODIFIES clause, and an EFFECTS clause.",'527,'96.43554688
'27,'Section header 19,"'5.3.1 REQUIRES Clause",'528,'89.30664063
'27,'Text 416,"'The REQUIRES clause lists what the function requires in order to accomplish its task. If the requirements are not met, then the function provides no guarantees - the behavior is undefined, and anything the function does (e.g. crashing your computer, stealing your credit-card info, etc.) is valid. Thus, a user should never call a function with arguments or in a state that violates the REQUIRES clause.",'529,'96.77734375
'27,'Text 417,"'Within the function definition, the implementation is allowed to assume that the REQUIRES clause is met - again, a user should never call the function if they are violated. A good practice is to assert that the REQUIRES clause is met, if it is possible to do SO:",'530,'96.58203125
'27,'Text 418,"'#include <cassert> #include ""stats.hpp"" #include ""p1_library.hpp"" using namespace std;",'531,'93.55468750
'27,'Text 419,"'double mean(vector<double> v) { assert ( v . empty()) ; return sum(v) / count (v) }",'532,'95.36132813
'27,'Text 420,"'In order to use assert, the <cassert> header must be included. Then a boolean expression can be passed to assert. If the expression evaluates to a true value, execution proceeds normally. However, if it evaluates to a false value, then the program crashes with a meaningful error message:",'533,'97.46093750
'27,'Text 421,"'Assertion failed: (!v. empty ()) , function mean, file stats.cpp, line 8.",'534,'92.52929688
'27,'Text 422,"'This is much more desirable than computing a wrong answer (or stealing your credit-card info!), as it tells the user they did something wrong and where the requirements were violated.",'535,'96.14257813
'27,'Text 423,"'If a function doesn't have any requirements, the REQUIRES clause may be elided. Such a function is called complete, while one that has requirements is called partial.",'536,'95.31250000
'27,'Footer 12,"'5.3. Specification Comments (RMEs)",'537,'87.79296875
'27,'Page number 24,"'22",'538,'82.91015625
'28,'Header 25,"'Programming and Data Structures, Release 0.3",'539,'48.43750000
'28,'Section header 20,"'5.3.2 MODIFIES Clause",'540,'92.23632813
'28,'Text 424,"'The MODIFIES clause specifies the entities outside the function that might be modified by it. This includes pass-by- reference parameters, global variables (not in this course - only global constants are permitted), and input and output streams (e.g. cout, cin, a file stream, etc.):",'541,'98.53515625
'28,'Text 425,"'//MODIFIES: V //EFFECTS: sorts V in ascending order void sort (std vector<double> &V) ;",'542,'91.30859375
'28,'Text 426,"'The MODIFIES clause only specifies what entities may be modified, leaving out any details about what those modifi- cations actually might be. The latter is the job of the EFFECTS clause. Instead, the purpose of the MODIFIES clause is for the user to quickly tell what items might be modified.",'543,'94.87304688
'28,'Text 427,"'If no non-local entities are modified, the MODIFIES clause may be elided.",'544,'92.04101563
'28,'Section header 21,"'5.3.3 EFFECTS Clause",'545,'93.50585938
'28,'Text 428,"'The EFFECTS clause specifies what the function actually does. This includes details about what modifications are made, if any, as well as what the return value means, if there is one. All functions should have an EFFECTS clause - if a function does nothing, there is no point to writing the function.",'546,'96.38671875
'28,'Text 429,"'The EFFECTS clause should generally only indicate what the function does without getting into implementation details (the how). It is part of the interface of a function, SO it should not be affected if the implementation were to change.",'547,'92.87109375
'28,'Section header 22,"'5.4 Properties of Procedural Abstraction",'548,'85.35156250
'28,'Text 430,"'As mentioned previously, the implementation of an abstraction should be able to change without affecting the way the abstraction is used. More formally, abstractions are substitutable - we should be able to swap out an implementation of an abstraction for a different one. As long as the interface remains the same, code that uses the abstraction will still work.",'549,'97.26562500
'28,'Text 431,"'Abstractions should also be local, meaning that it should be possible to understand the implementation of one abstrac- tion without knowing anything about the implementation of other abstractions. This implies that the implementation of one abstraction should not rely on implementation details of another - instead, the former should only work with the latter through the interface of the latter.",'550,'96.04492188
'28,'Footer 13,"'5.4. Properties of Procedural Abstraction",'551,'87.30468750
'28,'Page number 25,"'23",'552,'87.30468750
'29,'Text 432,"'CHAPTER",'553,'63.52539063
'29,'Text 433,"'SIX",'554,'62.59765625
'29,'Text 434,"'TESTING",'555,'88.23242188
'29,'Text 435,"'Testing is the primary mechanism we have for determining whether or not code is correct. Most programs are too complex to formally prove correct with reasonable effort. Instead, thorough testing provides a measure of confidence that the code behaves correctly.",'556,'96.77734375
'29,'Text 436,"'Insufficient testing can lead to code that breaks when deployed, with potentially disastrous consequences. A canonical example is the Therac-25, a radiation-therapy machine from the 1980s. A combination of poor design and software bugs led to several cases where patients received massive radiation overdoses. Three patients died as a result. A more recent example of software bugs leading to catastrophic failure is Knight Capital Group, a financial-services firm that engaged in high-frequency trading. Lack of regression testing, poor software maintenance, and a mistake in deployment caused a new version of their software to execute millions of trades that bought shares at high prices and sold them at lower ones - all in a span of just 45 minutes. The end result was a pre-tax loss of $440 million, and the company was forced to sell itself to a competitor.",'557,'97.16796875
'29,'Text 437,"'In this course, the stakes aren't quite as high as in the cases above. However, it is often the case that the difference between doing poorly on a project and doing well is how well you test your code. Testing is the mechanism for deter- mining whether or not code is buggy. Once a bug has been detected, debugging is the process used to identify and fix the source of the bug.",'558,'91.16210938
'29,'Text 438,"'There are two main categories of test cases:",'559,'81.34765625
'29,'List 10,"",'560,'79.05273438
'29,'Text 439 - Part of List 10,"'Unit tests test once piece of code at a time, often at the granularity of individual functions or small groups of functions. This helps to find bugs early as well as make them easier to debug, since a failed unit test identifies exactly which function is broken.",'561,'96.97265625
'29,'Text 440 - Part of List 10,"'System tests test an entire module or program as a whole. This can identify bugs that occur when integrating multiple units together - it's possible that two units appear to work individually, but one unit makes an incorrect assumption about the other that only manifests when they are tested together. System tests can also be closer to the real use case of a program, providing a measure of confidence that the program works as a whole.",'562,'96.82617188
'29,'Text 441,"'In software development, it is important to maintain a set of regression tests, or tests that are run every time a code change is made. That way, a breaking change is identified immediately and can be fixed before the software is deployed. Regression tests generally include both unit and system tests.",'563,'94.04296875
'29,'Text 442,"'Test-driven development is a common programming practice that integrates writing tests with developing the imple- mentation of a program. Once the interface of a unit has been determined, tests can be written even before the imple- mentation - that way, once the implementation is written, there are tests that can be run immediately. Furthermore, the process of writing tests can help inform the right strategy to use in implementation, reducing development time. The implementation in turn inspires new test cases, based on an understanding of what mistakes could have been made in the code. The result is an iterative process: writing tests for a unit, implementing the unit, writing more tests, fixing bugs, and SO on until the code has been thoroughly vetted.",'564,'96.38671875
'29,'Text 443,"'Only valid test cases should be written. Those that don't compile are useless, as well as those that result in undefined behavior (e.g. by violating the REQUIRES clause of a function). There are several types of valid test cases:",'565,'90.57617188
'29,'Page number 26,"'24",'566,'87.89062500
'30,'Header 26,"'Programming and Data Structures, Release 0.3",'567,'84.91210938
'30,'List 11,"",'568,'97.94921875
'30,'Text 444 - Part of List 11,"'Simple test cases are for the ""average"" case. For instance, in testing a mode () function in Project 1, an example of a simple test case is one that tests a vector that contains exactly one mode (e.g. { 1, 2, 3, 2 }).",'569,'96.14257813
'30,'Text 445 - Part of List 11,"'Edge cases are those that test special cases in a unit's behavior. For instance, the mode() function requires that its argument vector be non-empty. Thus, the smallest vector that can be passed to mode( is one with a single element - this is an edge case. Another special case is when the input has two modes - in this case, the documentation of the function specifies that it returns the smaller one. So we should test that the function indeed behaves correctly in this case.",'570,'97.65625000
'30,'Text 446 - Part of List 11,"'Stress tests are intensive tests that ensure that a system will work under a heavy load. For example, an autograder for a 1000-person course should be able to withstand hundreds of students trying to submit right before the deadline. Thus, it is important to test the autograder with large numbers of concurrent requests. Stress tests will not be used in this course, since the projects we will focus on are not performance-critical.",'571,'96.48437500
'30,'Text 447,"'Test cases should focus on cases that realistically could be erroneous. For example, a malicious programmer could insert a bug that only occurs for a specific, arbitrary input (e.g. if the number 42 is in the input). However, we generally can't test every possible input, SO we have to concentrate on those cases where a reasonable programmer could make a mistake. (Other mechanisms, such as code reviews, are used to guard against malicious programmers.)",'572,'95.84960938
'30,'Text 448,"'The small scope hypothesis states that thorough testing with ""small"" test cases is sufficient to catch most bugs in a system6. Thus, our test cases need not be large - in general, they should be small enough where we can compute the expected results by hand. Similarly, having more test cases is not necessarily better. Fewer test cases that are meaningfully different is more effective than having many, redundant test cases. As an example, the data sets { 1, 1, 2, 2, 2 } and { 1, 1, 2, 2, 2, 2 } are not meaningfully different for the mode () function - there is no good reason why it would behave differently in the two cases. On the other hand, the data set { 1, 1, 2, 2 } is meaningfully different, since it contains two modes.",'573,'97.26562500
'30,'Footer 14,"'6 See Evaluating the ""Small Scope Hypothesis"" by Andoni et al. and On the Small-Scope Hypothesis for Testing Answer-Set Programs by Oetsch et al. for empirical evaluations of the hypothesis.",'574,'82.56835938
'30,'Page number 27,"'25",'575,'93.06640625
'31,'Text 449,"'CHAPTER",'576,'40.20996094
'31,'Header 27,"'SEVEN",'577,'41.30859375
'31,'Title 9,"'MACHINE MODEL I",'578,'59.57031250
'31,'Text 450,"'A computer program consists of source code that determines what the program does. The program itself is run on a machine, and the program directs the machine on what computation should be preferred. In order to understand a program, it is important to have a machine model that helps us reason about how the source code relates to what happens at runtime.",'579,'98.68164063
'31,'Text 451,"'As an example, consider the following C++ program:",'580,'95.94726563
'31,'Text 452,"'int main() { int = double 4.1; int z = x; x = 5; }",'581,'95.94726563
'31,'Text 453,"'When the program runs, execution starts at main() Each variable in the program is a name that refers to some object in memory, a region of memory that holds the data value for the variable. The variable's type determines how much memory is required, and how the data are represented generally, data are stored in bytes, which themselves are sequences of eight bits, each of which is a binary digit that is zero or one. For instance, in typical C++ implementations, a variable of type int requires four bytes (32 bits) of storage, while one of type double requires eight bytes (64 bits).",'582,'96.58203125
'31,'Text 454,"'It is often useful to think of memory as a large array, with data values stored at different indices into the array, as shown in Figure 7.2.",'583,'92.04101563
'31,'Text 455,"'Here, the program is using memory index 6 for X, index 2 for y, and index 4 for z. (Later, we will see that a program uses a more systematic method for locating the local variables of a function.) The contents of memory illustrated above are after the initialization of X and y but before the initialization of z. The location for X has a representation of the int value 3, the location for y has a representation of the double value 4.1, and the location for Z has some indeterminate value.",'584,'96.67968750
'31,'Text 456,"'When the program proceeds to initialize z, it copies the value 3 from the memory for X into the memory for z, as demonstrated in Figure 7.3.",'585,'94.33593750
'31,'Text 457,"'Finally, the assignment X = 5 modifies the value of X to be 5, as Figure 7.4 illustrates.",'586,'92.04101563
'31,'Text 458,"'In order to discuss the conceptual spaces for source code and runtime in more detail, we need some terminology. In source code, a name refers to some entity such as a variable, function, or type. As mentioned above, a variable is a name that refers to an object in memory. A name has a scope, which determines what region of code can use that name to refer to an entity. For example, the scope of y in the code above begins at the declaration of y and ends at the end of the function definition for main(). Attempting to use y outside this region will result in a compiler error. A declaration is what introduces a name into the program and begins its scope.",'587,'97.16796875
'31,'Text 459,"'At runtime, an object is a piece of data in memory, and it is located at some address in memory (corresponding to the index in our basic machine model above). An object has a lifetime during which it is legal to use that object. More specifically, an object is created at some point in time, and at some later point in time it is destroyed. The storage duration of an object determines its lifetime. There are three options that we will see in C++:",'588,'95.84960938
'31,'Page number 28,"'26",'589,'79.29687500
'32,'Header 28,"'Programming and Data Structures, Release 0.3",'590,'87.06054688
'32,'Figure 3,"",'591,'96.63085938
'32,'Text 460,"'Memory",'592,'91.65039063
'32,'Text 461,"'Figure 7.1: Variables correspond to objects in memory, each of which stores a data value represented in binary.",'593,'96.48437500
'32,'Text 462,"'7",'594,'97.26562500
'32,'Text 463,"'6",'595,'98.63281250
'32,'Text 464,"'3",'596,'82.03125000
'32,'Text 465,"'5",'597,'93.31054688
'32,'Text 466,"'4",'598,'99.07226563
'32,'Text 467,"'3",'599,'97.46093750
'32,'Text 468,"'2",'600,'97.85156250
'32,'Text 469,"'1",'601,'97.75390625
'32,'Text 470,"'0",'602,'97.07031250
'32,'Text 471,"'X",'603,'97.80273438
'32,'Text 472,"'4.1",'604,'62.06054688
'32,'Text 473,"'Z",'605,'97.07031250
'32,'Text 474,"'y",'606,'96.97265625
'32,'Text 475,"'Figure 7.2: Simplified machine model, with memory as a linear (array) structure with slots for different objects.",'607,'96.92382813
'32,'Page number 29,"'27",'608,'88.28125000
'33,'Header 29,"'Programming and Data Structures, Release 0.3",'609,'77.44140625
'33,'Text 476,"'7",'610,'98.63281250
'33,'Text 477,"'6",'611,'97.55859375
'33,'Text 478,"'5",'612,'96.04492188
'33,'Figure 4,"",'613,'27.85644531
'33,'Text 479,"'4",'614,'95.36132813
'33,'Text 480,"'3",'615,'95.41015625
'33,'Text 481,"'2",'616,'95.45898438
'33,'Text 482,"'1",'617,'95.75195313
'33,'Text 483,"'0",'618,'95.89843750
'33,'Text 484,"'4.1",'619,'51.85546875
'33,'Text 485,"'X",'620,'80.81054688
'33,'Text 486,"'Figure 7.3: Initializing an object as a copy of another.",'621,'88.67187500
'33,'Text 487,"'3",'622,'32.64160156
'33,'Text 488,"'Z",'623,'88.03710938
'33,'Text 489,"'y",'624,'87.01171875
'33,'Text 490,"'7",'625,'90.91796875
'33,'Text 491,"'6",'626,'96.58203125
'33,'Text 492,"'5",'627,'95.75195313
'33,'Text 493,"'4",'628,'95.75195313
'33,'Text 494,"'3",'629,'92.91992188
'33,'Text 495,"'2",'630,'92.18750000
'33,'Figure 5,"",'631,'39.33105469
'33,'Figure 6,"",'632,'30.61523438
'33,'Text 496,"'1",'633,'90.72265625
'33,'Text 497,"'3",'634,'32.12890625
'33,'Text 498,"'0",'635,'92.28515625
'33,'Text 499,"'X",'636,'84.96093750
'33,'Text 500,"'4.1",'637,'43.57910156
'33,'Text 501,"'Z",'638,'82.66601563
'33,'Text 502,"'Figure 7.4: Modifying the value of an object.",'639,'88.96484375
'33,'Text 503,"'y",'640,'83.39843750
'33,'Page number 30,"'28",'641,'84.86328125
'34,'Header 30,"'Programming and Data Structures, Release 0.3",'642,'89.06250000
'34,'List 12,"",'643,'96.28906250
'34,'Text 504 - Part of List 12,"'static: the lifetime is essentially the whole program",'644,'97.85156250
'34,'Text 505 - Part of List 12,"'automatic (also called local): the lifetime is tied to a particular scope, such as a block of code",'645,'98.63281250
'34,'Text 506 - Part of List 12,"'dynamic: the object is explicitly created and destroyed by the programmer",'646,'98.33984375
'34,'Text 507,"'The former two durations are controlled by the compiler, while the latter is specified by the programmer. We will restrict ourselves to static and automatic storage duration until later in the course.",'647,'96.38671875
'34,'Text 508,"'A variable is not the same thing as a memory object: a variable is a concept associated with source code, while an object is associated with the runtime. The same variable can refer to different objects at different times, such as a local variable in a function that is called more than once. An object that has dynamic storage duration is not associated with a variable at all.",'648,'96.19140625
'34,'Text 509,"'An important consideration in the design of a language is the semantics of an initialization or assignment of the form X = y. Does this change which object X is referring to, or does it modify the value of the object that X is referring to? The first option is known as reference semantics, while the second is value semantics.",'649,'96.43554688
'34,'Text 510,"'In C++, the default is value semantics. Consider the following program:",'650,'94.18945313
'34,'Text 511,"'int x x 42; // initialize value of X to 42 int y = 99; // initialize value of y to 99 X y; // assign value of y to value of X",'651,'67.67578125
'34,'Text 512,"'The assignment in the last line copies the value stored in the memory object associated with y into the memory object for X, as shown in Figure 7.5.",'652,'95.99609375
'34,'Figure 7,"",'653,'90.42968750
'34,'Text 513,"'Figure 7.5: Assignment copies a value from the right-hand side into the left-hand-side object.",'654,'94.97070313
'34,'Text 514,"'C++ supports reference semantics only when initializing a new variable. Placing an ampersand (&) to the left of the new variable name causes the name to be associated with an existing object. The following is an example with a local variable:",'655,'98.24218750
'34,'Text 515,"'int X = 42; // initialize value of X to 42 int Z = 3; // initialize value of Z to 3 int &y = x; // y and X are now names for the same object X 24; // assigns 24 to object named x/y y z; // Does NOT re-bind y to a different object // Value semantics used here.",'656,'71.48437500
'34,'Text 516,"'The declaration int &y = X; introduces y as a new name for the object associated with X. Any subsequent modifi- cation to this object is reflected through both names, regardless of the name used to perform the modification. Figure 7.6 shows the effects of the assignments in the code above.",'657,'92.67578125
'34,'Text 517,"'Since C++ only supports reference semantics in initialization, the association between a variable and a memory object can never be broken, except when the variable goes out of scope.",'658,'86.37695313
'34,'Page number 31,"'29",'659,'88.23242188
'35,'Header 31,"'Programming and Data Structures, Release 0.3",'660,'79.49218750
'35,'Figure 8,"",'661,'79.24804688
'35,'Text 518,"'Figure 7.6: A reference is another name for an existing object.",'662,'91.25976563
'35,'Section header 23,"'7.1 Pointers",'663,'53.61328125
'35,'Text 519,"'Recall that in C++, an object is a piece of data in memory, and that it is located at some address in memory. The compiler and runtime determine the location of an object when it is created; aside from deciding whether an object is in the global segment, on the stack, or in the heap segment (the segment used for dynamic memory), the programmer generally does not control the exact location where an object is placed1. Given the same program and the same inputs to that program, different systems will often end up placing the same objects at different memory locations. In fact, in many implementations, running the same program twice on the same system will result in different addresses for the objects.",'664,'97.46093750
'35,'Text 520,"'Though the programmer does not have control over the address at which an object is located, the programmer does have the ability to query the address on an object once it has been created. In C++, the & (usually pronounced ""address-of"") operator can be applied to an object to determine its address:",'665,'95.89843750
'35,'Text 521,"'int main() int X = 3; double 5.5; cout<< &X<< endl; // sample output 0x7ffee0659a2c cout &y << endl; // sample output: 0x7ffee0659a20 }",'666,'68.60351563
'35,'Text 522,"'Addresses are usually written in hexadecimal (base-16) notation, with a leading Ox followed by digits in the range 0-9 and a-f, with a representing the value 10, b the value 11, and SO on. Most modern machines use 64 bits for an address; since each digit in a hexadecimal number represents four bits (24 = 16 values), a 64-bit address requires up to 16 hexadecimal digits. The examples above use only 12 digits, implying that the leading four digits are zeros. Most examples in this text use fewer digits for conciseness.",'667,'97.90039063
'35,'Text 523,"'In addition to being printed, addresses can also be stored in a category of objects called pointers2. A pointer variable can be declared by placing a * symbol to the left of the variable name in its declaration:",'668,'95.60546875
'35,'Text 524,"'int x = 3; int *ptr= &x; cout << ptr << endlt; // sample output: 0x7ffee0659a2c",'669,'50.97656250
'35,'Text 525,"'A pointer type consists of two elements:",'670,'87.69531250
'35,'List 13,"",'671,'88.23242188
'35,'Text 526 - Part of List 13,"'the type of the objects whose addresses the pointer can hold as a value. For example, an int * pointer can hold the address of an int, but not that of any other data type.",'672,'97.21679688
'35,'Text 527 - Part of List 13,"'the * symbol, which indicates that the type is a pointer",'673,'96.58203125
'35,'Text 528,"'Each data type in C++ has a corresponding pointer type. For instance, int * is the pointer type corresponding to int,",'674,'92.43164063
'35,'Text 529,"'1 C++ has placement new, which allows a programmer to initialize a new object in a given memory location. However, even with placement new, the original memory must have been allocated by the programmer, and the programmer does not control the exact address produced by that allocation.",'675,'85.83984375
'35,'Text 530,"'2 The terms address and pointer are often used interchangeably. Technically, a pointer is an object that holds an address as its value, while the address is the value itself.",'676,'74.70703125
'35,'Footer 15,"'7.1. Pointers",'677,'58.59375000
'35,'Page number 32,"'30",'678,'87.06054688
'36,'Header 32,"'Programming and Data Structures, Release 0.3",'679,'61.76757813
'36,'Text 531,"'double * is the pointer type corresponding to double, and double ** is the pointer type corresponding to double *.",'680,'98.38867188
'36,'Text 532,"'A pointer object can be dereferenced to obtain the object whose address the pointer is holding by applying the * (usually pronounced ""star"" or ""dereference"") operator:",'681,'97.16796875
'36,'Key value 14,"",'682,'83.54492188
'36,'Text 533,"'We often say that a pointer ""points to"" an object, and that the * operator ""follows"" the pointer to the object it is pointing at. In keeping with this terminology, a pointer is often pictured as an arrow from the pointer to the object it is pointing at, as shown in Figure 7.7.",'683,'95.75195313
'36,'Figure 9,"",'684,'95.99609375
'36,'Text 534,"'Figure 7.7: An arrow indicates the object whose address a pointer holds.",'685,'93.75000000
'36,'Text 535,"'Usually, we are not concerned with actual address values - they are implementation-dependent and can vary between program runs. Instead, we only concern ourselves with which object each pointer is referring to. Thus, we often draw just an arrow to illustrate which object a pointer is pointing to, as in Figure 7.8, without the actual address value.",'686,'98.04687500
'36,'Figure 10,"",'687,'92.67578125
'36,'Text 536,"'Figure 7.8: Pointers are often illustrated by just an arrow, without the actual address value.",'688,'97.55859375
'36,'Text 537,"'The following is another example of working with a pointer:",'689,'97.75390625
'36,'Key value 15,"",'690,'26.04980469
'36,'Footer 16,"'7.1. Pointers",'691,'51.07421875
'36,'Page number 33,"'31",'692,'88.57421875
'37,'Header 33,"'Programming and Data Structures, Release 0.3",'693,'48.24218750
'37,'Figure 11,"",'694,'28.58886719
'37,'Text 538,"'Figure 7.9: Example of modifying an object through a pointer.",'695,'78.07617188
'37,'Text 539,"'The code initializes the pointer bar with the address of foo. It proceeds to increment foo directly, then dereferences bar to increment the object it is pointing at. Since it is pointing at the object associated with foo, the result is that foo has value 3. The state of memory at each point is shown in Figure 7.9.",'696,'93.11523438
'37,'Section header 24,"'7.1.1 Pointers and References",'697,'70.99609375
'37,'Text 540,"'The * and & symbols mean different things when they are used as part of a type and when they are used in an expression:",'698,'89.50195313
'37,'List 14,"",'699,'79.05273438
'37,'Text 541 - Part of List 14,"'When used in a type, * means that the type is a pointer type, while & means the type is a reference type.",'700,'93.65234375
'37,'Text 542 - Part of List 14,"'When used as a unary prefix operator in an expression, * is used to dereference a pointer, while & is used to obtain the address of an object.",'701,'95.21484375
'37,'Text 543 - Part of List 14,"'When used as a binary infix operator, * is multiplication, while & is a bitwise and operation (which is outside the scope of this course).",'702,'93.55468750
'37,'Text 544,"'The following illustrates some examples:",'703,'76.75781250
'37,'Text 545,"'int x = 3; int *ptr = &x; int &ref = *ptr;",'704,'80.76171875
'37,'Text 546,"'In the second line, * is used in a type, SO ptr is a pointer to an int. The initialization is an expression, SO the & obtains the address of the object corresponding to X. In the third line, & is used as part of the type, SO ref is a reference variable. Its initialization is an expression, SO the * dereferences ptr to get to the object associated with X. The result is that ref is an alias for the same object as X.",'705,'94.77539063
'37,'Text 547,"'Pointers allow us to work indirectly with objects. The following is an implementation of a swap function that uses pointers to refer to the objects whose values to swap:",'706,'87.79296875
'37,'Table 6,"",'707,'49.31640625
'37,'Text 548,"'(continues on next page)",'708,'52.24609375
'37,'Section header 25,"'7.1. Pointers",'709,'38.50097656
'37,'Page number 34,"'32",'710,'90.57617188
'38,'Header 34,"'Programming and Data Structures, Release 0.3",'711,'55.71289063
'38,'Text 549,"'(continued from previous page)",'712,'66.35742188
'38,'Text 550,"'swap_pointed(&a, &b); cout a << endl; // prints 5 cout << endl; // prints 3 }",'713,'30.56640625
'38,'Text 551,"'Figure 7.10 demonstrates the execution of this code.",'714,'83.20312500
'38,'Figure 12,"",'715,'89.59960938
'38,'Text 552,"'Figure 7.10: Pointers enable redirection, allowing a function to modify objects in a different scope.",'716,'94.04296875
'38,'Text 553,"'References can also be used to indirectly refer to other objects. However, a pointer actually holds the address of another object, while a reference just acts as another name for an existing object. A reference must be initialized to refer to another object, and the association between the reference and its object cannot be broken. On the other hand, a pointer need not be initialized to point to an object, and the address value it holds can be later changed to be the address of a different object. A pointer can be null or have an undefined value, SO it must be used carefully to avoid undefined behavior. On the other hand, while it is possible to construct an invalid reference, it usually does not occur in the normal course of programming in C++.",'717,'98.19335938
'38,'Text 554,"'Both pointers and references allow objects to be used across scopes. They both enable subtype polymorphism, a concept we will see later in the course. Both can also be used to refer to objects in dynamic memory, as we will also see later.",'718,'97.16796875
'38,'Text 555,"'Pointers are strongly connected to arrays. Indexing into an array actually works through pointer arithmetic, as we will see later.",'719,'97.16796875
'38,'Footer 17,"'7.1. Pointers",'720,'89.59960938
'38,'Page number 35,"'33",'721,'90.33203125
'39,'Header 35,"'CHAPTER EIGHT",'722,'41.57714844
'39,'Title 10,"'MACHINE MODEL II",'723,'44.55566406
'39,'Section header 26,"'8.1 Pointer Errors",'724,'58.39843750
'39,'Text 556,"'A pointer is an atomic type, since it cannot be subdivided into smaller objects. As with other atomic types, a variable of pointer type that isn't explicitly initialized is default initialized to an undefined value:",'725,'95.36132813
'39,'Text 557,"'int X = 3; int *ptr; // undefined value ptr = &x; // well-defined value -- the address of X",'726,'60.59570313
'39,'Text 558,"'Dereferencing a default-initialized pointer results in undefined behavior - the program may crash, or it may not; reading the dereferenced value can result in zero, or some other random value. Undefined behavior is notoriously difficult to debug, as the behavior can be different on different machines or in different runs of the program on the same machine. Tools like Valgrind or an address sanitizer can help detect undefined behavior.",'727,'94.92187500
'39,'Text 559,"'The following is another example of default initializing pointers:",'728,'75.63476563
'39,'Table 7,"",'729,'26.58691406
'39,'Figure 13,"",'730,'39.13574219
'39,'Text 560,"'Stack",'731,'48.63281250
'39,'Text 561,"'Stack",'732,'39.33105469
'39,'Text 562,"'Stack",'733,'45.33691406
'39,'Text 563,"'Figure 8.1: Dereferencing an uninitialized pointer results in undefined behavior.",'734,'89.55078125
'39,'Text 564,"'Figure 8.1 illustrates the execution of this code. Both X and y are default initialized to indeterminate values. The code",'735,'93.26171875
'39,'Page number 36,"'34",'736,'88.62304688
'40,'Header 36,"'Programming and Data Structures, Release 0.3",'737,'60.69335938
'40,'Text 565,"'proceeds to assign the address of a into X, SO X now has a well-defined value, and it is valid to dereference X. Assigning to the object it is pointing at changes the value of that object, the one named by a. Dereferencing y, on the other hand, produces undefined behavior, since its value is a junk address. The program may crash, or it may not. It may overwrite a memory location that is in use by something else, or some location that is not in use. With undefined behavior, anything is possible.",'738,'98.97460938
'40,'Text 566,"'A null pointer is a pointer that holds an address value of OxO. No object can be located at that address, making the null value a useful value for a pointer that does not point to a valid object. In C++, the nullptr literal represents the null value, and it can be used with any pointer type:",'739,'97.11914063
'40,'Text 567,"'int *ptr1 = nullptr; double *ptr2 = nullptr; cout << (ptr1 == nullptr) << endl; // prints 1 (i.e. true)",'740,'85.30273438
'40,'Text 568,"'Dereferencing a null pointer also results in undefined behavior. However, in most implementations, doing SO will crash the program, which is generally easier to debug than other forms of undefined behavior.",'741,'96.09375000
'40,'Text 569,"'A null pointer is sometimes used to indicate the lack of a value, as in the following:",'742,'88.33007813
'40,'Text 570,"'// EFFECTS: Returns a pointer to the first string in vec of the given // length, or a null pointer if no such string is in vec. string * find_by_length(vector<string> &vec, int length) { for (size_t vec.size() ++i) { if (vec[i].size() == length) { return &vec[i]; } } return nullptr; // no string of given length } int main() { vector<string> v { { ""hello"", ""world"", ""from"", ""EECS"", ""280"" string *found = find_by_length(v, if (found) { // null pointer has false value cout << ""found string: "" << *found << endl; } else { cout << ""no such string"" << endl; } }",'743,'95.01953125
'40,'Text 571,"'In this example, the find_by_length() function returns a pointer to a string of the given length. However, if no such string exists, the function returns a null pointer to indicate this. The caller must check whether the return value is null before attempting to dereference it.",'744,'96.97265625
'40,'Text 572,"'Since a pointer is an object in its own right, it can live past the lifetime of the object it is pointing at. The following is an example:",'745,'96.38671875
'40,'Text 573,"'int * get_address(int x) { return &x; } void print(int val) { cout val << endl; }",'746,'56.49414063
'40,'Text 574,"'(continues on next page)",'747,'79.88281250
'40,'Footer 18,"'8.1. Pointer Errors",'748,'48.73046875
'40,'Page number 37,"'35",'749,'88.47656250
'41,'Header 37,"'Programming and Data Structures, Release 0.3",'750,'82.37304688
'41,'Header 38,"'(continued from previous page)",'751,'41.96777344
'41,'Text 575,"'int main() { int a = 3; int *ptr = get_address(a); print(42); cout << *ptr << endl; // UNDEFINED BEHAVIOR }",'752,'48.04687500
'41,'Figure 14,"",'753,'91.74804688
'41,'Text 576,"'Figure 8.2: A pointer may refer to a dead object, in which case dereferencing it produces undefined behavior.",'754,'92.48046875
'41,'Text 577,"'In this code, the parameter of the get_address( () function is passed by value. So the X parameter is a new object in the activation record for get_address (), and it is initialized as a copy of a. The function returns the address of X, and that value is placed in the ptr object in main(). However, X dies along with the activation record of get_address SO ptr is now pointing at a dead object. The code then calls print(), and it SO happens that its activation record is placed in the same location previously used by get_address(), as shown in Figure 8.2. At this point, ptr happens to point at the val object, whose value is 42. When the print () function returns, its activation record is also reclaimed. Proceeding to dereference ptr produces undefined behavior. It SO happens in this implementation that 42 is printed, but other implementations may have different behavior.",'755,'97.85156250
'41,'Text 578,"'We can fix the code above by passing the parameter to get_address by reference:",'756,'94.87304688
'41,'Text 579,"'int * get_address(int &x) { return &x; } void print(int val) { cout val << endl; } int main() { int a = 3; int *ptr = get_address(a); print(42); cout << *ptr << endl; // prints 3 }",'757,'64.89257813
'41,'Text 580,"'Now X aliases the object a in main(), as shown in Figure 8.3. Thus, get_address() returns the address of a, which is still alive when *ptr is printed.",'758,'96.04492188
'41,'Footer 19,"'8.1. Pointer Errors",'759,'70.99609375
'41,'Page number 38,"'36",'760,'91.40625000
'42,'Header 39,"'Programming and Data Structures, Release 0.3",'761,'47.75390625
'42,'Figure 15,"",'762,'95.36132813
'42,'Text 581,"'Figure 8.3: Example of taking the address of a reference parameter.",'763,'92.96875000
'42,'Section header 27,"'8.2 Function Calls and the Call Stack",'764,'80.17578125
'42,'Text 582,"'Previously, we saw a basic machine model in which the program places each object at a different location in mem- ory. We now examine a more structured model, stack-based memory management, that is used by many language implementations.",'765,'96.14257813
'42,'Text 583,"'In most implementations, the data for a function call are collectively stored within an activation record, which contains space for each of the function's parameters and local variables, temporary objects, the return address, and other items that are needed by the function. In this course, we will generally only consider the parameters and local variables in an activation record, ignoring the other pieces of data there.",'766,'95.99609375
'42,'Text 584,"'In stack-based memory management, activation records are stored in a data structure called a stack. A stack works just like a stack of pancakes: when a new pancake is made, it is placed on top of the stack, and when a pancake is removed from the stack, it is the top pancake that is taken off. Thus, the last pancake to be made is the first to be eaten, resulting in last-in, first-out (LIFO) behavior. Activation records are similarly stored: when an activation record is created, it is placed on top of the stack, and the first activation record to be destroyed is the last one that was created. This gives rise to an equivalent term stack frame for an activation record.",'767,'97.31445313
'42,'Text 585,"'As an example, consider the following program:",'768,'93.11523438
'42,'Text 586,"'void bar } void foo { bar(); } int main() { foo(); }",'769,'58.49609375
'42,'Text 587,"'When the program is run, the main() function is called, SO an activation record is created and added to the top of the stack. Then main () calls foo(), which places an activation record for foo () on the top of the stack. Then bar () is called, SO its activation record is put on the stack. When bar () returns, its activation record is removed from the stack. Then foo () completes, removing its activation record. Finally, the activation record for main() is destroyed when the function returns. Figure 8.4 shows the state of the stack after each call and return.",'770,'91.11328125
'42,'Text 588,"'In many implementations, the stack is actually stored upside down in memory, SO that it grows downward rather than upward as shown in Figure 8.5. However, it still has the same LIFO behavior as a right-side-up stack.",'771,'76.75781250
'42,'Text 589,"'As a more complex example, consider the following program:",'772,'56.78710938
'42,'Footer 20,"'8.2. Function Calls and the Call Stack",'773,'77.44140625
'42,'Page number 39,"'37",'774,'86.91406250
'43,'Header 40,"'Programming and Data Structures, Release 0.3",'775,'55.81054688
'43,'Figure 16,"",'776,'49.51171875
'43,'Text 590,"'Figure 8.5: A stack that grows downward rather than upward.",'777,'76.61132813
'43,'Text 591,"'int plus_one(int x) { return X + 1; } int plus_two(int X) { return plus_one(x + 1); } int main() { int result = 0 ; result = plus_one (0); result = plus_two(result), ; cout << result; // prints 3 }",'778,'73.09570313
'43,'Text 592,"'At program startup, the main( () function is called, creating an activation record that holds the single local variable result. The declaration of result initializes its value to 0, and the program proceeds to call plus_one(0). This creates an activation record for plus_one () that holds the parameter X. The program initializes the value of X to the argument value 0 and runs the body of plus_one(). The body computes the value of X + 1 by obtaining the value of X and adding 1 to it, resulting in a value of 1, which the function then returns. The return value replaces the original call to plus_one(0), and the activation record for plus_one is discarded before main( () proceeds. The code then assigns the return value of 1 to result. Figure 8.6 illustrates the activation records up to this point.",'779,'96.43554688
'43,'Text 593,"'The program then proceeds to call plus_two(result) First, result is evaluated to obtain the value 1. Then an activation record is created for plus_two(), with space for its parameter X. Observe that this activation record is located in memory where the previous activation record for plus_one() was - the latter is no longer in use, SO the memory can be reused. After the new activation record is created, the parameter X is initialized with the argument value 1. Then the program runs the body of plus_two().",'780,'95.65429688
'43,'Text 594,"'The body of plus_two() in turn calls plus_one(x + 1). This evaluates X + 1 to obtain the value 2, creates an activation record for plus_one(), initializes the value of X in the new activation record to be 2, and then runs the body of plus_one(). The state of memory at this point is shown in Figure 8.7.",'781,'93.40820313
'43,'Footer 21,"'8.2. Function Calls and the Call Stack",'782,'76.46484375
'43,'Page number 40,"'38",'783,'93.55468750
'44,'Header 41,"'Programming and Data Structures, Release 0.3",'784,'39.59960938
'44,'Figure 17,"",'785,'91.84570313
'44,'Text 595,"'Figure 8.7: State of stack in second call to plus_one().",'786,'82.71484375
'44,'Text 596,"'Observe that the new activation record for plus_one() is distinct from the previous one - - each invocation of a func- tion gets its own activation record. In addition, there are now two variables X in the program. Within the scope of plus_one (), X refers to the object located in the activation record for plus_one(), and its value is 2. Within plus_two(), X refers to the object in the activation record for plus_two(), and its value is 1.",'787,'94.58007813
'44,'Text 597,"'The invocation of plus_one( computes 3 as its return value, SO that value replaces the call to plus_one (), and the activation record for plus_one() is discarded. plus_two() returns that same value 3, SO the value 3 replaces the call to plus_two () in main(), and the activation record for plus_two() is discarded. Then main proceeds to assign the value 3 to result and print it out. Finally, when main() returns, its activation record too is discarded.",'788,'88.13476563
'44,'Section header 28,"'8.2.1 Function-Call Process",'789,'65.67382813
'44,'Text 598,"'To summarize, the following steps occur in a function call:",'790,'89.25781250
'44,'List 15,"",'791,'74.56054688
'44,'Text 599 - Part of List 15,"'1. For pass-by-value parameters, the argument expressions are evaluated to obtain their values.",'792,'56.20117188
'44,'Text 600 - Part of List 15,"'For a pass-by-reference parameter, the corresponding argument expression is evaluated to obtain an object rather than its value.",'793,'61.96289063
'44,'Text 601 - Part of List 15,"'The order in which arguments are evaluated is unspecified in C++.",'794,'68.06640625
'44,'Text 602 - Part of List 15,"'2. A new and unique activation record is created for the call, with space for the function's parameters, local variables, and metadata. The activation record is pushed onto the stack.",'795,'86.18164063
'44,'Text 603 - Part of List 15,"'3. The parameters are passed, using the corresponding arguments to initialize the parameters. For a pass-by-value parameter, the corresponding argument value is copied into the parameter. For a pass-by-reference parameter,",'796,'87.89062500
'44,'Text 604,"'1 C++ allows references to const to bind to values (i.e. rvalues in programming-language terms) rather than objects (lvalues). So a reference of type const int & can bind to just the value 3, as in const int &ref = 3;.",'797,'76.36718750
'44,'Footer 22,"'8.2. Function Calls and the Call Stack",'798,'86.08398438
'44,'Page number 41,"'39",'799,'89.74609375
'45,'Header 42,"'Programming and Data Structures, Release 0.3",'800,'84.03320313
'45,'Text 605,"'the parameter is initialized as an alias of the argument object.",'801,'95.41015625
'45,'List 16,"",'802,'94.58007813
'45,'Text 606 - Part of List 16,"'4. The body of the called function is run. This transfer of control is often called active flow, since the code actively tells the computer which function to run.",'803,'97.65625000
'45,'Text 607 - Part of List 16,"'5. When the called function returns, if the function returns a value, that value replaces the function call in the caller.",'804,'97.70507813
'45,'Text 608 - Part of List 16,"'6. The activation record for the called function is destroyed. In simple cases, implementations will generally just leave in memory what is already there, simply marking the memory as no longer in use.",'805,'98.24218750
'45,'Text 609 - Part of List 16,"'7. Execution proceeds from the point of the function call in the caller. This transfer of control is often called passive flow, since the code does not explicitly tell the computer which function to run.",'806,'98.33984375
'45,'Text 610,"'The following program is an example of pass by reference:",'807,'86.42578125
'45,'Text 611,"'void swap(int &x, int &y) { int tmp = : x; X y; y = tmp; } int main() { int a = 3; int b=7; cout a << endl; // prints 3, 7 swap(a) b); cout endl; // prints 7, 3 }",'808,'55.81054688
'45,'Text 612,"'The program starts by creating an activation record for main(), with space for the local variables a and b. It initializes a to 3 and b to 7 and then prints out their values. The program then calls swap (a, b), which evaluates the expressions a and b to obtain their objects, creates an activation record for swap(), and initializes the parameters from the argument objects. Since the two parameters are references, the activation record does not contain user-accessible memory for the parameters. (The metadata for the function, however, may include information about the parameters.) The activation record does contain explicit space for the local variable tmp, since it is not a reference. Figure 8.8 illustrates the activation record.",'809,'93.79882813
'45,'Figure 18,"",'810,'77.53906250
'45,'Text 613,"'Figure 8.8: Activation record for a function that uses pass by reference.",'811,'84.71679688
'45,'Text 614,"'Here, the reference parameters are depicted with a dotted line between the names and the objects they reference.",'812,'87.59765625
'45,'Text 615,"'The program proceeds to run the body of swap(). First, tmp is initialized to the value of X- since X refers to the same object as a in main (), the value 3 of that object is copied into the memory for tmp. Then the assignment X = y copies",'813,'85.30273438
'45,'Footer 23,"'8.2. Function Calls and the Call Stack",'814,'86.57226563
'45,'Page number 42,"'40",'815,'92.48046875
'46,'Header 43,"'Programming and Data Structures, Release 0.3",'816,'66.99218750
'46,'Text 616,"'the value 7 from the object associated with y (b in main()) to the object associated with X (a in main()). Finally, the assignment y = tmp copies the value 3 from tmp into the object associated with y (b in main ()). When swap () returns, its activation record is destroyed, and execution continues in main(). The latter prints out the new values of 7 and 3 for a and b, respectively.",'817,'99.16992188
'46,'Text 617,"'A function can also return an object by reference, though we need to ensure that the lifetime of the object extends beyond the function invocation. The following is an example:",'818,'97.85156250
'46,'Text 618,"'int & larger (int &x, int &y) { if (y x x) { return y; } return x; } int main() { int a = 3; int b=7 7; cout << a<< "",""<<b<< endl; // prints 3, 7 larger(a, b) = -1; cout a << << b << endl; // prints 3, -1 }",'819,'65.67382813
'46,'Text 619,"'The call larger(a, b) returns the object a or b whose value is larger, and we then assign the new value -1 to this object. If larger() were to return by value instead, attempting to assign to the resulting value would result in a compiler error.",'820,'95.65429688
'46,'Text 620,"'Returning by reference is most common in data structures, where we wish to access an element by reference. For instance, this is how the indexing (or subscript) operator works on a vector:",'821,'95.06835938
'46,'Text 621,"'std: :vector<int> data = /*...*/; data[0]===1",'822,'88.72070313
'46,'Text 622,"'This operator is implemented using operator overloading, which we will discuss later.",'823,'95.84960938
'46,'Footer 24,"'8.2. Function Calls and the Call Stack",'824,'87.69531250
'46,'Page number 43,"'41",'825,'88.47656250
'47,'Title 11,"'Part II Data Abstraction",'826,'35.35156250
'47,'Page number 44,"'42",'827,'90.67382813
'48,'Header 44,"'CHAPTER",'828,'54.19921875
'48,'Header 45,"'NINE",'829,'47.16796875
'48,'Title 12,"'THE CONST KEYWORD",'830,'76.95312500
'48,'Text 623,"'The const keyword is a type qualifier in C++ that allows us to prevent an object from being modified. As an example, consider the following erroneous definition of strcpy",'831,'98.63281250
'48,'Text 624,"'void strcpy (char *dst, const char *src) { while (*src !='\0') *src = *dst; ++src; ++dst; } *src = *dst; }",'832,'90.57617188
'48,'Text 625,"'In this definition, the assignments are backwards - the code is attempting to modify the source string rather than the destination. However, because the src parameter was declared with type const char *, the compiler will detect this error:",'833,'96.53320313
'48,'Text 626,"'$ g++ --std=c++17 strcpy.cpp strcpy.cpp:3:10: error: read-only variable is not assignable *src = *dst; NNNN strcpy.cpp: 7:8: error: read-only variable is not assignable *src = *dst; A 2 errors generated.",'834,'93.65234375
'48,'Text 627,"'A variable declared as const can be initialized, but its value cannot be later modified through an assignment. For a simple type, the const keyword may appear on either side of the type:",'835,'95.75195313
'48,'Text 628,"'const int X = 3; // initialization is OK int const y = 4; // const can go on the right as well x = y ; // ERROR: attempt to assign to const object",'836,'52.73437500
'48,'Text 629,"'Only types with values may be declared as const. The following types do not have values:",'837,'95.89843750
'48,'List 17,"",'838,'90.23437500
'48,'Text 630 - Part of List 17,"'References; they alias objects that may have values but do not have values of their own.",'839,'97.46093750
'48,'Text 631 - Part of List 17,"'Arrays; we will see arrays later in the course.",'840,'96.72851563
'48,'Text 632 - Part of List 17,"'Functions; we will see function types later in the course.",'841,'97.31445313
'48,'Page number 45,"'43",'842,'83.44726563
'49,'Header 46,"'Programming and Data Structures, Release 0.3",'843,'79.58984375
'49,'Section header 29,"'9.1 References and const",'844,'49.51171875
'49,'Text 633,"'We saw previously that the binding between a reference and the object it aliases is established at initialization, and it cannot be broken as long as the reference exists. Thus, it is not meaningful for a reference itself to be const.",'845,'97.75390625
'49,'Text 634,"'While a reference does not have a value and thus cannot be declared as const itself, it can refer to an object with const type. The const keyword can appear to the left of the & in a reference type, as in const int & - this is read ""inside out"" as ""reference to a constant int"". The object the reference is aliasing is not modifiable through the reference:",'846,'97.46093750
'49,'Table 8,"",'847,'39.03808594
'49,'Text 635,"'However, the original object is still modifiable if there is a non-const way to refer to it:",'848,'94.62890625
'49,'Table 9,"",'849,'70.06835938
'49,'Text 636,"'The example above has three names that refer to the same object. However, the object is only modifiable through the names that do not include the const keyword.",'850,'96.77734375
'49,'Text 637,"'In the two previous examples, we have created reference-to-const aliases for a non-const object. We will see shortly that non-const to const conversions are allowed, but the other direction is prohibited.",'851,'96.33789063
'49,'Section header 30,"'9.2 Pointers and const",'852,'91.79687500
'49,'Text 638,"'Pointers do have a value, SO they can be declared as const. To do so, the const keyword is placed to the right of the *:",'853,'97.90039063
'49,'Text 639,"'int X = 3; int y = 4; int * const ptr = &x; *ptr = -1; // OK ptr is pointing to a non-const int ptr = &y; // ERROR attempt to assign to const object",'854,'82.08007813
'49,'Text 640,"'Reading the declaration of ptr inside out, we get ""ptr is a constant pointer to an int."" Thus, we cannot modify the value of ptr itself. However, since the type that ptr is pointing to (what is to the left of the *) is not const, we can modify the object that ptr is pointing to.",'855,'97.55859375
'49,'Text 641,"'Similar to a reference, we can declare that the object that a pointer is pointing to is const by placing the const keyword to the left of the *:",'856,'96.87500000
'49,'Text 642,"'int X = 3; int y = 4; const int * ptr = &x; // equivalent: int const *ptr = &x; ptr = &y ; // OK -- ptr is not const, so we can change its value *ptr = -1; // ERROR -- attempt to assign to const object",'857,'78.66210938
'49,'Text 643,"'Finally, we can declare that both the pointer itself and the object it is pointing to are const:",'858,'89.89257813
'49,'Footer 25,"'9.1. References and const",'859,'56.20117188
'49,'Page number 46,"'44",'860,'80.85937500
'50,'Header 47,"'Programming and Data Structures, Release 0.3",'861,'82.27539063
'50,'Header 48,"'int x = 3; int y = 4; const int * const ptr = &x; ptr = &y ; // ERROR attempt to assign to const object *ptr = -1; // ERROR attempt to assign to const object",'862,'49.60937500
'50,'Title 13,"'9.3 const Conversions",'863,'55.46875000
'50,'Text 644,"'We've seen examples above where we've constructed references-to-const and pointers-to-const objects from objects that were not declared as const. The general rule for converting between const and non-const is that the conversion must not enable modifications that are prohibited without the conversion.",'864,'95.94726563
'50,'Text 645,"'A const object can appear on the right-hand side of an assignment, since an assignment has value semantics - it copies the value from the right-hand side to the left-hand side object. Thus, it does not permit the const object to be modified:",'865,'91.74804688
'50,'Text 646,"'const int x = 3; int y = // OK -- copies value from X; does not enable X to be modified",'866,'62.50000000
'50,'Text 647,"'On the other hand, if we initialize a reference-to-non-const with a const object, we would enable the object to be modified through the reference. Thus, such a conversion is prohibited:",'867,'96.53320313
'50,'Table 10,"",'868,'37.84179688
'50,'Text 648,"'The same goes for placing the address of a const object in a pointer-to-non-const:",'869,'97.11914063
'50,'Table 11,"",'870,'41.47949219
'50,'Text 649,"'The other direction is allowed, however: creating a reference-to-const or pointer-to-const from a non-const object does not enable any new modifications:",'871,'97.46093750
'50,'Table 12,"",'872,'46.87500000
'50,'Text 650,"'The compiler only reasons about each conversion in isolation. This means that it does not allow a conversion from const to non-const even if we have some other means of modifying the underlying object:",'873,'97.26562500
'50,'Text 651,"'int x = 3; int *ptr1 = &x; // OK does not permit const object to be modified const int *ptr2 = ptr1; // OK does not permit const object to be modified ptr1 = ptr2; // ERROR compiler sees that ptr2 is pointing to a // a const object, but ptr1 is not a pointer // to const",'874,'38.98925781
'50,'Text 652,"'In the example above, even though ptr2 was originally initialized from ptr1, we cannot later assign the value of ptr2 to ptrl, since it would be converting a pointer-to-const to a pointer-to-non-const. This is actually useful for us as programmers: if we pass a pointer to another function, and the function guarantees that it won't modify the pointed-to",'875,'96.92382813
'50,'Footer 26,"'9.3. const Conversions",'876,'73.58398438
'50,'Page number 47,"'45",'877,'85.74218750
'51,'Header 49,"'Programming and Data Structures, Release 0.3",'878,'53.12500000
'51,'Text 653,"'object by declaring its parameter as pointer-to-const, then we would be unhappy if the function could convert it back to a pointer-to-non-const and modify the pointed-to object. 1",'879,'55.17578125
'51,'Text 654,"'1 C++ has a const. cast that enables const to be removed or added. However, it is only used in exceptional cases, none of which are relevant to this course.",'880,'43.31054688
'51,'Footer 27,"'9.3. const Conversions",'881,'73.58398438
'51,'Page number 48,"'46",'882,'83.05664063
'52,'Text 655,"'CHAPTER",'883,'36.05957031
'52,'Text 656,"'TEN",'884,'33.15429688
'52,'Text 657,"'STRUCTS",'885,'60.20507813
'52,'Text 658,"'C++ has several different categories of objects:",'886,'74.60937500
'52,'List 18,"",'887,'82.08007813
'52,'Text 659 - Part of List 18,"'Atomic types are built into the language, and these types are atomic because their objects cannot be subdivided into smaller objects. Atomic types are also known as primitive types. Examples of atomic types include basic numeric types such as int, double, bool, and char, as well as pointer types (e.g. int *, string *).",'888,'97.11914063
'52,'Text 660 - Part of List 18,"'Arrays are contiguous sequences of objects of the same type. They are therefore composed of homogeneous subobjects. We will discuss arrays later in the course.",'889,'97.07031250
'52,'Text 661 - Part of List 18,"'Class-type objects are objects composed of member subobjects, each which may be of a different type. Class-type objects are thus heterogeneous, and they are also often called compound objects.",'890,'96.09375000
'52,'Text 662,"'In C++, a class type is introduced through the struct or class keyword. We will use the two keywords for different conventions when introducing our own data types. Later, we will see that the actual distinction between how C++ treats the two keywords is minimal.",'891,'96.09375000
'52,'Text 663,"'In order to introduce a new data type, we use the struct keyword, followed by the name of the type we are introducing, followed by a body with member declarations:",'892,'91.25976563
'52,'Section header 31,"'struct Person {",'893,'37.57324219
'52,'Text 664,"'string name; int age; bool is_ninja; };",'894,'90.08789063
'52,'Text 665,"'Here, we are introducing a Person type. The body contains declarations for three member variables, each with their own type and name. The semicolon after the struct definition is mandatory, unlike in some other languages.",'895,'95.45898438
'52,'Text 666,"'After the struct definition, we can create objects that have Person type. The following program creates two local variables of type Person:",'896,'94.72656250
'52,'Text 667,"'int main() { Person elise; Person tali; }",'897,'93.79882813
'52,'Text 668,"'Each Person object has its own subobjects name, age, and is_ninja located within the memory for the Person object, as shown in Figure 10.1.",'898,'91.40625000
'52,'Text 669,"'Since we did not explicitly initialize the Person objects, they are default initialized by in turn default initializing their member subobjects. The age and is_ninja members are of atomic type, SO they are default initialized to indeterminate values. The name member is of class type, and it is default initialized to an empty string. In the future, we will see that class types can specify how they are initialized.",'899,'95.26367188
'52,'Page number 49,"'47",'900,'80.27343750
'53,'Header 50,"'Programming and Data Structures, Release 0.3",'901,'37.57324219
'53,'Table 13,"",'902,'56.20117188
'53,'Text 670,"'Stack",'903,'69.09179688
'53,'Text 671,"'Figure 10.1: Memory for two objects of Person type.",'904,'93.06640625
'53,'Text 672,"'We can explicitly initialize a Person object with an initializer list, similar to how we can initialize the elements of a vector:",'905,'97.21679688
'53,'Text 673,"'Person elise = { ""Elise"", 22, true };",'906,'92.91992188
'53,'Text 674,"'This initializes the struct member-by-member from the initializer list: the name member is initialized with ""Elise"", the age member is initialized with 22, and the is_ninja member is initialized with true. If fewer initializers are provided than members, the remaining members are implicitly initialized (with zeros for atomic types).",'907,'97.41210938
'53,'Text 675,"'We can also copy structs when initializing a new struct or assigning to an existing one:",'908,'92.33398438
'53,'Text 676,"'Person tali = elise;",'909,'90.23437500
'53,'Text 677,"'By default, copying a struct copies the members one by one. 2 The result in memory is illustrated in Figure 10.2.",'910,'75.78125000
'53,'Text 678,"'We can access individual members of a struct with the dot (.) operator. The struct object goes on the left-hand side, and the member name on the right:",'911,'85.05859375
'53,'Text 679,"'tali.name = ""Tali"";",'912,'69.77539063
'53,'Text 680,"'Here, we have assigned the string ""Tali"" to the name member of the tali object. Figure 10.3 shows the result in memory.",'913,'95.70312500
'53,'Text 681,"'As the figure shows, tali and elise each have their own name members, SO that modifying one does not affect the other.",'914,'94.43359375
'53,'Text 682,"'We can use an initializer list for a struct in contexts other than initialization. The following uses an initializer list in an assignment (which is different from an initialization, since the target object already exists), as well as an argument to a function:",'915,'96.04492188
'53,'Text 683,"'void Person_print_name (Person person) { cout << person.name << endl;",'916,'54.10156250
'53,'Text 684,"'(continues on next page)",'917,'51.85546875
'53,'Text 685,"'2 We will see in the future that we can customize how class types are copied by overloading the copy constructor and assignment operator.",'918,'41.87011719
'53,'Page number 50,"'48",'919,'80.37109375
'54,'Header 51,"'Programming and Data Structures, Release 0.3",'920,'50.39062500
'54,'Table 14,"",'921,'86.32812500
'54,'Text 686,"'Stack",'922,'65.03906250
'54,'Text 687,"'Figure 10.2: By default, copying a class-type object copies each of the member variables.",'923,'97.41210938
'54,'Table 15,"",'924,'76.95312500
'54,'Text 688,"'Stack",'925,'74.16992188
'54,'Text 689,"'Figure 10.3: The result of modifying an individual member variable.",'926,'95.11718750
'54,'Page number 51,"'49",'927,'87.30468750
'55,'Header 52,"'Programming and Data Structures, Release 0.3",'928,'54.49218750
'55,'Text 690,"'(continued from previous page)",'929,'47.75390625
'55,'Text 691,"'}",'930,'42.16308594
'55,'Text 692,"'int main() { Person tali; tali = { ""Tali"", 21, true }; // in an assignment Person_print_name ({ ""Elise"", 22, true }); // as argument to function }",'931,'52.44140625
'55,'Text 693,"'When passing a struct to a function, we have our usual default of value semantics, meaning that a copy is made. For instance, the following erroneous definition of Person_birthday() does not modify the argument object, since it receives a copy of the argument:",'932,'93.60351563
'55,'Text 694,"'// MODIFIES: person // EFFECTS: Increases the person's age by one. If they are now older // than 70, they are no longer a ninja. void Person_birthday (Person person) { ++person.age; if (person.age > 70) { person.is_ninja = false; }",'933,'47.26562500
'55,'Text 695,"'Figure 10.4 illustrates what happens when we call Person_birthday() on a Person object:",'934,'80.61523438
'55,'Table 16,"",'935,'59.08203125
'55,'Text 696,"'Stack",'936,'71.14257813
'55,'Text 697,"'Figure 10.4: Passing a class-type object by value produces a copy that lives in the activation record of the callee.",'937,'97.80273438
'55,'Text 698,"'The modification happens on a Person object that lives in the activation record for Person_birthday (). This copy will die when Person_birthday () returns, and the object that lives in main () is unchanged.",'938,'96.82617188
'55,'Text 699,"'Instead, we need to pass the struct indirectly, either using a reference or a pointer. The following uses a pointer, and its execution is shown in Figure 10.5:",'939,'95.75195313
'55,'Page number 52,"'50",'940,'87.79296875
'56,'Header 53,"'Programming and Data Structures, Release 0.3",'941,'56.59179688
'56,'Text 700,"'// REQUIRES: ptr points to a valid Person object // MODIFIES: *ptr // EFFECTS: Increases the person's age by one. If they are now older // than 70, they are no longer a ninja. void Person_birthday(Person *ptr) +(*ptr).age; if ((*ptr).age > 70) { (*ptr).is_ninja = false; } }",'942,'53.02734375
'56,'Figure 19,"",'943,'76.90429688
'56,'Text 701,"'Stack",'944,'85.05859375
'56,'Text 702,"'Figure 10.5: Passing a pointer to a class-type object avoids making a copy of that object.",'945,'94.82421875
'56,'Text 703,"'The code uses the * operator to dereference the pointer, then uses the . operator to access a member of the resulting Person object. The parentheses around the dereference are required because the postfix . has higher precedence than the prefix *",'946,'97.46093750
'56,'Text 704,"'C++ provides the -> operator as a shorthand for dereference followed by member access. The following definition of rson_birthday () is equivalent to the one above:",'947,'96.14257813
'56,'Section header 32,"'void Person_birthday (Person *ptr) {",'948,'32.98339844
'56,'Text 705,"'++ptr->age; if (ptr->age > 70) { ptr->is_ninja = false; } }",'949,'95.21484375
'56,'Text 706,"'Of course, this one is nicer to read and to write, SO we should make use of the -> operator when possible.",'950,'92.18750000
'56,'Text 707,"'The Person_birthday( function needs to modify the underlying Person object, SO we cannot declare the Person as const. If a function does not need to modify the underlying object, then it should be declared as const. Declaring a struct as const prevents any of its members from being modified.",'951,'97.02148438
'56,'List 19,"",'952,'79.58984375
'56,'Text 708 - Part of List 19,"'// REQUIRES: ptr points to a valid Person object",'953,'95.50781250
'56,'Text 709 - Part of List 19,"'// MODIFIES: nothing",'954,'90.96679688
'56,'Text 710 - Part of List 19,"'// EFFECTS: Prints a one-sentence description of the person",'955,'86.96289063
'56,'Text 711 - Part of List 19,"'void Person_describe(const Person *ptr) {",'956,'70.80078125
'56,'Text 712,"'(continues on next page)",'957,'51.17187500
'56,'Page number 53,"'51",'958,'90.38085938
'57,'Header 54,"'Programming and Data Structures, Release 0.3",'959,'57.56835938
'57,'Text 713,"'(continued from previous page)",'960,'71.92382813
'57,'Text 714,"'cout ptr->name << "" is "" << ptr->age "" << "" years old and ""; if (ptr->is_ninja) { cout << ""is a ninja!"" << endl; } else { cout << ""is not a ninja."" << endl; } }",'961,'75.48828125
'57,'Text 715,"'Except for very small structs, we generally do not pass structs by value, since creating a copy of a large struct can be expensive. Instead, we pass them by pointer or by reference. If the original object needs to be modified, we use a pointer or reference to non-const. Otherwise, we use a pointer or reference to const:",'962,'95.50781250
'57,'Text 716,"'void func_ptr(const Person *p); // const can go on either side of void func_ref(Person const &p) ; // Person, but must be to the left // of * or & for the Person itself // to be non-modifiable",'963,'28.80859375
'57,'Section header 33,"'10.1 Compound Objects and const",'964,'83.69140625
'57,'Text 717,"'Since a class-type object has a value, it can be declared as const, which prevents any of its members from being modified. As an example, consider the following struct definition:",'965,'97.41210938
'57,'Text 718,"'struct Foo { int num; int *ptr; };",'966,'69.18945313
'57,'Text 719,"'Like any const object, a const Foo must be initialized upon creation:",'967,'95.50781250
'57,'Text 720,"'int main() { int X = 3; const Foo foo = { 4, &x }; }",'968,'94.18945313
'57,'Figure 20,"",'969,'87.01171875
'57,'Text 721,"'Stack",'970,'67.72460938
'57,'Text 722,"'Figure 10.6: Contents of a Foo object. Declaring the object as const only prohibits modifications to the subobjects contained within the memory for the object.",'971,'96.14257813
'57,'Footer 28,"'10.1. Compound Objects and const",'972,'63.33007813
'57,'Page number 54,"'52",'973,'86.08398438
'58,'Title 14,"'Programming and Data Structures, Release 0.3",'974,'39.99023438
'58,'Text 723,"'With foo declared as const, attempting to modify any of its members results in a compile error:",'975,'97.70507813
'58,'Text 724,"'foo.num = -1; // ERROR ++foo.ptr; // ERROR",'976,'70.06835938
'58,'Text 725,"'Modifications cannot be made to any of the subobjects that live within the memory of an object declared const. 3 On the other hand, it is possible to modify the object that foo. ptr points to:",'977,'86.27929688
'58,'Text 726,"'*foo.ptr = -1; cout x; // prints -1",'978,'82.22656250
'58,'Text 727,"'Since foo is const, foo ptr is a const pointer, and the expression has type int * const. This means it is not a pointer to const, SO modifying the value of the object it is pointing at is allowed. Looking at it another way, the object X lives outside the memory for foo, SO the fact that foo is const has no effect on whether or not X can be modified through a pointer that lives within foo.",'979,'95.89843750
'58,'Text 728,"'3 A member can be declared mutable, which allows it to be modified even if the object that contains it is const.",'980,'45.70312500
'58,'Footer 29,"'10.1. Compound Objects and const",'981,'85.74218750
'58,'Page number 55,"'53",'982,'86.23046875
'59,'Header 55,"'CHAPTER",'983,'45.99609375
'59,'Header 56,"'ELEVEN",'984,'50.29296875
'59,'Title 15,"'ABSTRACT DATA TYPES IN C",'985,'85.64453125
'59,'Text 729,"'Recall that abstraction is the idea of separating what something is from how it works, by separating interface from implementation. Previously, we saw procedural abstraction, which applies abstraction to computational processes. With procedural abstraction, we use functions based on their signature and documentation without having to know details about their definition.",'986,'98.48632813
'59,'Text 730,"'The concept of abstraction can be applied to data as well. An abstract data type (ADT) separates the interface of a data type from its implementation, and it encompasses both the data itself as well as functionality on the data. An example of an ADT is the string type in C++, used in the following code:",'987,'97.07031250
'59,'Text 731,"'string strl = ""hello""; string str2 = ""jello""; cout str1 << endl; if (str1.length() == str2.length()) { cout << ""Same length!"" endl; }",'988,'86.66992188
'59,'Text 732,"'This code creates two strings and initializes them to represent different values, prints out one of them, and compares the lengths of both all without needing to any details about the implementation of string. Rather, it relies solely on the interface provided by the string abstraction.",'989,'96.92382813
'59,'Text 733,"'A string is an example of a full-featured C++ ADT, providing customized initialization, overloaded operations such as the stream-insertion operator, member functions, and SO on. We will start with the simpler model of C ADTs, deferring C++ ADTs until next time.",'990,'97.26562500
'59,'Text 734,"'The C language only has support for structs with data members (i.e. member variables). While this is sufficient to represent the data of an ADT, the functions that operate on the ADT must be defined separately from the struct. The following is the data definition of an ADT to represent triangles:",'991,'97.80273438
'59,'Text 735,"'// A triangle ADT. struct Triangle { double a; double b; double C; }; int main() { Triangle t1 = { 3, 4, 5 }; Triangle t2 = { 2, 2, 2 }; }",'992,'50.00000000
'59,'Text 736,"'The Triangle struct contains three member variables, one for each side of the triangle, each represented by a double. The example in main () creates and initializes two Triangle structs, resulting in the memory layout in Figure 11.1.",'993,'96.09375000
'59,'Page number 56,"'54",'994,'86.66992188
'60,'Title 16,"'Programming and Data Structures, Release 0.3",'995,'48.33984375
'60,'Table 17,"",'996,'89.99023438
'60,'Text 737,"'Stack",'997,'82.66601563
'60,'Text 738,"'Figure 11.1: Two local Triangle objects.",'998,'95.36132813
'60,'Text 739,"'An ADT also includes functions that operate on the data. We can define functions to compute the perimeter of a triangle or to modify it by scaling each of the sides by a given factor:",'999,'97.16796875
'60,'Text 740,"'// REQUIRES: tri points to a valid Triangle // EFFECTS: Returns the perimeter of the given Triangle. double Triangle_perimeter (const Triangle *tri) { return tri->a + tri->b + tri->c; } // REQUIRES: tri points to a valid Triangle; S > 0 // MODIFIES: *tri // EFFECTS: Scales the sides of the Triangle by the factor S. void Triangle_scale(Triangle *tri, double s) { tri->a ==s; tri->b *=s; tri->c *= s; }",'1000,'71.53320313
'60,'Text 741,"'Our naming convention for functions that are part of a C-style ADT is to prepend the function name with the name of the ADT, Triangle in this case. The first parameter is a pointer to the actual Triangle object the function works on. If the object need not be modified, we declare the pointer as a pointer to const.",'1001,'97.46093750
'60,'Text 742,"'The following demonstrates how to use the Triangle ADT functions:",'1002,'91.45507813
'60,'Text 743,"'int main() { Triangle t1 = { 3, 4, 5 }; Triangle_scale (&t1, 2); // sides are now 6, 8, 10 cout << Triangle_perimeter(&t1) << endl; // prints 24 }",'1003,'95.41015625
'60,'Text 744,"'The code creates a Triangle as a local variable and initializes it with sides 3, 4, and 5. It then scales the sides by a factor of 2 by calling Triangle_scale(). Since that function takes a pointer to the actual triangle, we use the address-of operator to obtain and pass the address of t1, as shown in Figure 11.2.",'1004,'96.48437500
'60,'Page number 57,"'55",'1005,'89.30664063
'61,'Header 57,"'Programming and Data Structures, Release 0.3",'1006,'47.07031250
'61,'Table 18,"",'1007,'90.77148438
'61,'Text 745,"'Stack",'1008,'72.65625000
'61,'Text 746,"'Figure 11.2: Passing a pointer to a Triangle object.",'1009,'95.11718750
'61,'Text 747,"'The function scales each side of the triangle, resulting in t1 having sides of 6, 8, and 10. We then call Triangle_perimeter() on the address of t1, which computes the value 24.",'1010,'96.33789063
'61,'Text 748,"'In this example, the code in main() need not worry about the implementation of Triangle_scale( or Triangle_perimeter(). Instead, it relies on abstraction, using the functions for what they do rather than how they do it. However, in initializing t1 itself, the code is relying on implementation details - specifically, that a Triangle is implemented as three double members that represent the lengths of the sides. If the implementation were to change to represent a triangle as two sides and the angle between them, for instance, then the behavior of the code in main( () would change, and it would no longer print 24. Thus, we need to abstract the initialization of a Triangle, avoiding having to initialize each member directly. We do SO by defining a Triangle_init(] function:",'1011,'97.41210938
'61,'Text 749,"'// REQUIRES: tri points to a Triangle object // MODIFIES: *tri // EFFECTS: Initializes the triangle with the given side lengths. void Triangle_init(Triangle *tri, double a_in, double b_in, double c_in) { tri->a = a_in; tri->b = b_in; tri->c = c_in; } int main() { Triangle t1; Triangle_init(&t1, 3, 4, 5); Triangle_scale(&t1, 2); cout << Triangle_perimeter (&t1) << endl; }",'1012,'37.42675781
'61,'Text 750,"'The user of the Triangle ADT creates an object without an explicit initialization and then calls Triangle_init( on its address to initialize it, providing the side lengths. After that call, the Triangle has been properly initialized and can be used with the other ADT functions. Now if the implementation of Triangle changes, as long as the interface remains the same, the code in main () will work as before. The code within the ADT, in the Triangle functions, will need to change, but outside code that uses the ADT will not. The following illustrates an implementation of Triangle that represents a triangle by two sides and an angle:",'1013,'96.28906250
'61,'Page number 58,"'56",'1014,'92.08984375
'62,'Title 17,"'Programming and Data Structures, Release 0.3",'1015,'44.45800781
'62,'Key value 16,"",'1016,'42.82226563
'62,'Page number 59,"'57",'1017,'94.62890625
'63,'Header 58,"'Programming and Data Structures, Release 0.3",'1018,'58.98437500
'63,'Text 751,"'Here, we have added accessor or getter functions for each of the sides, allowing a user to obtain the side lengths without needing to know implementation details. Even within the ADT itself, we have used Triangle_side3( from within Triangle_perimeter() to avoid code duplication.",'1019,'97.07031250
'63,'Text 752,"'The REQUIRES clauses of the ADT functions make a distiction between Triangle objects and valid Triangle ob- jects. The former refers to an object that is of type Triangle but may not have been properly initialized, while the latter refers to a Triangle object that has been initialized by a call to Triangle_init(). Except for Triangle_init(), the ADT functions all work on valid Triangles.",'1020,'95.50781250
'63,'Text 753,"'Now that we have a full definition of a C-style ADT, we adhere to the following convention for working with one: the user of a C-style ADT may only interact with the ADT through its interface, meaning the functions defined as part of the ADT's interface. The user is generally prohibited from accessing struct member variables directly, as those are implementation details of the ADT. This convention also holds in testing an ADT, since tests should only exercise the behavior of an ADT and not its implementation.",'1021,'95.80078125
'63,'Section header 34,"'11.1 Representation Invariants",'1022,'82.37304688
'63,'Text 754,"'When designing an abstract data type, we must build a data representation on top of existing types. Usually, there will be cases where the underlying data representation permits combinations of values that do not make sense for our ADT. For example, not every combination of three doubles represents a valid triangle - a double may have a negative value, but a triangle may not have a side with negative length. The space of values that represent valid instances of a triangle abstraction is a subset of the set of values that can be represented by three doubles, as illustrated in Figure 11.3.",'1023,'95.99609375
'63,'Figure 21,"",'1024,'91.25976563
'63,'Text 755,"'Figure 11.3: Representation invariants define the valid subset of the values allowed by the data representation of an ADT.",'1025,'94.48242188
'63,'Text 756,"'Thus, when designing an ADT, we need to determine the set of values that are valid for the ADT. We do SO by specifying representation invariants for our ADT, which describe the conditions that must be met in order to make an object valid. For a triangle represented as a double for each side, the following representation invariants must hold:",'1026,'96.82617188
'63,'List 20,"",'1027,'93.21289063
'63,'Text 757 - Part of List 20,"'The length of each side must be positive.",'1028,'97.31445313
'63,'Text 758 - Part of List 20,"'The triangle inequality must hold: the sum of any two sides must be strictly greater than the remaining side.",'1029,'97.36328125
'63,'Text 759,"'Often, we document the representation invariants as part of the ADT's data definition:",'1030,'95.41015625
'63,'Footer 30,"'11.1. Representation Invariants",'1031,'80.85937500
'63,'Page number 60,"'58",'1032,'89.11132813
'64,'Header 59,"'Programming and Data Structures, Release 0.3",'1033,'55.56640625
'64,'Text 760,"'// A triangle ADT. struct Triangle { double a; double b; double C; // INVARIANTS: a>0&&b>O&&C>O&& // };",'1034,'48.14453125
'64,'Text 761,"'We then enforce the invariants when constructing or modifying an ADT object by encoding them into the REQUIRES clauses of our functions. We can use assertions to check for them as well, where possible:",'1035,'97.21679688
'64,'Key value 17,"",'1036,'46.38671875
'64,'Section header 35,"'11.2 Plain Old Data",'1037,'88.03710938
'64,'Text 762,"'As mentioned above, we adhere to the convention of only interacting with an ADT through its interface. Usually, this means that we do not access the data members of an ADT in outside code. However, occasionally we have the need for an ADT that provides no more functionality than grouping its members together. Such an ADT is just plain old data (POD)4, without any functions that operate on that data, and we define its interface to be the same as its implementation.",'1038,'97.02148438
'64,'Text 763,"'The following is an example of a Pixel struct used as a POD:",'1039,'61.76757813
'64,'Text 764,"'// A pixel that represents red, green, and blue color values. struct Pixel { int r; // red",'1040,'58.88671875
'64,'Text 765,"'(continues on next page)",'1041,'82.03125000
'64,'Text 766,"'4 We use the term ""plain old data"" in the generic sense and not as the specific C++ term. C++ has a generalization of POD types called aggregates. Technically, the Person struct we saw last time is an aggregate but not a POD. What we mention here for POD types generally applies to aggregates as well.",'1042,'88.57421875
'64,'Section header 36,"'11.2. Plain Old Data",'1043,'49.70703125
'64,'Page number 61,"'59",'1044,'89.59960938
'65,'Header 60,"'Programming and Data Structures, Release 0.3",'1045,'56.68945313
'65,'Text 767,"'(continued from previous page)",'1046,'77.19726563
'65,'Text 768,"'int g; // green int b; // blue }; int main() { Pixelp={ 255,0,0}; cout p.r p.g << << p.b endl; }",'1047,'37.10937500
'65,'Text 769,"'The Pixel ADT consists of just a data representation with no further functionality. Since it is a POD, its interface and implementation are the same, SO it is acceptable to access its members directly.",'1048,'79.49218750
'65,'Section header 37,"'11.3 Abstraction Layers",'1049,'67.67578125
'65,'Text 770,"'As with procedural abstraction, data abstraction is also defined in layers, with each layer interacting solely with the interface of the layer below and not its implementation. For example, we can represent an image using three matrices, one for each color channel. Any code that uses an image relies on the image interface, without needing to know that it is implemented over three matrices. Each matrix in turn can be represented using a single-dimensional vector. Code that uses a matrix relies on the 2D abstraction provided by the interface without needing to know that it is implemented as a 1D vector under the hood.",'1050,'93.65234375
'65,'Table 19,"",'1051,'40.91796875
'65,'Text 771,"'Image ""how"", using Matrix ""what"".",'1052,'45.14160156
'65,'Text 772,"'Figure 11.4: Abstraction layers for an image.",'1053,'79.24804688
'65,'Footer 31,"'11.3. Abstraction Layers",'1054,'79.29687500
'65,'Page number 62,"'60",'1055,'87.79296875
'66,'Header 61,"'Programming and Data Structures, Release 0.3",'1056,'76.70898438
'66,'Section header 38,"'11.4 Testing an ADT",'1057,'53.12500000
'66,'Text 773,"'As mentioned previously, code outside of an ADT's implementation must interact with the ADT solely through its interface, including test code. Modifying an ADT's implementation should not require modifying its test code - we should be able to immediately run our regression tests in order to determine whether or not the ADT still works.",'1058,'98.09570313
'66,'Text 774,"'Adhering to the interface often means that we can't test each ADT function individually. For instance, we can- not test Triangle_init in isolation; instead, we can test it in combination with the side accessors (e.g. Triangle_side1()) to determine whether or not the initialization works correctly. Instead of testing individual func- tions, we test individual behaviors, such as initialization.",'1059,'97.16796875
'66,'Text 775,"'As another example, let's proceed to design and test an ADT to represent a coordinate in two-dimensional space, using the principle of test-driven development that we saw previously. We will use polar coordinates, which represent a coordinate by the radius from the origin and angle from the horizontal axis, and we reflect this in the name of the ADT and its interface.",'1060,'96.63085938
'66,'Figure 22,"",'1061,'94.58007813
'66,'Text 776,"'Figure 11.5: Polar representation of a point in two-dimensional space.",'1062,'95.89843750
'66,'Section header 39,"'We start by determining the interface of the ADT:",'1063,'57.95898438
'66,'Text 777,"'// A set of polar coordinates in 2D space. struct Polar; // REQUIRES: p points to a Polar object // MODIFIES: *p // EFFECTS: Initializes the coordinate to have the given radius and // angle in degrees. void Polar_init (Polar* p, double radius, double angle); // REQUIRES: p points to a valid Polar object // EFFECTS: Returns the radius portion of the coordinate as a // nonnegative value. double Polar_radius (const Polar* p) // REQUIRES: p points to a valid Polar object // EFFECTS: Returns the angle portion of the coordinate in degrees as // a value in [0, 360) double Polar_angle (const Polar* p);",'1064,'90.03906250
'66,'Text 778,"'We then proceed to write some test cases, following the principles of test-driven development:",'1065,'91.35742188
'66,'Footer 32,"'11.4. Testing an ADT",'1066,'70.16601563
'66,'Page number 63,"'61",'1067,'91.25976563
'67,'Title 18,"'Programming and Data Structures, Release 0.3",'1068,'41.01562500
'67,'Section header 40,"'// Basic test of initializing a Polar object.",'1069,'32.37304688
'67,'Figure 23,"",'1070,'31.44531250
'67,'Text 779,"'TEST(test_init_basic) { Polar p; Polar_init(&p, 5, 45); ASSERT_EQUAL L(Polar_radius (&p), 5); ASSERT_EQUAL(Polar_angle(&p), 45);",'1071,'56.78710938
'67,'Text 780,"'}",'1072,'25.75683594
'67,'Text 781,"'We can then proceed to define a data representation. As part of this process, we should consider what representation invariants our ADT should have. For our Polar ADT, a reasonable set of invariants is that the radius is nonnegative, and the angle is in the range [0, 360) (using degrees rather than radians)5:",'1073,'96.19140625
'67,'Section header 41,"'struct Polar {",'1074,'39.99023438
'67,'Figure 24,"",'1075,'26.31835938
'67,'Text 782,"'double r; double phi; // INVARIANTS: r 0 && phi >= 0 && phi < 360 };",'1076,'92.48046875
'67,'Text 783,"'Now that we have a data representation, we can make an initial attempt at implementing the functions as well:",'1077,'90.47851563
'67,'Text 784,"'void Polar_init(Polar* p, double radius, double angle) { p->r = radius: p->phi = angle; } double Polar_radius(const Polar* p) { return p->r; } double Polar_angle(const Polar* p) { return p->phi; }",'1078,'48.73046875
'67,'Text 785,"'We can run our existing test cases to get some confidence that our code is working. In addition, the process of coming up with a data representation, representation invariants, and function definitions often suggests new test cases. For instance, the following test cases check that the representation invariants are met when Polar_init() is passed values that don't directly meet the invariants:",'1079,'95.06835938
'67,'Figure 25,"",'1080,'38.40332031
'67,'Section header 42,"'// Tests initialization with a negative radius.",'1081,'28.90625000
'67,'Text 786,"'TEST(test_negative_radius) { Polar p; Polar_init(&p, -5, 225) ; ASSERT_EQUAL (Polar_radius (&p), 5); ASSERT_EQUAL (Polar_angle(&p), 45); }",'1082,'45.89843750
'67,'Text 787,"'// Tests initialization with an angle >= 360. TEST(test_big_angle) { Polar p; Polar_init(&p, 5, 405)",'1083,'55.56640625
'67,'Text 788,"'(continues on next page)",'1084,'59.08203125
'67,'Text 789,"'5 A complete set of invariants would likely also specify a canonical representation of the origin. For example, it may specify that if the radius is 0, then SO is the angle.",'1085,'75.97656250
'67,'Footer 33,"'11.4. Testing an ADT",'1086,'70.16601563
'67,'Page number 64,"'62",'1087,'79.93164063
'68,'Header 62,"'Programming and Data Structures, Release 0.3",'1088,'42.52929688
'68,'Text 790,"'(continued from previous page)",'1089,'78.27148438
'68,'Text 791,"'ASSERT_EQUAL (Polar_radius (&p), 5); ASSERT_EQUAL (Polar_angle(&p), 45);",'1090,'39.79492188
'68,'Text 792,"'}",'1091,'26.46484375
'68,'Text 793,"'Given our initial implementation, these test cases will fail. We can attempt to fix the problem as follows:",'1092,'79.00390625
'68,'Text 794,"'void Polar_init(Polar p, double radius, double angle) { p->r = std::abs(radius) // set radius to its absolute value p->phi = angle; if (radius < 0) { // rotate angle by 180 degrees if radius p->phi = p->phi + 180; // was negative } }",'1093,'83.98437500
'68,'Text 795,"'Running our test cases again, we find that both :_negative_radius and test_big_angle still fail: the angle value returned by Polar_angle() is out of the expected range. We can fix this as follows:",'1094,'94.58007813
'68,'Text 796,"'void Polar_init (Polar* p, double radius, double angle) { p->r = std: abs(radius); // set radius to its absolute value p->phi = angle; if (radius < 0) { // rotate angle by 180 degrees if radius p->phi = p->phi + 180; // was negative } p->phi = std::fmod(p->phi, 360); // mod angle by 360 }",'1095,'86.96289063
'68,'Text 797,"'Now both test cases succeed. However, we may have thought of another test case through this process:",'1096,'92.91992188
'68,'Figure 26,"",'1097,'43.11523438
'68,'Text 798,"'// Tests initialization with a negative angle. TEST (test_negative_ angle) { Polar p; Polar_init(&p, 5, -45); ASSERT_EQUAL (Polar_radius (&p), 5); ASSERT_EQUAL(Polar_angle(&p), 315); }",'1098,'44.45800781
'68,'Text 799,"'Unfortunately, this test case fails. We can try another fix:",'1099,'61.42578125
'68,'Text 800,"'void Polar_init(Polar* p, double radius, double angle) { p->r = std: : abs(radius); // set radius to its absolute value p->phi = angle; if (radius < 0) { // rotate angle by 180 degrees if radius p->phi = p->phi + 180; // was negative } p->phi= std::fmod(p->phi,360); = // mod angle by 360 if (p->phi < 0) { // rotate negative angle by 360 p->phi += 360; } }",'1100,'57.56835938
'68,'Text 801,"'Our test cases now all pass.",'1101,'87.06054688
'68,'Footer 34,"'11.4. Testing an ADT",'1102,'43.87207031
'68,'Page number 65,"'63",'1103,'81.54296875
'69,'Header 63,"'CHAPTER",'1104,'45.14160156
'69,'Header 64,"'TWELVE",'1105,'47.36328125
'69,'Title 19,"'COMMAND-LINE ARGUMENTS",'1106,'85.74218750
'69,'Text 802,"'So far, the programs we have considered have not worked with user input. More interesting programs, however, incor- porate behavior that responds to user input. We will see two mechanisms for passing input to a program: command-line arguments and standard input.",'1107,'97.46093750
'69,'Text 803,"'Command-line arguments are arguments that are passed to a program when it is invoked from a shell or terminal. As an example, consider the following command:",'1108,'93.84765625
'69,'Text 804,"'$ g++ -Wall -01 -std=c++17 -pedantic test. cpp -0 test",'1109,'71.04492188
'69,'Text 805,"'Here, g++ is the program we are invoking, and the arguments tell g++ what to do. For instance, the -Wall argument tells the g++ compiler to warn about any potential issues in the code, -01 tells the compiler to use optimization level 1, and SO on.",'1110,'96.43554688
'69,'Text 806,"'Command-line arguments are passed to the program through arguments to main(). The main() function may have zero parameters, in which case the command-line arguments are discarded. It can also have two parameters ¹, SO the signature has the following form:",'1111,'96.04492188
'69,'Text 807,"'int main(int argc, char *argv[])",'1112,'50.19531250
'69,'Text 808,"'The first argument is the number of command-line arguments passed to the program, and it is conventionally named argc. The second, conventionally named argv, contains each command-line argument as a C-style string. An array parameter is actually a pointer parameter, SO the following signature is equivalent:",'1113,'97.41210938
'69,'Section header 43,"'int main(int largc, char **argv);",'1114,'62.35351563
'69,'Text 809,"'Thus, the second parameter is a pointer to the first element of an array, each element of which is a pointer to the start of a C-style string, as shown in Figure 12.1.",'1115,'96.04492188
'69,'Text 810,"'The command-line arguments also include the name of the program as the first argument - this is often used in printing out error messages from the program.",'1116,'93.65234375
'69,'Text 811,"'We recommend converting command-line arguments to std: : string before working with them, as it is less error- prone than working with C-style strings directly.",'1117,'92.48046875
'69,'Text 812,"'As an example, the following program takes an arbitrary number of integral arguments and computes their sum:",'1118,'88.57421875
'69,'Text 813,"'#include <iostream> #include <string> // for string type and stoi function",'1119,'40.72265625
'69,'Text 814,"'using namespace std;",'1120,'38.98925781
'69,'Text 815,"'int main(int argc, char *argv[]) {",'1121,'57.47070313
'69,'Text 816,"'(continues on next page)",'1122,'74.70703125
'69,'Text 817,"'1 Implementations may also allow other signatures for main().",'1123,'51.66015625
'69,'Page number 66,"'64",'1124,'80.02929688
'70,'Header 65,"'Programming and Data Structures, Release 0.3",'1125,'78.22265625
'70,'Figure 27,"",'1126,'98.97460938
'70,'Text 818,"'Figure 12.1: Representation of command-line arguments.",'1127,'92.77343750
'70,'Text 819,"'(continued from previous page)",'1128,'93.55468750
'70,'Text 820,"'int sum = 0; for (int i= 1; i < largc; ++i) { string arg = argv[i]; sum += stoi (argv[i]) } cout << ""sum is "" << sum << endl;",'1129,'66.11328125
'70,'Text 821,"'}",'1130,'95.81155396
'70,'Text 822,"'The first argument is skipped, since it is the program name. Each remaining argument is converted to an int by the stoi () function, which takes a string as the argument and returns the integer that it represents. For example, stoi (""123"") returns the number 123 as an int.",'1131,'96.33789063
'70,'Text 823,"'The following is an example of running the program:",'1132,'94.97070313
'70,'Text 824,"'$ ./sum.exe 2 4 6 8 10 sum is 30",'1133,'83.39843750
'70,'Page number 67,"'65",'1134,'90.33203125
'71,'Header 66,"'CHAPTER",'1135,'36.20605469
'71,'Header 67,"'THIRTEEN",'1136,'41.96777344
'71,'Title 20,"'INPUT AND OUTPUT (I/O)",'1137,'62.06054688
'71,'Text 825,"'User input can also be obtained through standard input, which receives data that a user types into the console. In C++, the cin stream reads data from standard input. Data is extracted into an object using the extraction operator >>, and the extraction interprets the raw character data according to the target data type. For example, the following code extracts to string, which extracts individual words that are separated by whitespace:",'1138,'97.90039063
'71,'Text 826,"'string word; while (cin >> word) { cout << ""word = << word << << endl ; }",'1139,'95.26367188
'71,'Text 827,"'The extraction operation evaluates to the cin stream, which has a truth value - if the extraction succeeds, it is true, but if the extraction fails, the truth value is false. Thus, the loop above will continue as long as extraction succeeds.",'1140,'93.65234375
'71,'Text 828,"'The following is an example of the program:",'1141,'78.90625000
'71,'Text 829,"'$ ./words.exe hello world! word = 'hello' word = 'world!' goodbye word = 'goodbye'",'1142,'97.36328125
'71,'Text 830,"'The program only receives input after the user presses the enter key. The first line the user entered contains two words, each of which gets printed out. Then the program waits for more input. Another word is entered, SO the program reads and prints it out. Finally, the user in this example inputs an end-of-file character - on Unix-based systems, the sequence Ctrl-d enters an end of file, while Ctrl-z does SO on Windows systems. The end-of-file marker denotes the end of a stream, SO extracting from cin fails at that point, ending the loop above.",'1143,'96.87500000
'71,'Text 831,"'The program above prints output to standard output, represented by the cout stream. The insertion operator << inserts the text representation of a value into an output stream.",'1144,'91.01562500
'71,'Section header 44,"'13.1 I/O Redirection",'1145,'89.01367188
'71,'Text 832,"'Shells allow input redirection, which passes the data from a file to standard input rather than reading from the keyboard. For instance, if the file words. in contains the data:",'1146,'96.72851563
'71,'Text 833,"'hello world! goodbye",'1147,'90.57617188
'71,'Text 834,"'Then using the < symbol before the filename redirects the file to standard input at the command line:",'1148,'94.77539063
'71,'Page number 68,"'66",'1149,'78.90625000
'72,'Header 68,"'Programming and Data Structures, Release 0.3",'1150,'52.73437500
'72,'Text 835,"'$ ./words.exe < words.in word = 'hello' word = 'world!' word = 'goodbye'",'1151,'77.34375000
'72,'Text 836,"'A file has an implicit end of file at the end of its data, and the program terminates upon reaching the end of the file.",'1152,'81.34765625
'72,'Text 837,"'We can also do output redirection, where the shell writes the contents of standard output to a file. The symbol for output redirection is >:",'1153,'91.79687500
'72,'Text 838,"'$ /words.exe > result.out hello world! goodbye $ cat result.out word = 'hello' word = 'world!' word = 'goodbye'",'1154,'92.62695313
'72,'Text 839,"'Here, we redirect the output to the file result.out We then enter input from the keyboard, ending with the Ctrl-d sequence. When the program ends, we use the cat command to display the contents of result.out",'1155,'95.36132813
'72,'Text 840,"'Input and output redirection can also be used together:",'1156,'80.27343750
'72,'Text 841,"'$ ./words.exe < words.in > result.out $ cat result.out word = 'hello' word = 'world!' word = 'goodbye'",'1157,'94.77539063
'72,'Section header 45,"'13.2 Example: Adding Integers",'1158,'91.11328125
'72,'Text 842,"'Using standard input, we can write a program that adds up integers entered by a user. The program will terminate either upon reaching an end of file or if the user types in the word done:",'1159,'97.36328125
'72,'Text 843,"'#include <iostream> #include <string> // for stoi",'1160,'55.90820313
'72,'Text 844,"'using namespace std;",'1161,'31.22558594
'72,'Text 845,"'int main() { int sum = 0; cout << ""Enter some numbers to sum. "" << endl string word; while (cin >> word && word != ""done"") { sum += stoi (word): } cout << ""sum is "" << sum << endl;",'1162,'64.94140625
'72,'Text 846,"'}",'1163,'98.98401642
'72,'Text 847,"'The code extracts to a string SO that it can be compared to the string ""done"". (The latter is a C-style string, but C++ strings can be compared with C-style strings using the built-in comparison operators.)",'1164,'91.69921875
'72,'Text 848,"'The following is an example of running the program:",'1165,'86.81640625
'72,'Footer 35,"'13.2. Example: Adding Integers",'1166,'56.98242188
'72,'Page number 69,"'67",'1167,'84.66796875
'73,'Header 69,"'Programming and Data Structures, Release 0.3",'1168,'58.88671875
'73,'Text 849,"'$ /sum Enter some numbers to sum. 2 4 6 done sum is 12",'1169,'90.67382813
'73,'Text 850,"'An alternate version of the program extracts directly to an int. However, it can only be terminated by an end of file or other failed extraction:",'1170,'97.70507813
'73,'Text 851,"'#include <iostream> using namespace std; int main() { int sum = 0; cout << ""Enter some numbers to sum."" << endl int number; while (cin >> number) { sum += number; } cout << ""sum is "" << sum << endl; }",'1171,'66.01562500
'73,'Section header 46,"'13.3 File I/O",'1172,'77.24609375
'73,'Text 852,"'A program can also read and write files directly using file streams. It must include the <fstream> header, and it can then use an ifstream to read from a file and an ofstream to write to a file. The former supports the same interface as cin, while the latter has the same interface as cout.",'1173,'97.31445313
'73,'Text 853,"'An ifstream object can be created from a file name:",'1174,'93.16406250
'73,'Text 854,"'string filename = ""words.in""; ifstream fin(filename) ;",'1175,'95.41015625
'73,'Text 855,"'Alternatively, the ifstream object can be created without a file name, and then its open() function can be given the name of the file to open:",'1176,'97.21679688
'73,'Text 856,"'string filename = ""words.in"" ifstream fin; fin.open(filename)",'1177,'95.11718750
'73,'Text 857,"'In general, a program should check if the file was successfully opened, regardless of the mechanism used to create the ifstream:",'1178,'97.26562500
'73,'Text 858,"'if (!fin.is_open()) { cout << ""open failed"" << endl; return 1; }",'1179,'94.53125000
'73,'Text 859,"'Once we've determined the file is open, we can read from it like cin. The following program reads individual words from the file words. in and prints them:",'1180,'97.16796875
'73,'Footer 36,"'13.3. File I/O",'1181,'67.33398438
'73,'Page number 70,"'68",'1182,'77.19726563
'74,'Title 21,"'Programming and Data Structures, Release 0.3",'1183,'42.62695313
'74,'Text 860,"'#include <iostream> #include <fstream> #include <string>",'1184,'73.77929688
'74,'Text 861,"'using namespace std;",'1185,'50.09765625
'74,'Text 862,"'int main() { string filename = ""words.in""; ifstream fin; fin. open(filename) ; if (!fin.is_open()) { cout << ""open failed"" << endl; return 1; } string word; while (fin >> word) { cout ""word = I I << word << << endl; } fin.close() ; // optional }",'1186,'76.95312500
'74,'Text 863,"'The program closes the file before exiting. Doing SO explicitly is optional - it will happen automatically at the end of the ifstream object's lifetime (e.g. when it goes out of scope if it is a local variable).",'1187,'94.14062500
'74,'Text 864,"'Best practice is to extract from an input stream, whether it is cin or an ifstream, in the test of a loop or conditional. That way, the test will evaluate to false if the extraction fails. The following examples all print the last word twice because they do not check for failure between extracting and printing a word:",'1188,'95.01953125
'74,'Table 20,"",'1189,'25.97656250
'74,'Text 865,"'The following is printed when using any of the loops above:",'1190,'85.10742188
'74,'Text 866,"'$ ./main.exe hello world! goodbye",'1191,'88.57421875
'74,'Text 867,"'(continues on next page)",'1192,'77.53906250
'74,'Footer 37,"'13.3. File I/O",'1193,'65.38085938
'74,'Page number 71,"'69",'1194,'77.34375000
'75,'Title 22,"'Programming and Data Structures, Release 0.3",'1195,'44.75097656
'75,'Text 868,"'(continued from previous page)",'1196,'89.40429688
'75,'Text 869,"'goodbye",'1197,'64.89257813
'75,'Text 870,"'Multiple extractions can be placed in the test of a loop by chaining them. The test evaluates to true when all extractions succeed. For example, the following reads two words at a time:",'1198,'97.94921875
'75,'Table 21,"",'1199,'64.16015625
'75,'Text 871,"'For words. in, only the first two words are printed, since the test will fail in the second iteration when it tries to read a fourth word:",'1200,'95.84960938
'75,'Text 872,"'$ /main.exe word1 = 'hello' word2 = 'world!'",'1201,'94.48242188
'75,'Text 873,"'An entire line can be read using the getline() function, which takes in an input stream and a target string (by reference) and returns whether or not reading the line succeeded. If so, the target string will contain the full line read:",'1202,'97.26562500
'75,'Text 874,"'#include <iostream> #include <fstream> #include <string> using namespace std;",'1203,'38.57421875
'75,'Text 875,"'int main() { string filename = ""hello.txt""; ifstream fin; fin. .open(filename) ; if ( !fin.is_open()) { cout << ""open failed"" << endl; return 1; } string line; while (getline(fin, line)) { cout << ""line = III << line << << endl; } }",'1204,'84.42382813
'75,'Text 876,"'For words. in, this will result in:",'1205,'77.73437500
'75,'Text 877,"'$ /main.exe line = 'hello world! line = 'goodbye'",'1206,'94.67773438
'75,'Text 878,"'An ofstream works similarly to an i fstream, except that it is used for printing output to a file. The following program prints data to the file output. txt:",'1207,'96.82617188
'75,'Table 22,"",'1208,'36.66992188
'75,'Footer 38,"'13.3. File I/O",'1209,'61.32812500
'75,'Page number 72,"'70",'1210,'83.05664063
'76,'Header 70,"'Programming and Data Structures, Release 0.3",'1211,'52.05078125
'76,'Text 879,"'(continued from previous page)",'1212,'67.33398438
'76,'Text 880,"'using namespace std;",'1213,'40.69824219
'76,'Text 881,"'int main() { const int SIZE = 4; int data[SIZE] = { 1, 2, 3, 4 }; string filename = ""output.txt""; ofstream fout; fout.open(filename) ; if (!fout.is_open()) { cout << ""open failed"" << endl; return 1; } for (inti=0;i<4; +i) { fout << ""data["" << i << ""] = << data[i] << endl; } fout. close(); // optional }",'1214,'95.31250000
'76,'Text 882,"'The following shows the resulting data in output. txt:",'1215,'88.81835938
'76,'Text 883,"'$ cat output. txt data[0] = 1 data[1] = 2 data[2] = 3 data[3] = 4",'1216,'87.01171875
'76,'Footer 39,"'13.3. File I/O",'1217,'83.74023438
'76,'Page number 73,"'71",'1218,'79.93164063
'77,'Header 71,"'FOURTEEN",'1219,'28.10058594
'77,'Text 884,"'CHAPTER",'1220,'38.91601563
'77,'Title 23,"'MORE ON STREAMS",'1221,'64.59960938
'77,'Text 885,"'Previously, we learned about the standard input and output streams, as well as file streams. We examine the relationship between streams more closely now, as well as how to write unit tests using string streams.",'1222,'96.53320313
'77,'Text 886,"'A stream is an abstraction over a source of input, from which we can read data, or a sink of output, to which we can write data. Streams support the abstraction of character-based input and output over many underlying resources, including the console, files, the network, strings, and SO on.",'1223,'96.14257813
'77,'Text 887,"'In C++, input streams generally derive from istream ². We will see what this means specifically when we look at inheritance and polymorphism in the future. For our purposes right now, this means that we can pass different kinds of input-stream objects to a function that takes in a reference to an istream. Similarly, output streams generally derive from ostream, and we can pass different kinds of output-stream objects to a function that takes in a reference to an ostream.",'1224,'94.18945313
'77,'Figure 28,"",'1225,'78.12500000
'77,'Text 888,"'Figure 14.1: Relationships between different kinds of input and output streams.",'1226,'87.54882813
'77,'Text 889,"'To write data into an output stream, we use the insertion operator <<. The actual data written out depends on both the value itself as well as its type. For instance, if we use a string as the right-hand-side operand, the insertion operation will write the characters from the string into the stream:",'1227,'97.16796875
'77,'Footer 40,"'2 The is tream type is actually an alias for basic_istream<char>, which is an input stream that supports input using the char type. The same goes for ostream and basic_ostream<char>",'1228,'50.68359375
'77,'Page number 74,"'72",'1229,'88.23242188
'78,'Header 72,"'Programming and Data Structures, Release 0.3",'1230,'58.20312500
'78,'Key value 18,"",'1231,'54.68750000
'78,'Text 890,"'Expressions that apply an operator generally evaluate to a value. In the case of stream insertion, the result is the actual stream object itself. This allows us to chain insertion operations:",'1232,'94.43359375
'78,'Key value 19,"",'1233,'61.42578125
'78,'Text 891,"'To read data from an input stream, we use the extraction operator >>, with an object on the right-hand side. The characters are interpreted according to the type of the object. For built-in types, whitespace is generally skipped when extracting.",'1234,'95.45898438
'78,'Text 892,"'char C; cin C; // reads a single character; does not skip whitespace string S : cout >> s: // reads in one ""word"", delimited by whitespace int i; cin >> i: // attempts to parse the next characters as an integer value double d; cin >> d; // attempts to parse the next characters as a floating-point value",'1235,'84.86328125
'78,'Text 893,"'As with the insertion operator, an expression that applies the extraction operator evaluates back to the stream itself, allowing extraction operations to be chained:",'1236,'96.97265625
'78,'Key value 20,"",'1237,'50.78125000
'78,'Section header 47,"'14.1 String Streams",'1238,'89.45312500
'78,'Text 894,"'When writing unit tests, we often want the tests to be standalone without requiring access to external data. For tests that work with streams, we can use string streams rather than standard input/output or file streams. To use a string stream, we #include <sstream>. We can then use an istringstream as an input stream, and an ostringstream as an output stream.",'1239,'97.80273438
'78,'Text 895,"'The following is an example of using an istringstream to represent input data for testing a function that takes in an input stream:",'1240,'91.79687500
'78,'Text 896,"'TEST(test_image_basic { // A hardcoded PPM image string input = ""P3\n2 2\n255\n255 00025501 \n""; input += ""O 0 255 255 255 255 \n""; // Use istringstream for simulated input istringstream ss_input(input);",'1241,'45.33691406
'78,'Text 897,"'(continues on next page)",'1242,'68.50585938
'78,'Footer 41,"'14.1. String Streams",'1243,'48.24218750
'78,'Page number 75,"'73",'1244,'88.76953125
'79,'Header 73,"'Programming and Data Structures, Release 0.3",'1245,'67.91992188
'79,'Text 898,"'(continued from previous page)",'1246,'58.69140625
'79,'Text 899,"'Image *img = new Image; Image_init(img ss_input);",'1247,'74.21875000
'79,'Text 900,"'ASSERT_EQUAL (Image_width(img), 2); Pixel red = { 255, 0, 0 }; ASSERT_TRUE(Pixel_equale (Image_get_pixel (img, , 0, 0), red)); delete img;",'1248,'60.49804688
'79,'Text 901,"'}",'1249,'94.29999542
'79,'Text 902,"'We start with a string that contains the actual input data and then construct an istringstream from that. We can then pass that istringstream object to a function that has a parameter of type istream & When that function extracts data, the result will be the data from the string we used to construct the istringstream.",'1250,'95.60546875
'79,'Text 903,"'We can similarly use an ostringstream to test a function that takes an output stream:",'1251,'90.03906250
'79,'Text 904,"'TEST(test_matrix_basic) { Matrix *mat = new Matrix; Matrix_init(mat, 3, 3) ; Matrix_fill (mat, 0); Matrix_fill_border(mat, 1);",'1252,'82.03125000
'79,'Text 905,"'// Hardcoded correct output string output_correct = ""3 3\n1 1 1 \n1 0 1 \n1 \n"";",'1253,'83.39843750
'79,'Text 906,"'// Capture output in ostringstream ostringstream ss_output; Matrix_print (mat, ss_output) ; ASSERT_EQUAL (ss_output.strO), output_correct); delete mat;",'1254,'87.15820313
'79,'Text 907,"'}",'1255,'28.36914063
'79,'Text 908,"'We default construct an ostringstream object and pass it to a function with a parameter of type ostream &. The ostringstream will internally capture the data that the function inserts into it. We can then call str() on the ostringstream to obtain a string that contains that data, which we can then compare to another string that contains the expected output.",'1256,'97.16796875
'79,'Footer 42,"'14.1. String Streams",'1257,'84.52148438
'79,'Page number 76,"'74",'1258,'86.42578125
'80,'Text 909,"'CHAPTER",'1259,'52.34375000
'80,'Text 910,"'FIFTEEN",'1260,'46.38671875
'80,'Text 911,"'PROGRAM DESIGN",'1261,'74.56054688
'80,'Text 912,"'Apologies - this section has not been written yet.",'1262,'77.39257813
'80,'Page number 77,"'75",'1263,'64.59960938
'81,'Header 74,"'CHAPTER",'1264,'64.40429688
'81,'Header 75,"'SIXTEEN",'1265,'61.03515625
'81,'Title 24,"'ABSTRACT DATA TYPES IN C++",'1266,'89.50195313
'81,'Text 913,"'Now that we've seen the concept of abstract data types (ADTs), we proceed to examine the mechanisms C++ provides for defining an ADT. Unlike C, C++ allows the data and functions of an ADT to be defined together. It also enables an ADT to prevent access to internal implementation details, as well as to guarantee that an object is appropriately initialized when it is created.",'1267,'98.48632813
'81,'Text 914,"'Our convention in this course is to use the word struct to refer to C-style ADTs, as well as to use the struct keyword to define them. We use the word class to refer to C++ ADTs and use the class keyword to define them. We will discuss the technical difference between the two keywords momentarily.",'1268,'97.46093750
'81,'Text 915,"'A C++ class includes both member variables, which define the data representation, as well as member functions that operate on the data. The following is a Triangle class in the C++ style:",'1269,'95.16601563
'81,'Text 916,"'class Triangle { double a; double b; double C; public: Triangle(double a_in, double b_in, double c_in); double perimeter() const { return this-> + this->b + this->c; } void scale(double s) { this->a *= s; this->b *= s; this->c *= s; } };",'1270,'74.16992188
'81,'Text 917,"'The class has member variables for the length of each side, defining the data representation. We defer discussion of the public: and Triangle .) lines for now. Below those lines are member functions for computing the perimeter of a triangle and scaling it by a factor.",'1271,'95.26367188
'81,'Text 918,"'The following is an example of creating and using a Triangle object:",'1272,'86.08398438
'81,'Text 919,"'int main() { Triangle t1(3, 4, 5); t1.scale(2); cout << t1.perimeter() << endl }",'1273,'90.86914063
'81,'Page number 78,"'76",'1274,'87.01171875
'82,'Header 76,"'Programming and Data Structures, Release 0.3",'1275,'54.29687500
'82,'Text 920,"'We initialize a triangle by passing in the side lengths as part of its declaration. We can then scale a triangle by using the same dot syntax we saw for accessing a member variable: <object>. <function> (<arguments>).",'1276,'96.82617188
'82,'Text 921,"'Before we discuss the details of what the code is doing, let us compare elements of the C-style definition and use of the triangle ADT with the C++ version. The following contrasts the definition of an ADT function between the two styles:",'1277,'94.04296875
'82,'Text 922,"'C-Style Struct",'1278,'34.37500000
'82,'Section header 48,"'C++ Class",'1279,'70.06835938
'82,'Table 23,"",'1280,'33.49609375
'82,'Text 923,"'The following compares how objects are created and manipulated:",'1281,'80.07812500
'82,'Table 24,"",'1282,'33.03222656
'82,'Text 924,"'With the C-style struct, we defined a top-level Triangle_scale( function whose first argument is a pointer to the Triangle object we want to scale. With a C++ class, on the other hand, we define a scale () member function within the Triangle class itself. There is no need to prepend Triangle_, since it is clear that scale () is a member of the Triangle class. The member function also does not explicitly declare a pointer parameter instead, the C++ language adds an implicit this parameter that is a pointer to the Triangle object we are working on. We can then use the this pointer in the same way we used the explicit tri pointer in the C style.",'1283,'95.11718750
'82,'Text 925,"'As for using a Triangle object, in the C style, we had to separately create the Triangle object and then initialize it with a call to Triangle_init() In the C++ style, object creation and initialization are combined - we will see how later. When invoking an ADT function, in the C case we have to explicitly pass the address of the object we are working on. With the C++ syntax, the object is part of the syntax - it appears on the left-hand side of the dot, SO the compiler automatically passes its address as the this pointer of the scale member function.",'1284,'94.09179688
'82,'Text 926,"'The following contrasts the definitions of a function that treats the ADT object as const:",'1285,'74.85351563
'82,'Section header 49,"'C-Style Struct",'1286,'32.86132813
'82,'Section header 50,"'C++ Class",'1287,'53.90625000
'82,'Text 927,"'double Triangle_perimeter( const Triangle *tri) { return tri->a + tri->b + tri->c; }",'1288,'56.59179688
'82,'Text 928,"'class Triangle { double perimeter() const { return this->a + this->b + this->c; } };",'1289,'52.05078125
'82,'Page number 79,"'77",'1290,'81.68945313
'83,'Header 77,"'Programming and Data Structures, Release 0.3",'1291,'53.12500000
'83,'Section header 51,"'C-Style Struct",'1292,'58.49609375
'83,'Table 25,"",'1293,'58.78906250
'83,'Text 929,"'Stack",'1294,'90.67382813
'83,'Title 25,"'C++ Class",'1295,'40.91796875
'83,'Table 26,"",'1296,'81.68945313
'83,'Text 930,"'Stack",'1297,'77.19726563
'83,'Text 931,"'Figure 16.1: Memory layout when scaling a triangle in the C and C++ styles.",'1298,'93.26171875
'83,'Text 932,"'In the C style, we add the const keyword to the left of the * when declaring the explicit pointer parameter, resulting in tri being a pointer to const. In the C++ style, we don't have an explicit parameter where we can add the const keyword. Instead, we place the keyword after the parameter list for the function. The compiler will then make the implicit this parameter a pointer to const, as if it were declared with the type const Triangle * This allows us to call the member function on a const Triangle:",'1299,'97.55859375
'83,'Text 933,"'const Triangle t1(3, 4, 5);",'1300,'38.57421875
'83,'Text 934,"'cout << t1.perimeter() << endl; // OK : this pointer is a pointer to const t1.scale(2) // ERROR: conversion from const to non-const",'1301,'59.61914063
'83,'Text 935,"'As with accessing member variables, we can use the arrow operator to invoke a member function through a pointer:",'1302,'91.25976563
'83,'Text 936,"'Triangle t1(3, 4, 5); const Triangle *ptr = &t1; cout << ptr->perimeter << endl; // OK : this pointer is a pointer to const ptr->scale(2) // ERROR: conversion from const to non-const",'1303,'57.95898438
'83,'Section header 52,"'16.1 Implicit this->",'1304,'81.98242188
'83,'Text 937,"'Since member variables and member functions are both located within the scope of a class, C++ allows us to refer to members from within a member function without the explicit this-> syntax. The compiler automatically inserts the member dereference for us:",'1305,'96.19140625
'83,'Table 27,"",'1306,'26.73339844
'83,'Footer 43,"'16.1. Implicit this->",'1307,'77.53906250
'83,'Page number 80,"'78",'1308,'86.81640625
'84,'Header 78,"'Programming and Data Structures, Release 0.3",'1309,'75.63476563
'84,'Text 938,"'(continued from previous page)",'1310,'67.48046875
'84,'Text 939,"'double perimeter() const { return a + + C; // Equivalent to: this->a + this->b + this->c } } ;",'1311,'74.16992188
'84,'Text 940,"'This is also the case for invoking other member functions. For instance, the following defines and uses functions to get each side length:",'1312,'94.72656250
'84,'Table 28,"",'1313,'28.41796875
'84,'Text 941,"'In both cases, the compiler can tell that we are referring to members of the class and therefore inserts the this->. However, if there are names in a closer scope that conflict with the member names, we must use this- -> ourselves. The following is an example:",'1314,'93.11523438
'84,'Text 942,"'class Triangle { double a; ... double set_side1(doublea a) { this->a = a; } };",'1315,'88.72070313
'84,'Text 943,"'Here, the unqualified a refers to the parameter a, since it is declared in a narrower scope than the member variable. We can still refer to the member a by qualifying its name with this->.",'1316,'92.87109375
'84,'Text 944,"'In general, we should avoid declaring variables in a local scope that hide names in an outer scope. Doing SO in a constructor or set function is often considered acceptable, but it should be avoided elsewhere.",'1317,'92.91992188
'84,'Footer 44,"'16.1. Implicit this - >",'1318,'45.14160156
'84,'Page number 81,"'79",'1319,'80.32226563
'85,'Header 79,"'Programming and Data Structures, Release 0.3",'1320,'68.75000000
'85,'Section header 53,"'16.2 Member Accessibility",'1321,'40.25878906
'85,'Text 945,"'The data representation of an ADT is usually an implementation detail (plain old data being an exception). With C- style structs, however, we have to rely on programmers to respect convention and avoid accessing member variables directly. With C++ classes, the language provides us a mechanism for enforcing this convention: declaring members as private prevents access from outside the class, while declaring them as public allows outside access. 1 We give a set of members a particular access level by placing private: or public: before the members - that access level applies to subsequent members until a new access specifier is encountered, and any number of specifiers may appear in a class. The following is an example:",'1322,'98.09570313
'85,'Table 29,"",'1323,'28.78417969
'85,'Text 946,"'In this example, the members a, b, and C are declared as private, while Triangle (), perimeter(), and scale () are declared as public. Private members, whether variables or functions, can be accessed from within the class, even if they are members of a different object of that class. They cannot be accessed from outside the class:",'1324,'90.86914063
'85,'Text 947,"'int main() { Triangle t1(3, 4, 5); // OK : Triangle() is public t1.scale(2); // OK : scale() is public cout << t1.perimeter() << endl; // OK : perimeter() is public // Die triangle! DIE! t1.a = -1; // ERROR: a is private }",'1325,'46.48437500
'85,'Text 948,"'With the class keyword, the default access level is private. Thus, the private: at the beginning of the Triangle definition is redundant, and the following is equivalent:",'1326,'94.67773438
'85,'Table 30,"",'1327,'27.27050781
'85,'Text 949,"'(continues on next page)",'1328,'51.17187500
'85,'Text 950,"'1 Later, we will discuss protected members that are accessible to derived classes. This access level, however, is rarely used.",'1329,'54.68750000
'85,'Footer 45,"'16.2. Member Accessibility",'1330,'53.80859375
'85,'Page number 82,"'80",'1331,'82.56835938
'86,'Header 80,"'Programming and Data Structures, Release 0.3",'1332,'70.89843750
'86,'Text 951,"'(continued from previous page)",'1333,'72.70507813
'86,'Text 952,"'Triangle(double a_in, double b_in, double c_in); };",'1334,'42.72460938
'86,'Text 953,"'We have seen previously that members declared within a struct are accessible from outside the struct. In fact, the only difference between the struct and class keywords when defining a class type is the default access level: public for struct but private for class.2 However. we use the two keywords for different conventions in this course.",'1335,'87.89062500
'86,'Section header 54,"'16.3 Constructors",'1336,'66.21093750
'86,'Text 954,"'A constructor is similar to a member function, except that its purpose is to initialize a class-type object. In most cases, C++ guarantees that a constructor is called when creating an object of class type. The following examples all call a constructor:",'1337,'94.87304688
'86,'Key value 21,"",'1338,'36.37695313
'86,'Text 955,"'As can be seen above, there are many forms of syntax for initializing a Triangle object, all of which call a constructor. When no arguments are provided, the zero-argument, or default, constructor is called. We will discuss this constructor in more detail later.",'1339,'96.48437500
'86,'Text 956,"'The following does not call a constructor:",'1340,'85.30273438
'86,'Text 957,"'Triangle t7(): // declares a function called t7 that returns a Triangle",'1341,'38.50097656
'86,'Text 958,"'In fact, it doesn't create an object at all. Instead, it declares a function named t7 that takes no arguments and returns a Triangle. A function declaration can appear at local scope, SO this is interpreted as a function declaration regardless of whether it is at local or global scope.",'1342,'96.63085938
'86,'Text 959,"'So far, we declared a single constructor for Triangle as follows:",'1343,'86.23046875
'86,'Table 31,"",'1344,'27.31933594
'86,'Text 960,"'2 This also applies to inheritance. We will see next time that private inheritance is the default for a class, and we will need to use the public keyword to override this. The default for a struct is public inheritance. 3 The exception is aggregate initialization, where an initializer list is used to directly initialize the members of a class-type object. This is only possible for aggregates, which are class types that have a restricted set of features. Our pattern of C-style structs obey the rules for an aggregate, though we define init functions instead of using aggregate initialization. Our convention of C++ classes results in class types that are not aggregates, SO objects of such types can only be initialized through a constructor. We can still use initializer-list syntax for a non-aggregate it will call a constructor with the values in the initializer list as arguments.",'1345,'60.69335938
'86,'Footer 46,"'16.3. Constructors",'1346,'60.93750000
'86,'Page number 83,"'81",'1347,'83.74023438
'87,'Header 81,"'Programming and Data Structures, Release 0.3",'1348,'79.68750000
'87,'Text 961,"'The syntax is similar to declaring a member function, except:",'1349,'96.82617188
'87,'List 21,"",'1350,'96.38671875
'87,'Text 962 - Part of List 21,"'There is no return type.",'1351,'96.53320313
'87,'Text 963 - Part of List 21,"'The name of the constructor is the same as the name of the class.",'1352,'98.24218750
'87,'Text 964,"'Like a member function, the constructor has an implicit this parameter that points to the object being initialized. As in a member function, we can leave out this-> to access a member, as long as there is no local name that hides the member. The following is a definition of the Triangle constructor:",'1353,'96.43554688
'87,'Table 32,"",'1354,'27.63671875
'87,'Text 965,"'However, there is a problem with the definition above: the statements in the body of the constructor perform assignment, not initialization. Thus, the member variables are actually default initialized and then assigned new values. In this case, it is a minor issue, but it can be more significant in other cases. In particular there are several kinds of variables that allow initialization but not assignment:",'1355,'93.94531250
'87,'List 22,"",'1356,'87.20703125
'87,'Text 966 - Part of List 22,"'arrays",'1357,'95.31250000
'87,'Text 967 - Part of List 22,"'references",'1358,'94.67773438
'87,'Text 968 - Part of List 22,"'const variables",'1359,'93.75000000
'87,'Text 969 - Part of List 22,"'class-type variables that disable assignment (e.g. streams)",'1360,'92.67578125
'87,'Text 970,"'Another case where initialization followed by assignment is problematic is for types where both initialization and assignment perform nontrivial operations - we lose efficiency by doing both when we only need initialization.",'1361,'92.82226563
'87,'Text 971,"'C++ provides two mechanisms for initializing a member variable:",'1362,'84.32617188
'87,'List 23,"",'1363,'77.19726563
'87,'Text 972 - Part of List 23,"'directly in the declaration of the variable, similar to initializing a non-member variable",'1364,'95.70312500
'87,'Text 973 - Part of List 23,"'through a member-initializer list",'1365,'93.60351563
'87,'Text 974,"'A member-initializer list is syntax specific to a constructor. It is a list of initializations that appear between a colon symbol and the constructor body:",'1366,'92.23632813
'87,'Table 33,"",'1367,'31.49414063
'87,'Footer 47,"'16.3. Constructors",'1368,'60.83984375
'87,'Page number 84,"'82",'1369,'83.88671875
'88,'Header 82,"'Programming and Data Structures, Release 0.3",'1370,'71.87500000
'88,'Text 975,"'An individual initialization consists of a member-variable name, followed by an initialization expression enclosed by parentheses (or curly braces). The constructor above initializes the member a to the value of a_in, b to the value of b_in, and C to the value of c_in. The constructor body is empty, since it has no further work to do.",'1371,'94.48242188
'88,'Text 976,"'If a member is initialized in both its declaration and a member-initializer list, the latter takes precedence, SO that the initialization in the member declaration is ignored.",'1372,'74.02343750
'88,'Section header 55,"'16.4 Default Initialization and Default Constructors",'1373,'66.55273438
'88,'Text 977,"'Every object in C++ is initialized upon creation, whether the object is of class type or not. If no explicit initialization is provided, it undergoes default initialization. Default initialization does the following:",'1374,'92.38281250
'88,'List 24,"",'1375,'94.72656250
'88,'Text 978 - Part of List 24,"'Objects of atomic type (e.g. int, double, pointers) are default initialized by doing nothing. This means they retain whatever value was already there in memory. Put another way, atomic objects have undefined values when they are default initialized.",'1376,'97.50976563
'88,'Text 979 - Part of List 24,"'An array is default initialized by in turn default initializing its elements. Thus, an array of atomic objects is default initialized by doing nothing, resulting in undefined element values.",'1377,'97.65625000
'88,'Text 980 - Part of List 24,"'A class-type object is default initialized by calling the default constructor, which is the constructor that takes no arguments. If no such constructor exists, or if it is inaccessible (e.g. it is private), a compile-time error results.",'1378,'95.94726563
'88,'Text 981 - Part of List 24,"'An array of class-type objects is default initialized by calling the default constructor on each element. Thus, the element type must have an accessible default constructor in order to create an array of that type.",'1379,'93.06640625
'88,'Text 982,"'Within a class, if a member variable is neither initialized at declaration nor in the member-initializer list of a constructor, it is default initialized.",'1380,'94.87304688
'88,'Text 983,"'The default constructor is SO named because it is invoked in default initialization, and it takes no arguments. We can define a default constructor for Triangle as follows, making the design decision to initialize the object as a 1x1x1 equilateral triangle:",'1381,'96.04492188
'88,'Text 984,"'class Triangle { double a; double b; double C;",'1382,'37.37792969
'88,'Section header 56,"'public:",'1383,'46.48437500
'88,'Text 985,"'// default constructor Triangle() : a(1), b(1), c(1) {} // non-default constructor Triangle(double a_in, double b_in, double c_in) : a(a_in), b(b_in), c(c_in) {} };",'1384,'51.66015625
'88,'Text 986,"'A class can have multiple constructors. This is a form of function overloading, which we will return to in the future. The compiler determines which compiler to invoke based on the arguments that are provided when creating a Triangle object:",'1385,'90.57617188
'88,'Text 987,"'Triangle t1; // 1x1x1 calls zero-argument (default) constructor Triangle t2(3, 4, 5) // 3x4x5 - - calls three-argument constructor",'1386,'58.39843750
'88,'Footer 48,"'16.4. Default Initialization and Default Constructors",'1387,'79.29687500
'88,'Page number 85,"'83",'1388,'86.81640625
'89,'Header 83,"'Programming and Data Structures, Release 0.3",'1389,'68.70117188
'89,'Section header 57,"'16.4.1 Implicit Default Constructor",'1390,'43.77441406
'89,'Text 988,"'If a class declares no constructors at all, the compiler provides an implicit default constructor. The behavior of this constructor is as if it were empty, SO that it default initializes each member variable:",'1391,'98.09570313
'89,'Section header 58,"'struct Person {",'1392,'45.99609375
'89,'Text 989,"'string name; int age; bool is_ninja; // implicit default constructor // Person {} // default initializes each member variable }; int main() { Person elise // calls implicit default constructor cout elise.name; // prints nothing. default ctor for string makes it empty cout elise.age; // prints undefined value cout << elise.is_ninja; // prints undefined value };",'1393,'37.57324219
'89,'Text 990,"'If a class declares any constructors whatsoever, no implicit default constructor is provided:",'1394,'78.80859375
'89,'Table 34,"",'1395,'34.91210938
'89,'Text 991,"'In this case, if we want our type to have a default constructor, we have to explicitly write one:",'1396,'70.16601563
'89,'Table 35,"",'1397,'27.39257813
'89,'Text 992,"'(continues on next page)",'1398,'70.06835938
'89,'Footer 49,"'16.4. Default Initialization and Default Constructors",'1399,'79.24804688
'89,'Page number 86,"'84",'1400,'79.73632813
'90,'Header 84,"'Programming and Data Structures, Release 0.3",'1401,'50.48828125
'90,'Text 993,"'(continued from previous page)",'1402,'82.91015625
'90,'Text 994,"'Triangle() : a(1), b(1), c(1) {}",'1403,'60.49804688
'90,'Text 995,"'// non-default constructor Triangle(double a_in, double b_in, double c_in) : a(a_in), b(b_in), c(c_in) {}",'1404,'41.40625000
'90,'Text 996,"'double perimeter() const { return a + b + C; }",'1405,'38.98925781
'90,'Text 997,"'void scale (double s) {",'1406,'99.86119080
'90,'Text 998,"'a *= s;",'1407,'99.69244385
'90,'Text 999,"'b *= s;",'1408,'99.95061493
'90,'Text 1000,"'C *= s;",'1409,'99.98857880
'90,'Text 1001,"'}",'1410,'99.12995911
'90,'Text 1002,"'};",'1411,'89.12647247
'90,'Text 1003,"'int main() {",'1412,'99.88611603
'90,'Text 1004,"'Triangle t1; // OK : explicit default constructor",'1413,'99.76516724
'90,'Text 1005,"'}",'1414,'90.23417664
'90,'Section header 59,"'16.5 Get and Set Functions",'1415,'76.41601563
'90,'Text 1006,"'With C++ classes, member variables are usually declared private, since they are implementation details. However, many C++ ADTs provide a means of accessing the abstract data through get and set functions (also called getters and setters or accessor functions). These are provided as part of the interface as an abstraction over the underlying data. The following are examples for Triangle:",'1416,'96.67968750
'90,'Table 36,"",'1417,'34.81445313
'90,'Text 1007,"'If the implementation changes, the interface can remain the same, SO that outside code is unaffected:",'1418,'74.21875000
'90,'Footer 50,"'16.5. Get and Set Functions",'1419,'61.62109375
'90,'Page number 87,"'85",'1420,'84.03320313
'91,'Title 26,"'Programming and Data Structures, Release 0.3",'1421,'47.26562500
'91,'Text 1008,"'class Triangle { double side1; // new names double side2; double side3; public: // EFFECTS: Returns side a of the triangle. double get_a() const { // same interface return side1; // different implementation } // REQUIRES: a_in > O && a_in < get_b() + get_c() // MODIFIES: *this // EFFECTS: Sets side a of the triangle to a_in. void set_a(double a_in) { side1 = a_in; } };",'1422,'66.01562500
'91,'Text 1009,"'With a set function, we've introduced a new location from which the representation can be modified. We need to ensure that the representation invariants are still met. We can do SO by writing and using a private function to check the invariants:",'1423,'96.43554688
'91,'Table 37,"",'1424,'51.17187500
'91,'Text 1010,"'It is good practice to check the invariants anywhere the representation can be modified. Here, we have done SO in both the constructor and in the set function.",'1425,'86.71875000
'91,'Footer 51,"'16.5. Get and Set Functions",'1426,'81.25000000
'91,'Page number 88,"'86",'1427,'80.51757813
'92,'Header 85,"'Programming and Data Structures, Release 0.3",'1428,'80.37109375
'92,'Section header 60,"'16.6 Information Hiding",'1429,'42.16308594
'92,'Text 1011,"'Good abstraction design uses encapsulation, which groups together both the data and functions of an ADT. With a class, we get encapsulation by defining both member variables and member functions.",'1430,'95.75195313
'92,'Text 1012,"'A proper abstraction also provides information hiding, which separates interface from implementation. Access speci- fiers such as private allow us to prevent the outside world from accessing implementation details.",'1431,'91.69921875
'92,'Text 1013,"'We can further hide information from the sight of the users of an ADT by physically separating the code for the interface from the code for the implementation. The standard mechanism to do SO in C++ is to place declarations in header files and definitions in source files. With a class, we place a class definition that only contains member declarations in the header file:",'1432,'93.60351563
'92,'Key value 22,"",'1433,'66.89453125
'92,'Text 1014,"'It is also generally preferable to declare the public members of the class before private members, SO that users do not have to skip over implementation details to find the public interface.",'1434,'86.47460938
'92,'Text 1015,"'We then define the constructors and member functions outside of the class definition, in the corresponding source file. In order to define a member function outside of a class, we need two things:",'1435,'88.62304688
'92,'List 25,"",'1436,'56.20117188
'92,'Text 1016 - Part of List 25,"'1) A declaration of the function within the class, SO that the compiler (and other programmers) can tell that the member exists.",'1437,'95.45898438
'92,'Text 1017 - Part of List 25,"'2) Syntax in the definition that tells the compiler that the function is a member of the associated class and not a top-level function.",'1438,'91.74804688
'92,'Text 1018,"'The latter is accomplished by prefixing the member name with the class name, followed by the scope-resolution oper- ator:",'1439,'90.08789063
'92,'Footer 52,"'16.6. Information Hiding",'1440,'73.77929688
'92,'Page number 89,"'87",'1441,'83.44726563
'93,'Header 86,"'Programming and Data Structures, Release 0.3",'1442,'40.82031250
'93,'Text 1019,"'// Triangle.cpp #include ""Triangle.hpp""",'1443,'63.76953125
'93,'Text 1020,"'Triangle::Triangle() : a(1),b(1),c(1){}",'1444,'74.75585938
'93,'Text 1021,"'Triangle::Triangle(double a_in, double b_in, double c_in) : 1(a_in),b(b_in),c(c_in){}",'1445,'74.07226563
'93,'Text 1022,"'double Triangle: :perimeter() const { return a + b + C; }",'1446,'65.47851563
'93,'Text 1023,"'void Triangle::scale(doubles) a *=s; b * = s; C *= s; }",'1447,'50.09765625
'93,'Text 1024,"'This tells the compiler that the two constructors, as well as the perimeter () and scale () functions, are members of the Triangle class.",'1448,'92.08984375
'93,'Section header 61,"'16.7 Testing a C++ ADT",'1449,'85.69335938
'93,'Text 1025,"'We test a C++ ADT by writing test cases that live outside of the ADT itself. C++ forces us to respect the interface, since the implementation details are private:",'1450,'96.72851563
'93,'Text 1026,"'// Triangle_tests.cpp #include ""Triangle.hpp"" #include ""unit_test_framework.hpp""",'1451,'75.14648438
'93,'Text 1027,"'TEST(test_triangle_basic) { Trianglet(3,4,5); ASSERT_EQUAL(t.area(), 6); ASSERT_EQUAL(t.get_a(), 3); // must use get and set functions t.set_a(4); ASSERT_EQUAL(t.get_a(), 4); } TEST_MAIN()",'1452,'72.31445313
'93,'Footer 53,"'16.7. Testing a C++ ADT",'1453,'84.22851563
'93,'Page number 90,"'88",'1454,'80.37109375
'94,'Header 87,"'Programming and Data Structures, Release 0.3",'1455,'50.19531250
'94,'Section header 62,"'16.8 Member-Initialization Order",'1456,'63.52539063
'94,'Text 1028,"'Member variables are always initialized in the order in which they are declared in the class. This is the case regardless if some members are initialized at the declaration point and others are not, or if a constructor's member-initializer list is out of order:",'1457,'97.85156250
'94,'Text 1029,"'class Triangle { double a; double b; double C; Triangle(double a_in, double b_in, double c_in) : b(b_in), c(c_in), a(a_in) { // this ordering is ignored } };",'1458,'32.47070313
'94,'Section header 63,"'public:",'1459,'29.61425781
'94,'Text 1030,"'Here, a is initialized first to a_in, then b to b_in, then C to c_in; the ordering in the member-initializer list is ignored. Some compilers will generate a warning if the order differs between the member declarations and the member-initializer list:",'1460,'87.45117188
'94,'Text 1031,"'$ g++ --std=c++17 -Wall Triangle.cpp Triangle.cpp 8:16: warning: field 'c' will be initialized after field 'a' [-Wreorder] : b(b_in), c(c_in), a(a_in) { // this ordering is ignored",'1461,'88.86718750
'94,'Section header 64,"'16.9 Delegating Constructors",'1462,'85.30273438
'94,'Text 1032,"'When a class has multiple constructors, it can be useful to invoke one constructor from another. This allows us to avoid code duplication, and it also makes our code more maintainable by reducing the number of places where we hardcode implementation details.",'1463,'95.99609375
'94,'Text 1033,"'In order to delegate to another constructor, we must do SO in the member-initializer list. The member-initializer list must consist solely of the call to the other constructor:",'1464,'91.01562500
'94,'Table 38,"",'1465,'25.34179688
'94,'Text 1034,"'The delegation must be in the member-initializer list. If we invoke a different constructor from within the body, it does not do delegation; rather, it creates a new, temporary object and then throws it away:",'1466,'77.78320313
'94,'Footer 54,"'16.8. Member-Initialization Order",'1467,'47.75390625
'94,'Page number 91,"'89",'1468,'78.85742188
'95,'Header 88,"'Programming and Data Structures, Release 0.3",'1469,'52.63671875
'95,'Text 1035,"'Triangle (double side_in) { // default initializes members Triangle(side_in, , side_in, side_in) ; // creates a new Triangle object that // lives in the activation record for // this constructor",'1470,'43.50585938
'95,'Text 1036,"'}",'1471,'36.03515625
'95,'Footer 55,"'16.9. Delegating Constructors",'1472,'57.95898438
'95,'Page number 92,"'90",'1473,'72.31445313
'96,'Header 89,"'CHAPTER",'1474,'49.21875000
'96,'Header 90,"'SEVENTEEN",'1475,'49.31640625
'96,'Title 27,"'DERIVED CLASSES AND INHERITANCE",'1476,'89.89257813
'96,'Text 1037,"'In addition to encapsulation and information hiding, C++ classes provide two features that are fundamental to object- oriented programming:",'1477,'96.28906250
'96,'List 26,"",'1478,'90.13671875
'96,'Text 1038 - Part of List 26,"'Inheritance: the ability for a class to reuse the interface or functionality of another class.",'1479,'97.46093750
'96,'Text 1039 - Part of List 26,"'Subtype polymorphism: the ability to use an object of a more specific type where an object of a more general type is expected.",'1480,'98.48632813
'96,'Text 1040,"'We will discuss inheritance today, deferring subtype polymorphism until next time.",'1481,'91.65039063
'96,'Text 1041,"'To motivate the concept of inheritance, consider the following definitions of Chi cken and Duck ADTs:",'1482,'94.62890625
'96,'Text 1042,"'class Chicken { public: Chicken(const string &name_in) : age(0), name(name_in), roads_crossed(0) { cout << ""Chicken ctor"" << endl; } string get_name () const return name; } int get_age() const return age; } void cross_road() { ++roads_crossed; } void talk() const { cout << ""bawwk"" << endl; } private: int age; string name; int roads_crossed; };",'1483,'39.94140625
'96,'Text 1043,"'class Duck { public: Duck(const string &name_in) : age(0), name (name_in), num_ducklings(0) { cout << ""Duck ctor""< endl; } string get_name const { return name; } int get_age() const { return age; } void have_babies () { num_ducklings += 7; } void talk() const { cout ""quack"" endl; } private: int age; string name; int num_ducklings; };",'1484,'25.12207031
'96,'Page number 93,"'91",'1485,'82.76367188
'97,'Header 91,"'Programming and Data Structures, Release 0.3",'1486,'78.12500000
'97,'Text 1044,"'The two ADTs are nearly identical - both have age and name member variables, with their corresponding get functions, and both have a talk () member function that makes the appropriate chicken or duck sound. In terms of differences, chickens tend to cross roads (since they don't fly very well), SO we keep track of how often they do that. On the other hand, ducks are often accompanied by their ducklings, SO we keep track of how many they have.",'1487,'98.63281250
'97,'Text 1045,"'Intuitively, it makes sense for cken and Duck to share a lot of functionality, since chickens and ducks are both types of birds.",'1488,'89.11132813
'97,'Figure 29,"",'1489,'93.60351563
'97,'Text 1046,"'Figure 17.1: Relationship between different kinds of birds.",'1490,'83.74023438
'97,'Text 1047,"'This ""is-a"" relationship, where a Chicken is a Bird and a Duck is also a Bird, can be encoded with inheritance. We write Bird as a base class, then write Chicken and Duck as classes that inherit or derive from Bird. We place the common functionality in Bird, which then gets inherited by the derived classes.",'1491,'96.19140625
'97,'Table 39,"",'1492,'26.90429688
'97,'Text 1048,"'Here, all birds have a name and an age, and the generic sound a bird makes is ""tweet"". For more a more specific kind of bird, we obtain the functionality of the base class by deriving from it:",'1493,'78.85742188
'97,'Page number 94,"'92",'1494,'90.23437500
'98,'Title 28,"'Programming and Data Structures, Release 0.3",'1495,'45.70312500
'98,'Text 1049,"'class Chicken : public Bird { };",'1496,'69.82421875
'98,'Text 1050,"'The syntax for deriving from a base class is to put a colon after the name of the derived class, then the public keyword, then the name of the base class. This results in public inheritance, where it is part of the interface of Chicken that it derives from Bird. Without the public keyword, it would be private inheritance¹, where it is an implementation detail and not part of the interface that Chicken derives from Bird.",'1497,'97.31445313
'98,'Text 1051,"'Now that Chicken derives from Bird, it inherits the functionality of the Bird class, and the public interface of Bird is also supported by Chicken:",'1498,'93.21289063
'98,'Text 1052,"'Chicken c(""Myrtle""), ; c.have_birthday() ; cout << c.get_name << "" "" c.get_age ; // prints Myrtle 1",'1499,'68.26171875
'98,'Text 1053,"'Functionality that is specific to a particular kind of bird goes in the class for that bird:",'1500,'89.30664063
'98,'Text 1054,"'class Chicken : public Bird { public: void cross_road() { ++roads_crossed; } void talk() const { cout << ""bawwk"" << endl; } private: int roads_crossed; };",'1501,'42.06542969
'98,'Text 1055,"'Here, we have the additional data member roads_crossed; name and age are inherited from Bird. (They are not directly accessible from the Chicken class, however, since they are private. We will come back to this later.) Figure 17.2 illustrates the layout of Bird and Chicken in memory.",'1502,'91.35742188
'98,'Text 1056,"'int main() { Bird big_bird(""Big ] Bird"") Chicken myrtle(""Myrtle"") }",'1503,'70.99609375
'98,'Text 1057,"'The memory of Chicken actually consists of a Bird piece, plus the additional Chicken members. Thus, the data members defined by Bird are also included in a Chicken.",'1504,'87.59765625
'98,'Text 1058,"'In order to properly initialize a derived-class object, its constructor must ensure that its base-class subobject is also appropriately initialized. The base class may have private member variables, which cannot be accessed from the derived class, SO the derived class does not initialize the inherited members directly. Instead, it invokes a base-class constructor in the member-initializer list of its own constructors:",'1505,'94.14062500
'98,'Text 1059,"'1 As with member accessibility, the default inheritance is public if the struct keyword is used to define a class type and private if the class keyword is used. With private inheritance, the (non-private) inherited members are private to the derived class, SO that outside code may not access those members. There is also protected inheritance, where classes that derive from the derived class can access the (non-private) inherited members of the derived class, but outside code cannot.",'1506,'87.01171875
'98,'Page number 95,"'93",'1507,'77.05078125
'99,'Header 92,"'Programming and Data Structures, Release 0.3",'1508,'51.26953125
'99,'Figure 30,"",'1509,'96.24023438
'99,'Text 1060,"'Stack",'1510,'59.81445313
'99,'Text 1061,"'Figure 17.2: The layout of a derived-class object contains a subset that matches the layout of a base-class object.",'1511,'95.21484375
'99,'Text 1062,"'class Chicken : public Bird { public:",'1512,'32.03125000
'99,'Text 1063,"'Chicken (const string &name_in) : Bird(name_in), roads_crossed(0) { cout << ""Chicken ctor"" << endl; }",'1513,'43.96972656
'99,'Text 1064,"'private: int roads_crossed; };",'1514,'50.00000000
'99,'Text 1065,"'In C++, a derived-class constructor always invokes a constructor for the base class. If an explicit invocation does not appear in the member-initializer list, there is an implicit call to the default constructor. If the base class has no default constructor, an error results:",'1515,'97.41210938
'99,'Text 1066,"'class Chicken : public Bird { public: Chicken(const string &name_in) : roads_crossed(0) { // ERROR: implicit call to Bird(), which doesn't exist cout << ""Chicken ctor"" << endl; } };",'1516,'94.58007813
'99,'Text 1067,"'For completeness, the following is an implementation of Duck as a derived class of Bird:",'1517,'92.13867188
'99,'Text 1068,"'class Duck : public Bird { public: Duck(const string &name_in)",'1518,'93.11523438
'99,'Text 1069,"'(continues on next page)",'1519,'74.31640625
'99,'Page number 96,"'94",'1520,'91.25976563
'100,'Header 93,"'Programming and Data Structures, Release 0.3",'1521,'71.48437500
'100,'Text 1070,"'(continued from previous page)",'1522,'77.92968750
'100,'Text 1071,"': Bird(name_in), num_ducklings(0) { cout << ""Duck ctor"" << endl } void have_babies () { num_ducklings += 7; } void talk() const { cout << ""quack"" << endl; } private: int num_ducklings; };",'1523,'28.68652344
'100,'Text 1072,"'By writing Bird and deriving from it in both Chicken and Duck, we have avoided duplication of the shared function- ality.",'1524,'75.97656250
'100,'Section header 65,"'17.1 Ordering of Constructors and Destructors",'1525,'62.98828125
'100,'Text 1073,"'We have already seen that in most cases, a constructor is invoked when a class-type object is created. Similarly, a destructor is invoked when a class-type object's lifetime is over. For a local variable, this is when the variable goes out of scope. The following illustrates an example:",'1526,'93.01757813
'100,'Text 1074,"'class Foo { public:",'1527,'25.56152344
'100,'Text 1075,"'Foo() // constructor cout << ""Foo ctor"" << endl ; } ~Foo () // destructor cout ""Foo dtor"" << endl; } } void func() { Foo x; } int main() { cout << ""before call"" << endl; func() cout << ""after call"" << endl; }",'1528,'44.45800781
'100,'Text 1076,"'The class Foo has a custom destructor, written as ~Foo(), which runs when a Foo object is dying. Here, we just have both the constructor and destructor print messages to standard out. The following is printed when the code is run:",'1529,'85.05859375
'100,'Text 1077,"'before call Foo ctor",'1530,'60.93750000
'100,'Text 1078,"'(continues on next page)",'1531,'75.14648438
'100,'Footer 56,"'17.1. Ordering of Constructors and Destructors",'1532,'65.82031250
'100,'Page number 97,"'95",'1533,'87.25585938
'101,'Header 94,"'Programming and Data Structures, Release 0.3",'1534,'57.47070313
'101,'Text 1079,"'(continued from previous page)",'1535,'60.20507813
'101,'Text 1080,"'Foo dtor after call",'1536,'58.59375000
'101,'Text 1081,"'We will cover destructors in more detail later in the course. For now, we concern ourselves solely with the order in which constructors and destructors execute when we have derived classes.",'1537,'96.72851563
'101,'Text 1082,"'When there are multiple objects that are constructed and destructed, C++ follows a ""socks-and-shoes"" ordering: when we put on socks and shoes in the morning, we put on socks first, then our shoes. In the evening, however, when we take them off, we do SO in the reverse order: first our shoes, then our socks. In the case of a derived class, C++ will always construct the base-class subobject before initializing the derived-class pieces. Destruction is in the reverse order: first the derived-class destructor runs, then the base-class one. The following illustrates this order:",'1538,'96.43554688
'101,'Table 40,"",'1539,'37.10937500
'101,'Text 1083,"'The following results from running the code:",'1540,'66.89453125
'101,'Text 1084,"'construction: Bird ctor Chicken ctor destruction: Chicken dtor",'1541,'73.38867188
'101,'Text 1085,"'(continues on next page)",'1542,'72.11914063
'101,'Footer 57,"'17.1. Ordering of Constructors and Destructors",'1543,'60.93750000
'101,'Page number 98,"'96",'1544,'78.71093750
'102,'Header 95,"'Programming and Data Structures, Release 0.3",'1545,'47.16796875
'102,'Text 1086,"'(continued from previous page)",'1546,'52.44140625
'102,'Text 1087,"'Bird dtor",'1547,'52.73437500
'102,'Text 1088,"'When creating a Chicken object, the invocation of the Bird constructor is the first thing that happens in the Chicken constructor. This is true regardless of whether or not an explicit call to the Bird constructor appears, and regardless of ordering of the member-initializer list. Then the rest of the Chicken constructor runs. When a Chicken object is dying, first the code in the Chicken destructor runs. Then the code in the Bird destructor automatically runs. (It is generally erroneous to invoke the base-class destructor explicitly, since the compiler always does SO implicitly.)",'1548,'97.31445313
'102,'Text 1089,"'The following code creates both a Chicken and a Duck object:",'1549,'88.33007813
'102,'Figure 31,"",'1550,'27.00195313
'102,'Text 1090,"'int main() { cout << ""construction:"" << endl; Chicken myrtle (""Myrtle"") ; Duck donald(""Donald"") cout << ""destruction:"" << endl; }",'1551,'90.77148438
'102,'Text 1091,"'Assuming that Duck has a destructor that prints out ""Duck dtor"", the code prints the following:",'1552,'90.82031250
'102,'Text 1092,"'construction: Bird ctor Chicken ctor Bird ctor Duck ctor destruction: Duck dtor Bird dtor Chicken dtor Bird dtor",'1553,'93.84765625
'102,'Text 1093,"'We see the same ordering in Duck construction and destruction. Furthermore, we see that because myrtle is con- structed before donald, it is destructed after donald - socks-and-shoes ordering here as well.",'1554,'96.43554688
'102,'Section header 66,"'17.2 Name Lookup and Hiding",'1555,'88.42773438
'102,'Text 1094,"'When a member access is applied to an object, the compiler follows a specific process to look up the given name:",'1556,'96.33789063
'102,'List 27,"",'1557,'95.55664063
'102,'Text 1095 - Part of List 27,"'The compiler starts by looking for a member with that name in the compile-time or static type of the object. (We will discuss static and dynamic types next time.)",'1558,'97.80273438
'102,'Text 1096 - Part of List 27,"'If no member with that name is found, the compiler repeats the process on the base class of the given type. If the type has no base class, a compiler error is generated.",'1559,'97.36328125
'102,'Text 1097 - Part of List 27,"'If a member with the given name is found, the compiler then checks whether or not the member is accessible and whether the member can be used in the given context.2 If not, a compiler error is generated - the lookup process does not proceed further.",'1560,'97.07031250
'102,'Text 1098,"'As an example, consider the following member accesses:",'1561,'90.91796875
'102,'Text 1099,"'Chicken myrtle(""Myrtle""); myrtle.get_age()",'1562,'73.87695313
'102,'Text 1100,"'(continues on next page)",'1563,'84.76562500
'102,'Footer 58,"'2 If name lookup finds a set of overloaded functions within the same class, the compiler performs overload resolution to determine which overload is the most appropriate. We will discuss function overloading in more detail next time.",'1564,'56.49414063
'102,'Footer 59,"'17.2. Name Lookup and Hiding",'1565,'68.01757813
'102,'Page number 99,"'97",'1566,'87.20703125
'103,'Header 96,"'Programming and Data Structures, Release 0.3",'1567,'62.98828125
'103,'Text 1101,"'(continued from previous page)",'1568,'73.38867188
'103,'Text 1102,"'myrtle.talk myrtle.age; myrtle.undefined;",'1569,'46.19140625
'103,'List 28,"",'1570,'93.35937500
'103,'Text 1103 - Part of List 28,"'For myrtle.get_age(), the compiler first looks for a get_age member defined in the hicken class. Since Chicken does not define such a member, the compiler looks for a get_age member in its base Bird class. There is indeed a get_age member in Bird, SO the compiler then checks that the member is accessible and is a function that can be called with no arguments. These checks succeed, SO the lookup process terminates successfully.",'1571,'96.77734375
'103,'Text 1104 - Part of List 28,"'For myrtle. talk() the compiler looks for a talk member in Chicken. There is one, SO it then checks to make sure it is accessible and is a function that can be called with no arguments. This succeeds, and at runtime, it is Chicken: talk() that is called. The function Bird: : talk() is hidden, since the name lookup process never gets to it.",'1572,'97.16796875
'103,'Text 1105 - Part of List 28,"'myrtle age, the compiler looks for an age member in Chicken. There is none, SO the compiler looks in Bird. There is such a member, SO the compiler checks whether it is accessible from the given context. The member is private, SO this check fails, and the compiler reports an error.",'1573,'97.46093750
'103,'Text 1106 - Part of List 28,"'For myrtle.undefined, the compiler looks for an undefined member in Chicken. There is none, SO the compiler looks in Bird. There is no such member, and Bird has no base class, SO the compiler reports an error.",'1574,'97.85156250
'103,'Text 1107,"'As another example, consider the following code:",'1575,'74.07226563
'103,'Text 1108,"'class Base { public: int X; void foo (const string &s) }; class Derived : public Base { public: void x() ; void foo (int i) ; }; int main() { Derived d; int a d.x; d. foo (""hello"") }",'1576,'53.51562500
'103,'Text 1109,"'When looking up d.x. the compiler finds a member X in Derived. However, it is a member function, which cannot be assigned to an int. Thus, the compiler reports an error it does not consider the hidden X that is defined in Base.",'1577,'92.91992188
'103,'Text 1110,"'Similarly, when looking up d. foo, the compiler finds a member foo in Derived. Though it is a function, it cannot be called with a string literal, SO the compiler reports an error. Again, the compiler does not consider the foo that is defined in Base; that member is hidden by the foo defined in Derived.",'1578,'96.77734375
'103,'Text 1111,"'To summarize, C++ does not consider the context in which a member is used until after its finds a member of the given name. This is in contrast to some other languages, which consider context in the lookup process itself.",'1579,'94.53125000
'103,'Text 1112,"'On occasion, we wish to access a hidden member rather than the member that hides it. The most common case is when a derived-class version of a function calls the base-class version as part of its functionality. The following illustrates this in Chicken:",'1580,'95.84960938
'103,'Footer 60,"'17.2. Name Lookup and Hiding",'1581,'74.41406250
'103,'Page number 100,"'98",'1582,'81.34765625
'104,'Header 97,"'Programming and Data Structures, Release 0.3",'1583,'56.68945313
'104,'Text 1113,"'class Chicken : public Bird { public: void talk() const if E (age >= 1) { // ERROR: age is private in Bird cout ""bawwk"" << endl; } else { // baby chicks make more of a tweeting rather than clucking noise Bird::talk(); // call Bird's version of talk() } } };",'1584,'25.26855469
'104,'Text 1114,"'By using the scope-resolution operator, we are specifically asking for the Bird version of talk (), enabling access to it even though it is hidden. 3",'1585,'91.40625000
'104,'Text 1115,"'The code above does have a problem: it accesses the age member of Bird, which, though it is not hidden, is private and SO not accessible to Chicken. There are two solutions to this problem:",'1586,'94.62890625
'104,'List 29,"",'1587,'92.57812500
'104,'Text 1116 - Part of List 29,"'We can declare age to be protected, which allows derived classes of Bird to access the member but not the outside world.",'1588,'98.09570313
'104,'Text 1117 - Part of List 29,"'We can use the public get_age () function instead.",'1589,'97.80273438
'104,'Text 1118,"'The former strategy is not desirable; since the member variable age is an implementation detail, making it protected exposes implementation details to the derived classes. Instead, we should use a get function to abstract the implemen- tation detail. We could choose to make such a function protected, SO that it is part of the interface that derived classes have access to but not the outside world. For age, we already have a public get function, SO we can just use that:",'1590,'97.75390625
'104,'Text 1119,"'class Chicken : public Bird { public: void talk() const { if (get_age() { cout << ""bawwk"" << endl; } else { // baby chicks make more of a tweeting rather than clucking noise Bird::talk(); // call Bird's version of talk() } } }",'1591,'85.25390625
'104,'Footer 61,"'3 Interestingly, we can apply the scope-resolution operator as part of dot or arrow syntax in order to access the base-class version: myrtle. Bird: : talk(). However, this is very uncommon in real code, and we will not do it at all in this course.",'1592,'49.21875000
'104,'Footer 62,"'17.2. Name Lookup and Hiding",'1593,'67.72460938
'104,'Page number 101,"'99",'1594,'86.57226563
'105,'Text 1120,"'CHAPTER",'1595,'66.69921875
'105,'Text 1121,"'EIGHTEEN",'1596,'51.07421875
'105,'Text 1122,"'POLYMORPHISM",'1597,'54.78515625
'105,'Text 1123,"'The word polymorphism literally means ""many forms."" In the context of programming, polymorphism refers to the ability of a piece of code to behave differently depending on the context in which it is used. Appropriately, there are several forms of polymorphism:",'1598,'97.94921875
'105,'List 30,"",'1599,'84.96093750
'105,'Text 1124 - Part of List 30,"'ad hoc polymorphism, which refers to function overloading",'1600,'98.09570313
'105,'Text 1125 - Part of List 30,"'parametric polymorphism in the form of templates",'1601,'96.97265625
'105,'Text 1126 - Part of List 30,"'subtype polymorphism, which allows a derived-class object to be used where a base-class object is expected",'1602,'97.41210938
'105,'Text 1127,"'The unqualified term ""polymorphism"" usually refers to subtype polymorphism.",'1603,'75.04882813
'105,'Text 1128,"'We proceed to discuss ad hoc and subtype polymorphism, deferring parametric polymorphism until later.",'1604,'90.23437500
'105,'Section header 67,"'18.1 Function Overloading",'1605,'88.76953125
'105,'Text 1129,"'Ad hoc polymorphism refers to function overloading, which is the ability to use a single name to refer to many different functions in a single scope. C++ allows both top-level functions and member functions to be overloaded. The following is an example of overloaded member functions:",'1606,'97.70507813
'105,'Text 1130,"'class Base { public: void foo(int a) ; int foo (string b) ; }; int main() { Base b; b. foo (42) b. foo (""test"") }",'1607,'89.30664063
'105,'Text 1131,"'When we invoke an overloaded function, the compiler resolves the function call by comparing the types of the arguments to the parameters of the candidate functions and finding the best match. The call b. foo (42) calls the member function foo () with parameter int, since 42 is an int. The call b. foo (""test"") calls the function with parameter string - ""test"" actually has type const char *, but a string parameter is a better match for a const char * than int.",'1608,'95.94726563
'105,'Text 1132,"'In C++, functions can only be overloaded when defined within the same scope. If functions of the same name are defined in a different scope, then those that are defined in a closer scope hide the functions defined in a further scope:",'1609,'90.42968750
'105,'Text 1133,"'class Derived : public Base { public:",'1610,'75.14648438
'105,'Text 1134,"'(continues on next page)",'1611,'78.22265625
'105,'Page number 102,"'100",'1612,'70.31250000
'106,'Header 98,"'Programming and Data Structures, Release 0.3",'1613,'70.50781250
'106,'Text 1135,"'(continued from previous page)",'1614,'56.59179688
'106,'Text 1136,"'int foo(int a) double foo(double b) } int main() { Derived d; d. foo (""test"") ; // ERROR }",'1615,'42.43164063
'106,'Text 1137,"'When handling the member access d. foo, under the name-lookup process we saw last time, the compiler finds the name foo in Derived. It then applies function-overload resolution; however, none of the functions with name foo can be invoked on a const char *, resulting in a compile error. The functions inherited from Base are not considered, since they were defined in a different scope.",'1616,'96.43554688
'106,'Text 1138,"'Function overloading requires the signatures of the functions to differ, SO that overload resolution can choose the over- load with the most appropriate signature. Here, ""signature"" refers to the function name and parameter types - the return type is not part of the signature and is not considered in overload resolution.",'1617,'93.16406250
'106,'Text 1139,"'class Person { public: void greet () ; void greet (int X) ; // OK void greet (string x) ; // OK void greet (int X, string s) ; // OK void greet(string s, int X) ; // OK bool greet () ; // ERROR: signature the same as the first overload void greet () const; // OK : implicit this parameter different };",'1618,'37.84179688
'106,'Text 1140,"'For member functions, the const keyword after the parameter list is part of the signature - it changes the implicit this parameter from being a pointer to non-const to a pointer to const. Thus, it is valid for two member-function overloads to differ solely in whether or not they are declared as const.",'1619,'96.19140625
'106,'Section header 68,"'18.2 Subtype Polymorphism",'1620,'87.54882813
'106,'Text 1141,"'Subtype polymorphism allows a derived-class object to be used where a base-class one is expected. In order for this to work, however, we need indirection. Consider what happens if we directly copy a Chicken object into a Bird:",'1621,'97.46093750
'106,'Section header 69,"'int main( {",'1622,'28.68652344
'106,'Text 1142,"'Chicken nicken(""Myrtle""), //... Bird bird = chicken; }",'1623,'82.86132813
'106,'Text 1143,"'While C++ allows this, the value of a Chicken does not necessarily fit into a Bird object, since a Chicken has more member variables than a Bird. The copy above results in object slicing - the members defined by Bird are copied, but the Chicken ones are not, as illustrated in Figure 18.1.",'1624,'96.28906250
'106,'Text 1144,"'To avoid slicing, we need indirection through a reference or a pointer, SO that we avoid making a copy:",'1625,'92.04101563
'106,'Text 1145,"'Bird &bird_ref = chicken; Bird *bird_ptr = &chicken;",'1626,'86.03515625
'106,'Footer 63,"'18.2. Subtype Polymorphism",'1627,'77.44140625
'106,'Page number 103,"'101",'1628,'79.39453125
'107,'Header 99,"'Programming and Data Structures, Release 0.3",'1629,'61.66992188
'107,'Figure 32,"",'1630,'95.99609375
'107,'Text 1146,"'Stack",'1631,'53.12500000
'107,'Text 1147,"'Figure 18.1: Object slicing copies only the members defined by the base class.",'1632,'93.70117188
'107,'Text 1148,"'The above initializes bird_ref as an alias for the chicken object. Similarly, bird_ptr is initialized to hold the address of the chicken object. In either case, a copy is avoided.",'1633,'95.99609375
'107,'Text 1149,"'C++ allows a reference or pointer of a base type to refer to an object of a derived type. It allows implicit upcasts, which are conversions that go upward in the inheritance hierarchy, such as from Chicken to Bird, as in the examples above. On the other hand, implicit downcasts are prohibited:",'1634,'96.58203125
'107,'Text 1150,"'Chicken &chicken_ref = bird_ref; // ERROR: implicit downcast Chicken *chicken_ptr = bird_ptr; // ERROR: implicit downcast",'1635,'70.55664063
'107,'Text 1151,"'The implicit downcasts are prohibited by C++ even thoughbird_refandbird_ptr actually refer to Chi cken objects. In the general case, they can refer to objects that aren't of Chicken type, such as Duck or just plain Bird objects. Since the conversions may be unsafe, they are disallowed by the C++ standard.",'1636,'98.09570313
'107,'Text 1152,"'While implicit downcasts are prohibited, we can do explicit downcasts with static_cast:",'1637,'94.38476563
'107,'Text 1153,"'Chicken &chicken_ref = static_cast<Chicken &> (bird_ref); Chicken *chicken_ptr = static_cast<Chicken (bird_ptr)",'1638,'66.35742188
'107,'Text 1154,"'These conversions are unchecked at runtime, SO we need to be certain from the code that the underlying object is a Chicken.",'1639,'97.46093750
'107,'Text 1155,"'In order to be able to bind a base-class reference or pointer to a derived-class object, the inheritance relationship must be accessible. From outside the classes, this means that the derived class must publicly inherit from the derived class. Otherwise, the outside world is not allowed to take advantage of the inheritance relationship. Consider this example:",'1640,'97.65625000
'107,'Table 41,"",'1641,'41.77246094
'107,'Text 1156,"'(continues on next page)",'1642,'48.33984375
'107,'Footer 64,"'18.2. Subtype Polymorphism",'1643,'71.77734375
'107,'Page number 104,"'102",'1644,'82.27539063
'108,'Header 100,"'Programming and Data Structures, Release 0.3",'1645,'50.97656250
'108,'Text 1157,"'(continued from previous page)",'1646,'74.85351563
'108,'Text 1158,"'A *a_ptr = &b; // ERROR: inheritance relationship is private }",'1647,'69.53125000
'108,'Text 1159,"'This results in a compiler error:",'1648,'71.92382813
'108,'Text 1160,"'main. cpp 9:16: error: cannot cast 'B' to its private base class 'A' A *a_ptr = &b; = // ERROR: inheritance relationship is private ^ main. pp:4:13: note: implicitly declared private here class B : A { // default is private when using the class keyword ^ 1 error generated.",'1649,'75.43945313
'108,'Section header 70,"'18.3 Static and Dynamic Binding",'1650,'49.51171875
'108,'Text 1161,"'Subtype polymorphism allows us to pass a derived-class object to a function that expects a base-class object:",'1651,'92.08984375
'108,'Key value 23,"",'1652,'58.88671875
'108,'Text 1162,"'Here, we have passed an istringstream object to a function that expects an istream. Extracting from the stream will use the functionality that istringstream defines for extraction.",'1653,'96.24023438
'108,'Text 1163,"'Another common use case is to have a container of base-class pointers, each of which points to different derived-class objects:",'1654,'95.94726563
'108,'Text 1164,"'void all_talk(Bird *birds , int length) { for (int = O; < length; ++i) { array[i]->talk(); } } int main() Chicken c1 = /* .. */; Duck d = :/*...*/; Chicken c2 = /* ... */; Bird *array[] = { &c1, &d, &c2 }; all_talk(array, 3); }",'1655,'50.29296875
'108,'Text 1165,"'Unfortunately, given the way we defined the talk() member function of Bird last time, this code will not use the derived-class versions of the function. Instead, all three calls to talk () will use the Bird version:",'1656,'93.79882813
'108,'Text 1166,"'$ /main.exe tweet tweet tweet",'1657,'91.74804688
'108,'Footer 65,"'18.3. Static and Dynamic Binding",'1658,'54.88281250
'108,'Page number 105,"'103",'1659,'74.90234375
'109,'Header 101,"'Programming and Data Structures, Release 0.3",'1660,'49.12109375
'109,'Text 1167,"'In the invocation array [[]]->talk(), the declared type of the receiver, the object that is receiving the member- function call, is different from the actual runtime type. The declared or static type is Bird, while the runtime or dynamic type is Chicken when i ==0. This disparity can only exist when we have indirection, either through a reference or a pointer.",'1661,'99.07226563
'109,'Text 1168,"'For a particular member function, C++ gives us the option of either static binding where the compiler determines which function to call based on the static type of the receiver, or dynamic binding, where the program also takes the dynamic type into account. The default is static binding, since it is more efficient and can be done entirely at compile time.",'1662,'97.85156250
'109,'Text 1169,"'In order to get dynamic binding instead, we need to declare the member function as virtual in the base class:",'1663,'93.84765625
'109,'Text 1170,"'class Bird { virtual void talk() const { cout << ""tweet"" << endl; } };",'1664,'94.48242188
'109,'Text 1171,"'Now when we call the all_talk() function above, the compiler will use the dynamic type of the receiver in the invocation array[i]->talk():",'1665,'95.89843750
'109,'Text 1172,"'$ /main.exe bawwk quack bawwk",'1666,'94.58007813
'109,'Text 1173,"'The virtual keyword is necessary in the base class, but optional in the derived classes. It can only be applied to the declaration within a class; if the function is subsequently defined outside of the class, the definition cannot include the virtual keyword:",'1667,'97.46093750
'109,'Text 1174,"'class Bird { virtual void talk() const; }; void Bird::talk() const cout << ""bawwk"" << endl; }",'1668,'85.25390625
'109,'Section header 71,"'18.4 dynamic_cast",'1669,'72.85156250
'109,'Text 1175,"'With dynamic binding, the only change we need to make to our code is to add the virtual keyword when declaring the base-class member function. No changes are required to the actual function calls (e.g. in all_talk()).",'1670,'96.19140625
'109,'Text 1176,"'Consider an alternative to dynamic binding, where we manually check the runtime type of an object to call the appro- priate function. In C++, a dynamic_cast conversion checks the dynamic type of the receiver object:",'1671,'93.94531250
'109,'Text 1177,"'Chicken ten(""Myrtle""), Bird *b_ptr = &chicken; Chicken *c_ptr = dynamic_cast<Chicken (b_ptr); if (c_ptr) { // check for null // do something chicken-specific }",'1672,'94.09179688
'109,'Footer 66,"'18.4. dynamic_cast",'1673,'82.37304688
'109,'Page number 106,"'104",'1674,'77.88085938
'110,'Header 102,"'Programming and Data Structures, Release 0.3",'1675,'54.58984375
'110,'Text 1178,"'If the dynamic type is not actually a Chicken, the conversion results in a null pointer. Otherwise, it results in the address of the Chicken object. Thus, we can check for null after the conversion to determine if it succeeded.",'1676,'96.92382813
'110,'Text 1179,"'There are two significant issues with dynamic_cast:",'1677,'74.56054688
'110,'List 31,"",'1678,'41.47949219
'110,'Text 1180 - Part of List 31,"'1. It generally results in messy and unmaintainable code. For instance, we would need to modify all_talk() as follows to use dynamic_cast rather than dynamic binding:",'1679,'84.37500000
'110,'Text 1181 - Part of List 31,"'void all_talk(Bird * birds [] int length) { for (int i = 0; i < length; ++i) { Chicken *c_ptr = dynamic_cast<Chicken*: (birds[i]) if (c_ptr) { c_ptr->talk(); } Duck *d_ptr = dynamic_cast<Duck*> (birds[i]) if (d_ptr) { d_ptr->talk(); } Eagle *e_ptr = dynamic_cast<Eagle*> if (e_ptr) { e_ptr->talk() } } }",'1680,'86.08398438
'110,'Text 1182,"'We would need a branch for every derived type of Bird, and we would have to add a new branch every time we wrote a new derived class. The code also takes time that is linear in the number of derived classes.",'1681,'93.40820313
'110,'Text 1183,"'2. In C++, dynamic_cast can only be applied to classes that are polymorphic, meaning that they define at least one virtual member function. Thus, we need to use virtual one way or another.",'1682,'92.48046875
'110,'Text 1184,"'Code that uses dynamic_cast is usually considered to be poorly written. Almost universally, it can be rewritten to use dynamic binding instead.",'1683,'93.50585938
'110,'Section header 72,"'18.5 Member Lookup Revisited",'1684,'88.18359375
'110,'Text 1185,"'We have already seen that when a member is accessed on an object, the compiler first looks in the object's class for a member of that name before proceeding to its base class. With indirection, the following is the full lookup process:",'1685,'95.89843750
'110,'List 32,"",'1686,'80.17578125
'110,'Text 1186 - Part of List 32,"'1. The compiler looks up the member in the static type of the receiver object, using the lookup process we discussed before (starting in the class itself, then looking in the base class if necessary). It is an error if no member of the given name is found in the static type or its base types.",'1687,'95.36132813
'110,'Text 1187 - Part of List 32,"'2. If the member found is an overloaded function, then the arguments of the function call are used to determine which overload is called.",'1688,'95.16601563
'110,'Text 1188 - Part of List 32,"'3. If the member is a variable or non-virtual function (including static member functions, which we will see later), the access is statically bound at compile time.",'1689,'94.77539063
'110,'Text 1189 - Part of List 32,"'4. If the member is a virtual function, the access uses dynamic binding. At runtime, the program will look for a function of the same signature, starting at the dynamic type of the receiver, then proceeding to its base type if necessary.",'1690,'93.55468750
'110,'Text 1190,"'As indicated above, dynamic binding requires two conditions to be met to use the derived-class version of a function:",'1691,'89.50195313
'110,'Text 1191,"'The member function found at compile time using the static type must be virtual.",'1692,'94.28710938
'110,'Footer 67,"'18.5. Member Lookup Revisited",'1693,'86.66992188
'110,'Page number 107,"'105",'1694,'84.37500000
'111,'Header 103,"'Programming and Data Structures, Release 0.3",'1695,'75.78125000
'111,'Text 1192,"'The derived-class function must have the same signature as the function found at compile time.",'1696,'98.24218750
'111,'Text 1193,"'When these conditions are met, the derived-class function overrides the base-class one - it will be used instead of the base-class function when the dynamic type of the receiver is the derived class. If these conditions are not met, the derived-class function hides the base-class one - it will only be used if the static type of the receiver is the derived class.",'1697,'99.07226563
'111,'Text 1194,"'As an example, consider the following class hierarchy:",'1698,'94.62890625
'111,'Table 42,"",'1699,'28.97949219
'111,'Text 1195,"'Each class has a non-virtual f1() member function; since the function is non-virtual, the derived-class versions hide the ones in the base classes. The f2() function is virtual, SO the derived-class ones override the base-class versions.",'1700,'93.65234375
'111,'Text 1196,"'The following are some examples of invoking these functions:",'1701,'73.63281250
'111,'Table 43,"",'1702,'35.08300781
'111,'Footer 68,"'18.5. Member Lookup Revisited",'1703,'76.85546875
'111,'Page number 108,"'106",'1704,'77.24609375
'112,'Header 104,"'Programming and Data Structures, Release 0.3",'1705,'54.00390625
'112,'Text 1197,"'(continued from previous page)",'1706,'41.67480469
'112,'Table 44,"",'1707,'35.93750000
'112,'Text 1198,"'We discuss each call in turn:",'1708,'83.64257813
'112,'List 33,"",'1709,'90.57617188
'112,'Text 1199 - Part of List 33,"'There is no indirection in the calls top. f1() and mid. f1(, SO there is no difference between the static and dynamic types of the receivers. The former calls the Top version of f1(), resulting in 2, while the latter calls the Middle version, producing 3.",'1710,'97.21679688
'112,'Text 1200 - Part of List 33,"'The static type of the receiver in top_ptr->f1() and top_ptr->f2() is Top, while the dynamic type is Bottom. Since f1() is non-virtual, static binding is used, resulting in 1. On the other hand, f2() is virtual, SO dynamic binding uses the Bottom version, producing 6.",'1711,'97.70507813
'112,'Text 1201 - Part of List 33,"'In the first call to mid_ptr->f2(), both the static and dynamic type of the receiver is Middle, SO Middle's version is used regardless of whether f2() is virtual. The result is 4.",'1712,'97.60742188
'112,'Text 1202 - Part of List 33,"'The assignment mid_ptr = &bot changes the dynamic type of the receiver to Bottom in calls on mid_ptr. The static type remains Middle, SO the call mid_ptr->f1() results in 3. The second call to mid_ptr->f2(), however, uses dynamic binding, SO the Bottom version of f2() is called, resulting in 6.",'1713,'97.36328125
'112,'Section header 73,"'18.6 The override Keyword",'1714,'82.51953125
'112,'Text 1203,"'A common mistake when attempting to override a function is to inadvertently change the signature, SO that the derived- class version hides rather than overrides the base-class one. The following is an example:",'1715,'97.55859375
'112,'Text 1204,"'class Chicken : public Bird { virtual void talk() { cout << ""bawwk"" << endl; } } int main() { Chicken chicken(""Myrtle""): Bird *b_ptr = &chicken; b_ptr->talk(); }",'1716,'68.99414063
'112,'Text 1205,"'This code compiles, but it prints tweet when run. Under the lookup process above, the program looks for an override of Bird: : talk() at runtime. However, no such override exists Chicken: talk() has a different signature, since it is not const. Thus, the dynamic lookup finds Bird::talk() and calls it instead.",'1717,'90.47851563
'112,'Text 1206,"'Rather than having the code compile and then behave incorrectly, we can ask the compiler to detect bugs like this with the override keyword. Specifically, we can place the override keyword after the signature of a member function to let the compiler know we intended to override a base-class member function. If the derived-class function doesn't actually do so, the compiler will report this:",'1718,'92.87109375
'112,'Footer 69,"'18.6. The override Keyword",'1719,'81.59179688
'112,'Page number 109,"'107",'1720,'75.29296875
'113,'Header 105,"'Programming and Data Structures, Release 0.3",'1721,'38.20800781
'113,'Text 1207,"'class Chicken : public Bird { void talk() override { cout << ""bawwk"" << endl; }",'1722,'34.59472656
'113,'Text 1208,"'Here, we have removed the virtual keyword, since it is already implied by override - only a virtual function can be overridden, and the ""virtualness"" is inherited from the base class. Since we are missing the const, the compiler reports the following:",'1723,'93.75000000
'113,'Text 1209,"'main. cpp: 39:15: error: non-virtual member function marked ""override"" hides virtual member function void talk override { ^ main. cpp 20:16: note: hidden overloaded virtual function 'Bird::talk' declared here: different qualifiers (const vs none) virtual void talk() const { ^ 1 error generated.",'1724,'48.73046875
'113,'Section header 74,"'Adding in the const fixes the issue:",'1725,'51.56250000
'113,'Text 1210,"'class Chicken : public Bird { void talk() const override { cout << ""bawwk"" << endl; } } int main() { Chicken chicken(""Myrtle""); Bird *b_ptr = &chicken; b_ptr->talk(); }",'1726,'72.02148438
'113,'Text 1211,"'The code now prints bawwk.",'1727,'82.08007813
'113,'Section header 75,"'18.7 Abstract Classes and Interfaces",'1728,'83.93554688
'113,'Text 1212,"'In some cases, there isn't enough information in a base class to define a particular member function, but we still want that function to be part of the interface provided by all its derived classes. In the case of Bird, for example, we may want a get_wingspan() function that returns the average wingspan for a particular kind of bird. There isn't a default value that makes sense to put in the Bird class. Instead, we declare get_wingspan() as a pure virtual function, without any implementation in the base class:",'1729,'97.07031250
'113,'Section header 76,"'class Bird {",'1730,'65.23437500
'113,'Text 1213,"'virtual int get_wingspan() const = 0; };",'1731,'63.62304688
'113,'Footer 70,"'18.7. Abstract Classes and Interfaces",'1732,'67.23632813
'113,'Page number 110,"'108",'1733,'80.51757813
'114,'Header 106,"'Programming and Data Structures, Release 0.3",'1734,'63.76953125
'114,'Text 1214,"'The syntax for declaring a function as pure virtual is to put = 0; after its signature. This is just syntax - we aren't actually setting its value to 0.",'1735,'98.63281250
'114,'Text 1215,"'Since Bird is now missing part of its implementation, we can no longer create objects of Bird type. The Bird class is said to be abstract. We can still declare Bird references and pointers, however, since that doesn't create a Bird object. We can then have such references and pointers refer to derived-class objects:",'1736,'98.09570313
'114,'Text 1216,"'Bird bird(""Big Bird"") ; // ERROR: Bird is abstract Chicken chicken(""Myrtle""); // OK, as long as Chicken is not abstract Bird &bird_ref = chicken; // OK Bird *bird_ptr = &chicken; // OK",'1737,'61.76757813
'114,'Text 1217,"'In order for a derived class to not be abstract itself, it must provide implementations of the pure virtual functions in its base classes:",'1738,'95.84960938
'114,'Text 1218,"'class Chicken : public Bird { int get_wingspan() const override { return 20; // inches } };",'1739,'94.14062500
'114,'Text 1219,"'With a virtual function, a base class provides its derived classes with the option of overriding the function's behavior. With a pure virtual function, the base class requires its derived classes to override the function, since the base class does not provide an implementation itself. If a derived class fails to override the function, the derived class is itself abstract, and objects of that class cannot be created.",'1740,'96.58203125
'114,'Text 1220,"'We can also define an interface, which is a class that consists only of pure virtual functions. Such a class provides no implementation; rather, it merely defines the interface that must be overridden by its derived classes. The following is an example:",'1741,'96.48437500
'114,'Text 1221,"'class Shape { public: virtual double area const = 0; virtual double perimeter() const = 0; virtual void scale(double s) = 0; };",'1742,'97.60742188
'114,'Text 1222,"'With subtype polymorphism, we end up with two use cases for inheritance:",'1743,'94.62890625
'114,'List 34,"",'1744,'92.77343750
'114,'Text 1223 - Part of List 34,"'implementation inheritance, where a derived class inherits functionality from a base class",'1745,'97.85156250
'114,'Text 1224 - Part of List 34,"'interface inheritance, where a derived class inherits the interface of its base class, but not necessarily any imple- mentation",'1746,'97.50976563
'114,'Text 1225,"'Deriving from a base class that isn't an interface results in both implementation and interface inheritance. Deriving from an interface results in just interface inheritance. The latter is useful to work with a hierarchy of types through a common interface, using a base-class reference or pointer, even if the derived types don't share any implementation.",'1747,'96.87500000
'114,'Footer 71,"'18.7. Abstract Classes and Interfaces",'1748,'43.50585938
'114,'Page number 111,"'109",'1749,'79.88281250
'115,'Text 1226,"'Part III Containers and Dynamic Memory",'1750,'29.24804688
'115,'Page number 112,"'110",'1751,'83.34960938
'116,'Header 107,"'CHAPTER",'1752,'58.30078125
'116,'Header 108,"'NINETEEN",'1753,'59.37500000
'116,'Title 29,"'CONTAINERS AND ITERATORS",'1754,'76.22070313
'116,'Text 1227,"'Apologies - this section has not been written yet.",'1755,'90.91796875
'116,'Section header 77,"'19.1 Range-Based For Loops",'1756,'86.76757813
'116,'Text 1228,"'A range-based for loop is a special syntax for iterating over sequences that support traversal by iterator. Rather than writing out each piece of the traversal, we can have the compiler generate it for us:",'1757,'95.70312500
'116,'Text 1229,"'vector<int> vec = { 1, 2, 3, 4, 5 }; for (int item : vec) { cout << item << endl; }",'1758,'71.28906250
'116,'Text 1230,"'The syntax of a range-based for loop is:",'1759,'89.16015625
'116,'Text 1231,"'for (<type> <variable> : <sequence>) <body>",'1760,'93.26171875
'116,'Text 1232,"'In the example above, the variable is named item and has type int, and vec is the sequence over which the loop iterates. The compiler automatically converts this into a traversal by iterator:",'1761,'96.58203125
'116,'Text 1233,"'for (auto it = vec.begin() ; it = vec.end() : ++it) int item = *it; cout << item << endl; }",'1762,'95.60546875
'116,'Text 1234,"'The variable item is initialized in each iteration from an element in the sequence. Then the code in the body of the range-based for loop follows.",'1763,'96.53320313
'116,'Text 1235,"'The following loop attempts to set every element in the vector to the value 42:",'1764,'94.38476563
'116,'Text 1236,"'for (int item : vec) { item = 42; // attempt to set element to 42 }",'1765,'84.08203125
'116,'Text 1237,"'However, this loop does not actually modify any elements. To understand why, let us take a look at its translation into a traversal by iterator:",'1766,'95.60546875
'116,'Text 1238,"'for (auto it = vec. begin() it != vec.end() ++it) { int item = *it; item = 42; }",'1767,'90.42968750
'116,'Page number 113,"'111",'1768,'79.39453125
'117,'Header 109,"'Programming and Data Structures, Release 0.3",'1769,'49.70703125
'117,'Text 1239,"'The loop is actually modifying a copy of each element rather than an element itself. To avoid making a copy, we can declare the loop variable to be a reference:",'1770,'98.58398438
'117,'Text 1240,"'for (int &item : vec) { item = 42; // actually set element to 42 }",'1771,'90.13671875
'117,'Text 1241,"'This translates to:",'1772,'40.82031250
'117,'Text 1242,"'for (auto it = vec.begin(); it != vec.end() ++it) { int &item = *it; item = 42; }",'1773,'94.04296875
'117,'Text 1243,"'This successfully modifies each element to have the value 42.",'1774,'92.33398438
'117,'Text 1244,"'Range-based for loops are often used in combination with auto, as in the following:",'1775,'90.18554688
'117,'Text 1245,"'vector<int> vec { { 1, 2, 3, 4, 5 } ; for (auto &item : vec) { item 42; } for (auto item : vec) { cout << item << endl; }",'1776,'31.83593750
'117,'Text 1246,"'The first loop declares item as a reference, SO that it aliases an element in the sequence. The second loop does not declare item as a reference, SO it produces a copy of an element in the sequence. The following is the translation of both loops:",'1777,'93.84765625
'117,'Text 1247,"'vector<int> vec : { { 1, 2, 3, 4, 5 }; for (auto it = vec.begin() ; it != vec.end() ++it) { int &item = *it; // alias item = 42; } for (auto it = vec. begin() it != vec.end() ++it) { int item = *it; // copy item = 42; }",'1778,'38.08593750
'117,'Text 1248,"'With a range-based for loop, we can simplify print_all():",'1779,'84.66796875
'117,'Text 1249,"'template <typename Sequence> void print_all (const Sequence &sequence) { for (auto &item : sequence) { cout << item << endl: ; } }",'1780,'93.06640625
'117,'Text 1250,"'We can call it on any sequence that supports traversal by iterator, as long as the element type can be inserted into an output stream:",'1781,'88.76953125
'117,'Text 1251,"'1 We can even call print_all() on an array, as long as it still is an array:",'1782,'54.68750000
'117,'Footer 72,"'19.1. Range-Based For Loops",'1783,'59.47265625
'117,'Page number 114,"'112",'1784,'86.57226563
'118,'Header 110,"'Programming and Data Structures, Release 0.3",'1785,'56.49414063
'118,'Text 1252,"'vector<string> vec = { ""hello"", ""world!"" }; print_all(vec);",'1786,'60.49804688
'118,'Section header 78,"'19.1.1 Iterating over a Map",'1787,'77.88085938
'118,'Text 1253,"'The standard-library map defines an iterator that produces key-value pairs upon dereference. The following is an example that constructs a map, counting how many times each unique word occurs in a vector. It then iterates over the map to print out the counts.",'1788,'98.14453125
'118,'Text 1254,"'void print_word_counts (const std::vector<std::string> &words) { std: map<std::string int> word_counts;",'1789,'58.59375000
'118,'Text 1255,"'// Each time a word is seen, add 1 to its entry in the map for (const auto &word : words) { word_counts[word] += 1; } // Print out the results by iterating through the map. for (const auto &key_value : word_counts) { // key-value pairs const auto &word = key_value.first; const auto &count = key_value.second; cout << word << ""occurred << count << "" times."" << endl; } }",'1790,'70.16601563
'118,'Text 1256,"'When incrementing a word's count, we do not need to check whether the word is in the map; if not, the map automati- cally inserts the word into the map with a value-initialized count of zero, which we then increment to one.",'1791,'92.52929688
'118,'Text 1257,"'We use range-based for loops to iterate over both the vector and the map, declaring a type-deduced reference to each element. A reference avoids making a copy, which is nontrivial for strings. The iteration over the map produces key- value pairs (std: :pair<std::string int>), and we access the first and second members to obtain the word and count, respectively.",'1792,'95.65429688
'118,'Text 1258,"'string arr[] = { ""hello"", ""world!"" }; print_all(arr);",'1793,'60.40039063
'118,'Text 1259,"'This is because a range-based for loop actually calls std: begin() and std: :end() on the sequence, rather than directly calling the respective member functions. For arrays, std: :begin() and std: : end() return pointers, while for class types, they call the begin() and end () member functions, respectively.",'1794,'95.26367188
'118,'Footer 73,"'19.1. Range-Based For Loops",'1795,'70.31250000
'118,'Page number 115,"'113",'1796,'88.57421875
'119,'Text 1260,"'CHAPTER",'1797,'51.66015625
'119,'Text 1261,"'TWENTY",'1798,'48.14453125
'119,'Text 1262,"'TIME COMPLEXITY",'1799,'77.09960938
'119,'Text 1263,"'Apologies - this section has not been written yet.",'1800,'88.96484375
'119,'Page number 116,"'114",'1801,'66.55273438
'120,'Text 1264,"'CHAPTER",'1802,'44.45800781
'120,'Text 1265,"'TWENTYONE",'1803,'31.78710938
'120,'Text 1266,"'ARRAYS",'1804,'71.38671875
'120,'Text 1267,"'As we mentioned previously, C++ has several different categories of objects, including atomic, array, and class-type objects. An array is simple collection of objects, built into C++ and many other languages. An array has the following properties:",'1805,'95.89843750
'120,'List 35,"",'1806,'83.05664063
'120,'Text 1268 - Part of List 35,"'It has a fixed size, set when the array is created. This size never changes as long as the array is alive.",'1807,'97.02148438
'120,'Text 1269 - Part of List 35,"'An array holds elements that are of the same type.",'1808,'96.19140625
'120,'Text 1270 - Part of List 35,"'The elements of an array are stored in a specific order, with the index of the first element being 0.",'1809,'97.65625000
'120,'Text 1271 - Part of List 35,"'The elements are stored contiguously in memory, one after another.",'1810,'96.33789063
'120,'Text 1272 - Part of List 35,"'Accessing any element of an array takes constant time, regardless of whether the element is at the beginning, middle, or end of the array.",'1811,'96.14257813
'120,'Text 1273,"'An array variable can be declared by placing square brackets to the right of the variable name, with a compile-time constant between the brackets, denoting the number of elements. For example, the following declares array to be an array of four int elements:",'1812,'96.38671875
'120,'Text 1274,"'int array [4];",'1813,'91.89453125
'120,'Text 1275,"'The following uses a named constant to declare array2 to be an array of four ints:",'1814,'96.28906250
'120,'Text 1276,"'const int SIZE = 4; int array2[SIZE];",'1815,'76.46484375
'120,'Text 1277,"'In both cases, we did not provide an explicit initialization. Thus, array and array2 are default initialized by default initializing each of their elements. Since their elements are of atomic type int, they are default initialized to undefined values.",'1816,'95.94726563
'120,'Text 1278,"'We can explicitly initialize an array with an initializer list, a list of values in curly braces:",'1817,'89.74609375
'120,'Text 1279,"'int array[4] = { 1, 2, 3, 4 };",'1818,'73.33984375
'120,'Text 1280,"'This initializes the element at index 0 to 1, the element at index 1 to 2, and SO on.",'1819,'89.25781250
'120,'Text 1281,"'If the initializer list contains fewer values than the size of the array, the remaining array elements are implicitly initial- ized. For atomic elements, these remaining elements are initialized to zero values1 Thus, the following initializes the first two elements of array2 to 1 and 2, respectively, and the last two elements to 0:",'1820,'95.26367188
'120,'Text 1282,"'int array2[4] = { 1, 2 };",'1821,'78.12500000
'120,'Text 1283,"'The following results in every element in array 3 being initialized to 0:",'1822,'89.59960938
'120,'Text 1284,"'1 This is referred to as value initialization, which is distinct from default initialization.",'1823,'73.87695313
'120,'Page number 117,"'115",'1824,'84.47265625
'121,'Header 111,"'Programming and Data Structures, Release 0.3",'1825,'45.80078125
'121,'Text 1285,"'int array 3 [4] = {}",'1826,'77.53906250
'121,'Text 1286,"'Here, we have provided an empty initializer list, SO that the first zero elements (i.e. none of them) are explicitly initialized while the remaining elements (i.e. all of them) are implicitly initialized to 0.",'1827,'96.28906250
'121,'Text 1287,"'If the size of the array is the same as the size of the initializer list, we can elide the size of the array in its declaration:",'1828,'86.91406250
'121,'Key value 24,"",'1829,'40.35644531
'121,'Text 1288,"'Figure 21.1 illustrates the layout of array in memory.",'1830,'88.52539063
'121,'Table 45,"",'1831,'38.20800781
'121,'Text 1289,"'Figure 21.1: Layout of an array in memory.",'1832,'93.40820313
'121,'Text 1290,"'This diagram assumes that an int takes up four bytes in memory, which is the case on most modern machines.",'1833,'96.14257813
'121,'Text 1291,"'Individual array elements can be accessed with square brackets, with an index between the brackets. Indexing starts at 0, up through the size of the array minus one. For example, the following increments each element in array by one and prints out each resulting value:",'1834,'97.31445313
'121,'Text 1292,"'for (inti=0;i<4;++i) { ++array[ [i] cout << array[i] << endl; }",'1835,'88.18359375
'121,'Text 1293,"'Arrays can be composed with other kinds of objects, such as structs. The following is an array of three Person elements:",'1836,'95.65429688
'121,'Section header 79,"'struct Person {",'1837,'48.04687500
'121,'Text 1294,"'string name; int age; bool is_ninja; } Person people[3]",'1838,'94.14062500
'121,'Text 1295,"'Figure 21.2 shows the layout of this array in memory.",'1839,'84.27734375
'121,'Text 1296,"'The following is a struct that contains an array as a member, and its layout is shown in Figure 21.3:",'1840,'93.65234375
'121,'Table 46,"",'1841,'26.04980469
'121,'Page number 118,"'116",'1842,'84.57031250
'122,'Title 30,"'Programming and Data Structures, Release 0.3",'1843,'47.75390625
'122,'Table 47,"",'1844,'63.76953125
'122,'Text 1297,"'people :",'1845,'45.04394531
'122,'Text 1298,"'Figure 21.2: An array of class-type objects.",'1846,'69.09179688
'122,'Text 1299,"'Matrix",'1847,'64.59960938
'122,'Table 48,"",'1848,'66.21093750
'122,'Text 1300,"'Figure 21.3: A class-type object with an array member.",'1849,'69.18945313
'122,'Page number 119,"'117",'1850,'82.56835938
'123,'Header 112,"'Programming and Data Structures, Release 0.3",'1851,'83.83789063
'123,'Title 31,"'21.1 Arrays and Pointers",'1852,'72.50976563
'123,'Text 1301,"'Arrays in C++ are objects. However, in most contexts, there isn't a value associated with an array as a whole². The individual elements (if they are not of array type), have values, but not the array as a whole. Instead, when we use an array in a context where a value is required, the compiler converts the array into a pointer to the first element in the array:",'1853,'97.46093750
'123,'Key value 25,"",'1854,'83.10546875
'123,'Text 1302,"'In this example, assuming the layout in Figure 21.1 where the first element is at address Ox1000, printing array to standard output just prints out the address Ox1000 - it converts array to a pointer to its first element, and it is the pointer's value that is then printed. Similarly, dereferencing the array first turns it into a pointer to the first element, followed by the dereference that gives us the first element itself.",'1855,'95.26367188
'123,'Text 1303,"'The tendency of arrays to decay into pointers results in significant limitations when using an array. For instance, we cannot assign one array to another - the right-hand side of an assignment requires a value, which in the case of an array will become a pointer, which is then incompatible with the left-hand side array:",'1856,'95.01953125
'123,'Key value 26,"",'1857,'85.79101563
'123,'Text 1304,"'As discussed before, by default, C++ passes parameters by value. This is also true if the parameter is an array. Since an array decays to a pointer when its value is required, this implies that an array is passed by value as a pointer to its first element. Thus, an array parameter to a function is actually equivalent to a pointer parameter, regardless of whether or not the parameter includes a size:",'1858,'97.60742188
'123,'Key value 27,"",'1859,'69.77539063
'123,'Text 1305,"'(continues on next page)",'1860,'93.31054688
'123,'Text 1306,"'2 The system of values in C++ is very complicated and beyond the scope of this course. In the context of this course, we use the term value to mean something called an rvalue in programming-language terms. There are a handful of ways to construct an array rvalue in C++, but none that we will encounter in this course.",'1861,'89.89257813
'123,'Footer 74,"'21.1. Arrays and Pointers",'1862,'66.89453125
'123,'Page number 120,"'118",'1863,'91.65039063
'124,'Header 113,"'Programming and Data Structures, Release 0.3",'1864,'43.67675781
'124,'Text 1307,"'(continued from previous page)",'1865,'94.87304688
'124,'Table 49,"",'1866,'54.29687500
'124,'Text 1308,"'This means that a function that takes an array as a parameter cannot guarantee that the argument value corresponds to an array of matching size, or even that it is a pointer into an array. Instead, we need another mechanism for passing size information to a function; we will come back to this momentarily.",'1867,'94.14062500
'124,'Section header 80,"'21.2 Pointer Arithmetic",'1868,'77.68554688
'124,'Text 1309,"'C++ supports certain arithmetic operations on pointers:",'1869,'94.09179688
'124,'List 36,"",'1870,'95.84960938
'124,'Text 1310 - Part of List 36,"'An integral value can be added to or subtracted from a pointer, resulting in a pointer that is offset from the original one.",'1871,'98.43750000
'124,'Text 1311 - Part of List 36,"'Two pointers can be subtracted, resulting in an integral value that is the distance between the pointers.",'1872,'97.65625000
'124,'Text 1312,"'Pointer arithmetic is in terms of number of elements rather than number of bytes. For instance, if an int takes up four bytes of memory, then adding 2 to an int * results in a pointer that is two ints forward in memory, or a total of eight bytes:",'1873,'97.50976563
'124,'Text 1313,"'int array [] = 4, 3, 2, 1 } int *ptr1 array; // pointer to first element int *ptr2 = &array[2]; // pointer to third element int *ptr3 = ptr1 2; // pointer to third element int *ptr4 = array + 2; // pointer to third element ++ptr1; // move pointer to second element",'1874,'39.13574219
'124,'Text 1314,"'In initializing ptr4, array is converted to a pointer to its first element, since the + operator requires a value, and the result is two ints forward in memory, producing a pointer to the third element. The last line increments ptr1 to point to the next int in memory. The result is shown in Figure 21.4.",'1875,'97.46093750
'124,'Text 1315,"'The following demonstrates subtracting pointers:",'1876,'94.23828125
'124,'Text 1316,"'cout << ptr2 - ptr1 endl // prints 1",'1877,'85.35156250
'124,'Text 1317,"'Since ptr2 is one int further in memory than ptr, the difference ptr2 - ptr is 1.",'1878,'91.79687500
'124,'Text 1318,"'Pointer arithmetic is one reason why each C++ type has its own pointer type - in order to be able to do pointer arithmetic, the compiler needs to use the size of the pointed-to type, SO it needs to know what that type is. For example, imple- mentations generally represent double objects with eight bytes, SO adding 2 to a double * moves 16 bytes forward in memory. In general, for a pointer of type T adding N to it moves N * sizeof(T) bytes forward in memory3.",'1879,'96.63085938
'124,'Text 1319,"'Pointers can also be compared with the comparison operators, as in the following using the pointers declared above:",'1880,'90.23437500
'124,'Text 1320,"'3 sizeof is an operator that can be applied to a type to obtain the number of bytes used to represent that type. When applied to a type, the parentheses are mandatory (e.g. sizeof(int)). The operator can also be applied to a value, in which case it results in the size of the compile-time type of that value. Parentheses are not required in this case (e.g. sizeof 4 or sizeof x).",'1881,'73.92578125
'124,'Footer 75,"'21.2. Pointer Arithmetic",'1882,'67.67578125
'124,'Page number 121,"'119",'1883,'85.00976563
'125,'Title 32,"'Programming and Data Structures, Release 0.3",'1884,'42.52929688
'125,'Figure 33,"",'1885,'83.05664063
'125,'Text 1321,"'Stack",'1886,'92.38281250
'125,'Figure 34,"",'1887,'46.97265625
'125,'Text 1322,"'Stack",'1888,'86.81640625
'125,'Text 1323,"'Figure 21.4: Pointer arithmetic is in terms of whole objects, not bytes.",'1889,'97.90039063
'125,'Text 1324,"'cout << (ptr1 == ptr2) << endl; // false (prints as 0) cout << (ptr2 == ptr3) << endl; // true (prints as 1) cout << (ptr1 < ptr2) << endl; // true cout << (*ptr1 < *ptr2) << endl; // false (compares element values) ++ptr1; cout << (ptr1 ==ptr2) << endl; // true cout << (array &array[0]) << endl; // true (LHS turns into pointer)",'1890,'81.88476563
'125,'Text 1325,"'Arithmetic is generally useful only on pointers to array elements, since only array elements are guaranteed to be stored contiguously in memory. Similarly, comparisons are generally only well-defined on pointers into the same array or on pointers constructed from arithmetic operations on the same pointer.",'1891,'97.21679688
'125,'Section header 81,"'21.3 Array Indexing",'1892,'90.47851563
'125,'Text 1326,"'Array indexing in C++ is actually implemented using pointer arithmetic. If one of the operands to the subscript ([]) operator is an array and the other is integral, then the operation is equivalent to pointer arithmetic followed by a deref- erence:",'1893,'96.92382813
'125,'Key value 28,"",'1894,'45.50781250
'125,'Text 1327,"'Thus, if arr is an array and i is integral, then arr [i] is equivalent to * (arr + i):",'1895,'94.14062500
'125,'List 37,"",'1896,'88.72070313
'125,'Text 1328 - Part of List 37,"'1. The subscript operation requires the value of arr, SO it turns into a pointer to its first element.",'1897,'97.60742188
'125,'Text 1329 - Part of List 37,"'2. Pointer arithmetic is done to produce a pointer i elements forward in memory.",'1898,'96.67968750
'125,'Text 1330 - Part of List 37,"'3. The resulting pointer is dereferenced, resulting in the element at index i.",'1899,'96.33789063
'125,'Footer 76,"'21.3. Array Indexing",'1900,'72.11914063
'125,'Page number 122,"'120",'1901,'85.40039063
'126,'Title 33,"'Programming and Data Structures, Release 0.3",'1902,'52.44140625
'126,'Text 1331,"'Because the subscript operation is equivalent to pointer arithmetic, it can be applied to a pointer equally as well:",'1903,'97.99804688
'126,'Key value 29,"",'1904,'68.40820313
'126,'Text 1332,"'There are several implications of the equivalence between array indexing and pointer arithmetic. First, it is what makes array access a constant time operation - - no matter the index, accessing an element turns into a single pointer addition followed by a single dereference. The equivalence is also what makes passing arrays by value work - the result is a pointer, which we can still subscript into since it just does pointer arithmetic followed by a dereference. Finally, it allows us to work with subsets of an array. For instance, the following code prints out just the middle elements of an array:",'1905,'98.14453125
'126,'Text 1333,"'void print_array array[], int size) { for (int i = 0; i < size; ++i) { cout << array[i] << ""; } } int main() { int array [4] = { 3, -1, 5, 2 }; print_array (arr + 1, 2); // prints out just -15 }",'1906,'90.72265625
'126,'Table 50,"",'1907,'75.14648438
'126,'Text 1334,"'Stack",'1908,'82.32421875
'126,'Text 1335,"'Figure 21.5: Passing a subset of an array to a function.",'1909,'96.33789063
'126,'Text 1336,"'The print_array () function receives a pointer to the array's second element as well as a size of 2, as shown in Figure 21.5. Thus, it only prints out the second and third elements; as far as the function knows, it is working with an array of size 2 that starts at the address Ox :1004.",'1910,'97.50976563
'126,'Footer 77,"'21.3. Array Indexing",'1911,'86.08398438
'126,'Page number 123,"'121",'1912,'87.50000000
'127,'Header 114,"'Programming and Data Structures, Release 0.3",'1913,'60.74218750
'127,'Section header 82,"'21.4 More on Array Decay",'1914,'83.88671875
'127,'Text 1337,"'An array only decays into a pointer when its value is required. When an array object's value is not required, it does not decay into a pointer. For example, the address-of (&) operator requires an object but not its value - thus, applying & to an array produces a pointer to the whole array, not a pointer to an individual element nor a pointer to a pointer4.",'1915,'97.16796875
'127,'Text 1338,"'Another example is applying the sizeof operator to an array. The operator produces the size of the whole array in bytes5, as opposed to applying it to a pointer, which just produces the size of a pointer (generally eight bytes on modern systems):",'1916,'94.82421875
'127,'Key value 30,"",'1917,'87.45117188
'127,'Text 1339,"'Once an array has turned into a pointer, the resulting pointer loses all information about the size of the array, or even that it is a pointer into an array. Thus, we need another mechanism for keeping track of the size of an array, such as when we pass the array to a function (if it is passed by value, it turns into a pointer which retains no information about the array's size).",'1918,'95.84960938
'127,'Section header 83,"'21.5 The End of an Array",'1919,'93.55468750
'127,'Text 1340,"'If a program dereferences a pointer that goes past the bounds of the array, the result is undefined behavior6. If we are lucky, the program will crash, indicating we did something wrong and giving us an opportunity to debug it. In the worst case, the program may compute the right result when we run it on our own machine but misbehave when run on a different platform (e.g. the autograder).",'1920,'97.70507813
'127,'Text 1341,"'There are two general strategies for keeping track of where an array ends.",'1921,'93.01757813
'127,'List 38,"",'1922,'93.31054688
'127,'Text 1342 - Part of List 38,"'1. Keep track of the length separately from the array. This can be done with either an integer size or by constructing a pointer that is just past the end of an array (by just adding the size of the array to a pointer to the array's first element).",'1923,'97.65625000
'127,'Text 1343 - Part of List 38,"'2. Store a special sentinel value at the end of the array, which allows an algorithm to detect that it has reached the end.",'1924,'96.82617188
'127,'Text 1344,"'The first strategy is what we used in defining the print (array function above. As demonstrated there, the stored size may be smaller than the size of the array, resulting in the function operating on a subset of the array.",'1925,'93.21289063
'127,'Text 1345,"'The second strategy requires there to be a special value that can be reserved to indicate the end of the array, and that we are assured will not occur as a real element. It is how built-in (C-style) strings (as opposed to C++ std: string) are implemented, though we do not cover the details here. Instead, we will return to the sentinel strategy when we implement linked data structures.",'1926,'95.50781250
'127,'Text 1346,"'4 A pointer to an array of 4 ints can be declared using the syntax int (*ptr_to_arr) [4]; The address value stored in a pointer to an array is generally the same address as that of the array's first element. 5 Thus, the expression sizeof array / sizeof *array recovers the number of elements, as long as array is still an array. 6 Constructing a pointer that is out of bounds is not a problem; we often construct pointers that are just past the end of an array, as we will see in a moment. It is dereferencing such a pointer that results in undefined behavior.",'1927,'30.24902344
'127,'Footer 78,"'21.4. More on Array Decay",'1928,'77.58789063
'127,'Page number 124,"'122",'1929,'85.98632813
'128,'Header 115,"'Programming and Data Structures, Release 0.3",'1930,'72.55859375
'128,'Title 34,"'21.6 Array Traversal",'1931,'80.37109375
'128,'Text 1347,"'The print_array function above also demonstrates how to traverse through an array using an index that starts at 0 up to the size of the array, exclusive. The following is another example:",'1932,'90.23437500
'128,'Figure 35,"",'1933,'28.29589844
'128,'Text 1348,"'Figure 21.6: Traversal by index uses an index to walk through an array.",'1934,'75.48828125
'128,'Text 1349,"'This pattern of accessing elements is called traversal by index - we use an integer index in the range [0, SIZE) where SIZE is the size of the array, and we use the index to obtain the corresponding element. We can use the subscript operator or do pointer arithmetic ourselves. (The former is generally considered better, since it is more familiar and clearer to most programmers. However, you will often see both arr [0] and *arr used to access the first element.) The actual syntax we use is irrelevant to the pattern - what makes this traversal by index is that we use an integer index to access the array, and we traverse through the elements by modifying the index.",'1935,'92.43164063
'128,'Text 1350,"'Another pattern we can use is traversal by pointer, which walks a pointer across the elements of an array:",'1936,'77.68554688
'128,'Text 1351,"'Here, we start by constructing a pointer that is just past the end of the array: the last element is at arr + SIZE - 1, SO we need to end our traversal when the pointer we are using reaches arr + SIZE. We then use another pointer that starts at the first element, dereference it to obtain an element, and then increment it to move on to the next element. The syntax we use to dereference an element is irrelevant to the pattern (it can be *ptr or ptr [0]) - what makes this traversal by pointer is that we use a pointer to each element to access the array, and we traverse through the elements by modifying that pointer.",'1937,'90.57617188
'128,'Key value 31,"",'1938,'33.03222656
'128,'Text 1352,"'Traversal by index is the more common pattern when working with general arrays. However traversal by pointer is a special case of traversal by iterator, which we saw previously. We will shortly see that traversal by iterator/pointer allows us to write algorithms that work on both library containers and arrays. Thus, both the traversal-by-index and traversal-by-pointer patterns are important to programming in C++.",'1939,'87.25585938
'128,'Text 1353,"'Aside from providing us insight about memory and how objects are stored, arrays are a fundamental abstraction that can be used to build more complex abstractions. We proceed to see how to use arrays to build data structures such as",'1940,'83.83789063
'128,'Footer 79,"'21.6. Array Traversal",'1941,'87.59765625
'128,'Page number 125,"'123",'1942,'90.13671875
'129,'Header 116,"'Programming and Data Structures, Release 0.3",'1943,'52.92968750
'129,'Figure 36,"",'1944,'32.08007813
'129,'Text 1354,"'Figure 21.7: Traversal by pointer uses a pointer to walk through an array.",'1945,'81.98242188
'129,'Text 1355,"'vectors and sets.",'1946,'76.22070313
'129,'Section header 84,"'21.7 Arrays and const",'1947,'75.78125000
'129,'Text 1356,"'Since an array does not have a value of its own, it cannot be assigned to as a whole - we saw previously that a compile error would result, since we cannot obtain an array value to place on the right-hand side of the assignment. Thus, it is also not meaningful for an array itself to be const either.",'1948,'97.26562500
'129,'Text 1357,"'Similar to a reference, an array may not be const itself, but its elements may be:",'1949,'91.35742188
'129,'Text 1358,"'const double arr[4] = { 1.1, 2.3, -4.5, 8 }; arr[2] = 3.1; // ERROR -- attempt to assign to const object",'1950,'55.17578125
'129,'Text 1359,"'The declaration const double arr[4] is read inside out as ""arr is an array of four constant doubles."" The elements can be initialized through an initializer list, but they may not be modified later through assignment.",'1951,'96.38671875
'129,'Text 1360,"'If an array is a member of a class-type object, the array elements inherit the ""constness"" of the object itself. For example, consider the following:",'1952,'94.67773438
'129,'Text 1361,"'struct Foo { int num; int *ptr; int arr[4]; };",'1953,'51.07421875
'129,'Text 1362,"'Like any const object, a const Foo must be initialized upon creation:",'1954,'87.40234375
'129,'Text 1363,"'int main() { int X = 3 ; const Foo foo = { 4, &x, { 1, 2, 3, 4 } }; }",'1955,'86.27929688
'129,'Text 1364,"'The array member can be initialized using its own initializer list, which is the same syntax for initializing a local array variable.",'1956,'93.94531250
'129,'Text 1365,"'As we saw previously, attempting to modify foo . num or foo. ptr results in a compiler error. The same is true for the elements of foo. arr:",'1957,'94.58007813
'129,'Footer 80,"'21.7. Arrays and const",'1958,'79.58984375
'129,'Page number 126,"'124",'1959,'90.18554688
'130,'Title 35,"'Programming and Data Structures, Release 0.3",'1960,'45.33691406
'130,'Text 1366,"'main",'1961,'94.43359375
'130,'Figure 37,"",'1962,'49.12109375
'130,'Text 1367,"'Stack",'1963,'62.15820313
'130,'Text 1368,"'Figure 21.8: Contents of a Foo object. Declaring the object as const only prohibits modifications to the subobjects contained within the memory for the object.",'1964,'96.72851563
'130,'Text 1369,"'foo.arr[0] = 2; // ERROR",'1965,'95.36132813
'130,'Text 1370,"'Sine the array element is a subobject of a const object, it cannot be modified.",'1966,'96.19140625
'130,'Footer 81,"'21.7. Arrays and const",'1967,'89.64843750
'130,'Page number 127,"'125",'1968,'88.47656250
'131,'Header 117,"'CHAPTER",'1969,'42.91992188
'131,'Header 118,"'TWENTYTWO",'1970,'43.21289063
'131,'Title 36,"'ARRAY-BASED CONTAINERS",'1971,'76.70898438
'131,'Text 1371,"'A container is an abstract data type whose purpose is to hold objects of some other type. We have already seen two examples of containers: built-in arrays and vectors from the standard library. Both are containers that hold elements in a particular order, indexed starting from 0. A built-in array has a fixed size, while a vector can grow and shrink.",'1972,'92.67578125
'131,'Text 1372,"'Let's define our own container ADT, using built-in arrays as our building block. Rather than an ordered sequence, we will build a set abstraction, which represents an unordered collection of unique elements. We will start with a container that holds integers, generalizing it to arbitrary element types next time.",'1973,'88.37890625
'131,'Text 1373,"'In designing our ADT, we will use the following process:",'1974,'87.59765625
'131,'List 39,"",'1975,'87.74414063
'131,'Text 1374 - Part of List 39,"'1. Determine which operations our ADT will support.",'1976,'97.46093750
'131,'Text 1375 - Part of List 39,"'2. Write some code that uses our ADT. This will helps us figure out what the right interface should be, and it will serve as a test case. (Ideally, we would also write unit tests for each part of the public interface, following the pattern of test-driven development.)",'1977,'97.99804688
'131,'Text 1376 - Part of List 39,"'3. Define the ADT's public interface, including both function signatures and documentation.",'1978,'97.60742188
'131,'Text 1377 - Part of List 39,"'4. Come up with a data representation. Define member variables and determine the representation invariants.",'1979,'96.77734375
'131,'Text 1378 - Part of List 39,"'5. Write definitions for the ADT's constructors and member functions, making sure that they adhere to the repre- sentation invariants.",'1980,'96.63085938
'131,'Section header 85,"'22.1 Set Operations",'1981,'91.06445313
'131,'Text 1379,"'The following are the operations our set will support:",'1982,'96.58203125
'131,'List 40,"",'1983,'90.03906250
'131,'Text 1380 - Part of List 40,"'Creating an empty set.",'1984,'95.99609375
'131,'Text 1381 - Part of List 40,"'Inserting a value into a set. We will allow an existing item to be inserted - it will just do nothing.",'1985,'96.14257813
'131,'Text 1382 - Part of List 40,"'Removing a value from a set. We will allow a nonexistent item to be removed - it will just do nothing.",'1986,'96.43554688
'131,'Text 1383 - Part of List 40,"'Check if a value is contained in a set.",'1987,'96.28906250
'131,'Text 1384 - Part of List 40,"'Count the number of items in a set.",'1988,'95.99609375
'131,'Text 1385 - Part of List 40,"'Print a character representation of a set to an output stream.",'1989,'96.04492188
'131,'Page number 128,"'126",'1990,'83.34960938
'132,'Header 119,"'Programming and Data Structures, Release 0.3",'1991,'67.33398438
'132,'Section header 86,"'22.2 Code Example",'1992,'56.68945313
'132,'Text 1386,"'Here is a small program that uses a set:",'1993,'85.15625000
'132,'Key value 32,"",'1994,'48.92578125
'132,'Text 1387,"'}",'1995,'90.09184265
'132,'Section header 87,"'22.3 Public Interface",'1996,'75.29296875
'132,'Text 1388,"'The code example leads to the following public interface:",'1997,'79.68750000
'132,'Text 1389,"'class IntSet { public:",'1998,'59.27734375
'132,'Key value 33,"",'1999,'70.99609375
'132,'Text 1390,"'};",'2000,'70.80973053
'132,'Footer 82,"'22.2. Code Example",'2001,'79.29687500
'132,'Page number 129,"'127",'2002,'82.86132813
'133,'Header 120,"'Programming and Data Structures, Release 0.3",'2003,'62.59765625
'133,'Text 1391,"'The public interface includes a default constructor and member functions to insert or remove an item, check if an item is in the set, obtain its size, and print a representation of the set to a stream. The latter three functions do not modify the set, SO they are declared as const, meaning that the this pointer will be a pointer to const. The compiler will then enforce that those functions do not modify any member variables.",'2004,'98.09570313
'133,'Section header 88,"'22.4 static Data Members",'2005,'93.45703125
'133,'Text 1392,"'The public interface also includes a constant, MAX_SIZE, that denotes the maximum size of a set. We define the constant inside the IntSet class. This distinguishes the constant from other constants of the same name; there may be some other ADT with a MAX_SIZE. It also makes use of encapsulation, which allows all of an ADT's data and functionality to be defined together within a class.",'2006,'97.21679688
'133,'Text 1393,"'The constant is declared static, which has a specific meaning when used in a class - it indicates that the given member is not associated with an object of the class, but with the class as a whole. For a member variable, this means that there is a single copy of that variable in the program, located in static storage. Without the static keyword, each object of the class would have its own copy, located in the memory for that object. The static keyword also allows a member variable to be a compile-time constant, provided it is also declared as const (or constexpr) and initialized from an expression that can be computed at compile time.",'2007,'96.77734375
'133,'Text 1394,"'A static member can be accessed by name from within the class, the same as a non-static member. It can be accessed from outside the class with the scope-resolution operator:",'2008,'93.35937500
'133,'Text 1395,"'int main() { IntSet set; for (int i = 0; IntSet: MAX_SIZE; ++i) { set.insert(i) } }",'2009,'96.19140625
'133,'Text 1396,"'We need a compile-time constant because we will use a member variable that is a built-in array as part of our data representation. In C++, a local or member variable that is an array must have a size that is known to the compiler. In the case of a local variable, the compiler needs to know how big it is SO that the program can create activation records of the correct size. For a member variable, the compiler needs to know its size SO that it can determine the size of the object as a whole. Pointer arithmetic (including array accesses) requires the compiler to know the size of an object at compile time, since it is in terms of whole objects rather than with respect to individual bytes.",'2010,'97.11914063
'133,'Section header 89,"'22.5 Data Representation",'2011,'90.82031250
'133,'Text 1397,"'We rely on existing types to represent the data of our IntSet. For the elements themselves, we use a built-in array, with MAX_SIZE as its capacity. However, our set will start out empty, after which we can add and remove elements as we please. Thus, the size of the set will generally not be the same as the size of the array, and we need a separate member variable to keep track of the number of elements in the set. We will use an int for this member.",'2012,'96.77734375
'133,'Section header 90,"'class IntSet {",'2013,'45.43457031
'133,'Text 1398,"'private:",'2014,'34.81445313
'133,'Text 1399,"'(continues on next page)",'2015,'87.69531250
'133,'Text 1400,"'1 Member variables that are static need not be compile-time constants. However, a member variable that isn't a compile-time constant cannot be initialized at the point of declaration (unless it is declared as inline in C++17 and onward). The variable must be defined outside of the class, generally in a source .cpp) file. As with a member function, the scope-resolution operator is used to define a member variable outside the class (e.g. int IntSet foo = 3;). 2 In the future, we will see how to eliminate the fixed-size restriction by storing the elements indirectly using a dynamic array. We will see that this raises issues of memory management and learn how to resolve them.",'2016,'52.92968750
'133,'Footer 83,"'22.4. static Data Members",'2017,'60.20507813
'133,'Page number 130,"'128",'2018,'87.20703125
'134,'Header 121,"'Programming and Data Structures, Release 0.3",'2019,'60.40039063
'134,'Text 1401,"'(continued from previous page)",'2020,'59.47265625
'134,'Text 1402,"'int elements [MAX_SIZE]; int num_elements;",'2021,'42.16308594
'134,'Text 1403,"'}",'2022,'46.58203125
'134,'Text 1404,"'Now that we've determined a data representation, we need to figure out what values correspond to valid sets. We use representation invariants to specify the set of valid values.",'2023,'95.94726563
'134,'Text 1405,"'For num_elements, a negative value does not make sense, since a set cannot have a negative size. At the same time, our sets do not have enough space to store more than MAX _SIZE elements, SO that places an upper bound on num_elements. The invariants for num_elements are thus 0 <= num_elements && num_elements <= MAX_SIZE.",'2024,'93.55468750
'134,'Text 1406,"'For elements, we need to know where in the array the set's elements are actually stored. We will store them at the beginning of the array, SO one invariant is that the first num_elements items in the array are the ones in the set. The set abstraction prohibits duplicate elements, SO another invariant is that there are no duplicates among the first num_elements items in elements.",'2025,'95.26367188
'134,'Text 1407,"'We document the representation invariants where we define our representation:",'2026,'85.15625000
'134,'Section header 91,"'class IntSet {",'2027,'27.17285156
'134,'Text 1408,"'private: int elements [MAX_SIZE]; int num_elements; // INVARIANTS: // O <= num_elements && num_elements <= MAX_SIZE // the first num_elements items in elements are the items in the set // the first num_elements items in elements contain no duplicates };",'2028,'62.50000000
'134,'Section header 92,"'22.6 size_t",'2029,'84.47265625
'134,'Text 1409,"'The size_t type represents only nonnegative integers, and the C++ standard guarantees that it is large enough to hold the size of any object. Since it does not represent negative integers, we could have used it for num_elements rather than defining 0 <= num_elements as a representation invariant. We would then also use size_t as the return type for size(), which is what the standard-library containers do.",'2030,'96.14257813
'134,'Text 1410,"'C++ has integral types that are unsigned, which do not represent negative numbers, and size_t is just one example. The int type is signed (unless it is preceded by the unsigned keyword). Unsigned integers can lead to subtle programming errors. The following is an example that compares a signed and unsigned integer:",'2031,'94.43359375
'134,'Text 1411,"'int main() { size_t S = 3; int i = -1; cout << (s < i) << endl; // prints 1 (true) }",'2032,'57.56835938
'134,'Text 1412,"'Perhaps non-intuitively, the comparison S < i is true, even though S is positive but i is negative. This is because the compiler converts i to a size_t in doing the comparison, and the data that represents a negative signed integer actually represents a very large unsigned integer.",'2033,'94.87304688
'134,'Text 1413,"'Another common error is incorrectly iterating backwards over a sequence:",'2034,'88.33007813
'134,'Footer 84,"'22.6. size_t",'2035,'86.08398438
'134,'Page number 131,"'129",'2036,'79.29687500
'135,'Header 122,"'Programming and Data Structures, Release 0.3",'2037,'59.27734375
'135,'Text 1414,"'int main() { vector<int> vec = { 1, 2, 3 }; for (size_t i = vec.size() 1; i >= 0; --i) { cout << vec[i] << endl; } }",'2038,'88.42773438
'135,'Text 1415,"'This code goes off the end of the vector, resulting in undefined behavior. The reason is that a size_t is always greater than or equal to 0, and when i is equal to 0 and decremented, its value wraps around to the largest possible size_t value. The following iteration correctly avoids this problem:",'2039,'98.19335938
'135,'Text 1416,"'int main() { vector<int> vec = { 1, 2, 3 }; for (size_t i = vec.size(); i > 0; --i) { cout << vec[i - 1] << endl; } }",'2040,'94.33593750
'135,'Text 1417,"'The loop iterates from vec. size() down to 1, offsetting by 1 when indexing into the vector. The following equivalent code makes use of postfix decrement to avoid the offset in the index expression:",'2041,'94.87304688
'135,'Text 1418,"'int main() { vector<int> vec = { 1, 2, 3 }; for (size_t i = vec.size(); i-->0;) { cout << vec[i] << endl; } }",'2042,'94.82421875
'135,'Text 1419,"'Given the pitfalls of unsigned integers, many C++ programmers avoid them, using signed integers instead. We too will generally stick to signed integers.",'2043,'96.14257813
'135,'Section header 93,"'22.7 Implementation",'2044,'91.89453125
'135,'Text 1420,"'We proceed to define the constructor and member functions of IntSet, defining them as they would appear in a source file, outside the class definition.",'2045,'97.80273438
'135,'Text 1421,"'We require only a default constructor for IntSet. However, we cannot rely on a compiler-generated implicit one: it would default initialize num_elements to an undefined value, violating our representation invariants. Thus, we need to define our own default constructor.",'2046,'97.31445313
'135,'Text 1422,"'IntSet: IntSet() : num_elements(0) {}",'2047,'82.03125000
'135,'Text 1423,"'We need not do anything with elements. It gets default initialized to contain undefined values, but that doesn't violate our representation invariants; since num_elements is 0, the invariants for elements are trivially satisfied.",'2048,'96.92382813
'135,'Text 1424,"'We proceed to define contains(). The representation invariants tell us that the valid items are the first num_elements in elements. They can be stored in any order, SO we need to iterate through them to see if the value is in the set.",'2049,'96.19140625
'135,'Text 1425,"'bool IntSet: contains (int value) const { for (int i = 0; i < num_elements; ++i) {",'2050,'91.89453125
'135,'Text 1426,"'(continues on next page)",'2051,'75.34179688
'135,'Footer 85,"'3 Alternatively, we can initialize num_elements to 0 at the point it is declared. The implicitly defined default constructor would then be sufficient; it would still have an empty member-initializer list, but the compiler uses the inline initialization of a member variable if it is not initialized in the member-initializer list.",'2052,'43.11523438
'135,'Footer 86,"'22.7. Implementation",'2053,'75.58593750
'135,'Page number 132,"'130",'2054,'80.81054688
'136,'Header 123,"'Programming and Data Structures, Release 0.3",'2055,'53.22265625
'136,'Text 1427,"'(continued from previous page)",'2056,'73.92578125
'136,'Text 1428,"'if (elements [i] == value) { return true; } } return false; }",'2057,'41.57714844
'136,'Text 1429,"'When we find an item, we can return immediately without checking the rest of the elements. On the other hand, if we get through all the elements without finding the given value, it is not in the set SO we return false.",'2058,'97.07031250
'136,'Text 1430,"'For inserting into the set, we first assert the requires clause, which ensures that our invariant of num_elements <= MAX_SIZE is never violated. We also must check whether the value is in the set, since adding it again would violation the invariant of no duplicates. If the value is not in the set, the simplest way to insert it is to place it at index num_elements and increment that variable. This meets the invariant that the first num_elements items in the array are the values in the set.",'2059,'97.36328125
'136,'Text 1431,"'void IntSet: : insert (int value) { assert(size() < MAX_SIZE) ; if (contains (value)) { elements [num_elements] = value; ++num_elements; // we could use num_elements++ in the line above instead } }",'2060,'94.33593750
'136,'Text 1432,"'To remove an element, we first need to check whether the value is in the set. If so, we need to know its location in the array, which would require iterating through the elements to find it. Rather than repeating this algorithm in both contains () and remove(), we define a private helper function to do SO and call it in both places.",'2061,'97.46093750
'136,'Section header 94,"'class IntSet {",'2062,'54.68750000
'136,'Text 1433,"'private: int indexOf(int value) const; }; int IntSet :indexOf(int value) const { for (int i = 0; < num_elements; ++i) { if (elements[i == value) { return i; } } return -1; }",'2063,'91.69921875
'136,'Text 1434,"'Rather than returning whether or not the value is in the set, indexOf() returns its actual index if it is there. If not, it returns an invalid index; we use -1, since indices start at 0. We can then write contains () as follows:",'2064,'97.02148438
'136,'Text 1435,"'bool IntSet: : contains (int value) const { return index0f(value) != -1; }",'2065,'72.11914063
'136,'Text 1436,"'We proceed to define remove():",'2066,'90.38085938
'136,'Footer 87,"'22.7. Implementation",'2067,'75.29296875
'136,'Page number 133,"'131",'2068,'85.00976563
'137,'Header 124,"'Programming and Data Structures, Release 0.3",'2069,'55.17578125
'137,'Text 1437,"'void IntSet: remove (int value) { int index = indexOf(value); if (index != -1) { elements [index] = elements [num_elements - 1]; --num_elements; } }",'2070,'91.74804688
'137,'Text 1438,"'In order to actually remove the item, we need to place another item at its location. The simplest solution that meets the representation invariants is to copy over the last item and then decrement num_elements, which ensures that the first num_elements items are the values in the set.",'2071,'96.72851563
'137,'Text 1439,"'elements",'2072,'66.11328125
'137,'Figure 38,"",'2073,'83.83789063
'137,'Text 1440,"'num_elements",'2074,'58.05664063
'137,'Figure 39,"",'2075,'70.89843750
'137,'Text 1441,"'Figure 22.1: Removing an element from an unordered set can be done by copying the last element into the position vacated by the removed element.",'2076,'96.77734375
'137,'Text 1442,"'The remaining member functions are defined as follows:",'2077,'87.45117188
'137,'Text 1443,"'int IntSet: size () const { return num_elements; } void ntSet::print(std::ostream &os) const { os ""{""; for (int i = num_elements; ++i) { os<< elements[i] << "" ""; } os << ""}""; }",'2078,'68.35937500
'137,'Section header 95,"'22.8 Sorted Representation",'2079,'86.81640625
'137,'Text 1444,"'The representation of IntSet places no restrictions on the ordering of elements in the array. This simplifies the imple- mentation of insert () and remove(). but it requires contains () (and indexOf()) to iterate over every element in the worst case.",'2080,'97.31445313
'137,'Text 1445,"'An alternate representation would be to require that the set elements are stored in sorted, increasing order. The member variables remain the same - it is the representation invariants that change.",'2081,'94.62890625
'137,'Table 51,"",'2082,'30.49316406
'137,'Footer 88,"'22.8. Sorted Representation",'2083,'72.70507813
'137,'Page number 134,"'132",'2084,'84.42382813
'138,'Header 125,"'Programming and Data Structures, Release 0.3",'2085,'50.97656250
'138,'Text 1446,"'(continued from previous page)",'2086,'79.73632813
'138,'Text 1447,"'// O <= num_elements && num_elements <= MAX_SIZE // the first num_elements items in elements are the items in the set // the first num_elements items in elements contain no duplicates // the first num_elements items are in sorted, increasing order };",'2087,'30.37109375
'138,'Text 1448,"'To insert an item, we can no longer just put it after the existing elements, since the new value may be smaller than existing values. Instead, we need to store it at its appropriate sorted position. This requires moving existing elements out of the way if necessary. Our algorithm will start after the last element and repeatedly:",'2088,'94.33593750
'138,'List 41,"",'2089,'92.91992188
'138,'Text 1449 - Part of List 41,"'Compare the item to the left with the value we are inserting.",'2090,'94.58007813
'138,'Text 1450 - Part of List 41,"'If the item to the left is less than the new value, the new value is placed at the current position, and we are done.",'2091,'95.99609375
'138,'Text 1451 - Part of List 41,"'If the item is greater than the new value, then the old item is moved one position to the right, and we repeat the process one position over to the left.",'2092,'96.92382813
'138,'Text 1452 - Part of List 41,"'If no more items are to the left, we place the new value at the current position (i.e. the beginning of the array).",'2093,'96.48437500
'138,'Text 1453,"'elements",'2094,'57.47070313
'138,'Figure 40,"",'2095,'80.61523438
'138,'Text 1454,"'num_elements",'2096,'59.08203125
'138,'Figure 41,"",'2097,'62.59765625
'138,'Text 1455,"'Figure 22.2: Inserting into an ordered set requires shifting existing elements to make room for the new element at the proper location.",'2098,'95.75195313
'138,'Section header 96,"'void SortedIntSet: insert (int value) {",'2099,'33.25195313
'138,'Text 1456,"'assert (size() < MAX_SIZE); if (contains (value)) { int index = num_elements; while (index > .0 && elements [index - 1] > value) { elements [index] = elements [index - 1]; --index; } elements [index] = value; ++num_elements; } }",'2100,'87.59765625
'138,'Text 1457,"'Similarly, to remove an item, we must shift the remaining elements leftward in order to maintain our representation invariants.",'2101,'87.89062500
'138,'Figure 42,"",'2102,'86.62109375
'138,'Text 1458,"'num_elements",'2103,'69.58007813
'138,'Figure 43,"",'2104,'42.91992188
'138,'Text 1459,"'Figure 22.3: Removing from an ordered set requires shifting elements to preserve the representation invariants.",'2105,'88.42773438
'138,'Footer 89,"'22.8. Sorted Representation",'2106,'54.88281250
'138,'Page number 135,"'133",'2107,'82.91015625
'139,'Header 126,"'Programming and Data Structures, Release 0.3",'2108,'58.59375000
'139,'Text 1460,"'void SortedIntSet: remove (int value) { int index = indexOf(value) if (index != -1) { for (; index < num_elements - 1; ++index) { elements [index] = elements[inder + 1] ; } -num_elements; } }",'2109,'94.28710938
'139,'Text 1461,"'The advantage of sorting is that we don't have to look through all the elements to determine the location of a value. Instead, we can use binary search, which eliminates half the search space in each step:",'2110,'96.72851563
'139,'List 42,"",'2111,'96.97265625
'139,'Text 1462 - Part of List 42,"'Compare the value we are looking for to the middle element among the remaining items.",'2112,'97.90039063
'139,'Text 1463 - Part of List 42,"'If the value is equal to the middle element, we have found its index.",'2113,'97.07031250
'139,'Text 1464 - Part of List 42,"'If the value is less than the middle element, we know it must be to the left, if it is in the set. Thus, we need only repeat the search on the items in the first half.",'2114,'98.04687500
'139,'Text 1465 - Part of List 42,"'If the value is greater than the middle element, we know it must be to the right, if it is in the set. Thus, we need only repeat the search on the items in the second half.",'2115,'98.09570313
'139,'Text 1466 - Part of List 42,"'If we have run out of elements to search, the value is not in the set.",'2116,'97.99804688
'139,'Text 1467,"'The following implements this algorithm:",'2117,'92.62695313
'139,'Text 1468,"'int SortedIntSet::indexOf(int value) const { int start = 0; int end = num_elements; while (start < end) { int middle = start / 2 + end / 2; if (value == relements[middle]) { return middle; } else if (value < elements [middle]) { end = middle; } else { start = middle + 1; } } return -1; }",'2118,'79.05273438
'139,'Text 1469,"'Since half the search space is eliminated in each step, this algorithm takes time that is logarithmic in the size of the set. We denote this as O(logn), where n is the number of elements in the set.",'2119,'95.84960938
'139,'Text 1470,"'For a set of size N, the following compares the worst-case runtime of each operation on unsorted and sorted sets:",'2120,'94.97070313
'139,'Table 52,"",'2121,'96.09375000
'139,'Text 1471,"'The notation O(1) means that the operation takes constant time: the time it takes is independent of the size of the set.",'2122,'97.02148438
'139,'Footer 90,"'22.8. Sorted Representation",'2123,'86.08398438
'139,'Page number 136,"'134",'2124,'87.50000000
'140,'Header 127,"'Programming and Data Structures, Release 0.3",'2125,'54.49218750
'140,'Text 1472,"'The insert () and remove () operations must first check whether the item is in the set, SO they can be no faster than contains (). The latter is significantly faster on a sorted set than an unsorted set, demonstrating the advantage of sorting.",'2126,'56.00585938
'140,'Footer 91,"'22.8. Sorted Representation",'2127,'35.03417969
'140,'Page number 137,"'135",'2128,'76.70898438
'141,'Header 128,"'CHAPTER",'2129,'38.50097656
'141,'Header 129,"'TWENTYTHREE",'2130,'46.48437500
'141,'Title 37,"'CONTAINER ADTS AND POLYMORPHISM",'2131,'87.06054688
'141,'Text 1473,"'We continue our discussion of container ADTs by examining several forms of polymorphism in the context of con- tainers. We will start by looking at operator overloading, a form of ad hoc polymorphism, and then proceed to discuss parametric polymorphism.",'2132,'97.07031250
'141,'Section header 97,"'23.1 Operator Overloading",'2133,'86.47460938
'141,'Text 1474,"'C++ follows the philosophy that user-defined types should have the same access to language facilities as built-in types. Since operators can be used with built-in atomic types, C++ allows operators to be applied to class types through operator overloading.",'2134,'96.09375000
'141,'Text 1475,"'Most operators in C++ can be overloaded. An operator overload requires at least one of the operands to be of class type1 - the behavior of operators on atomic types cannot be changed.",'2135,'94.14062500
'141,'Text 1476,"'When the compiler encounters an operator where at least one operand is of class type, it looks for a function whose name is operator followed by the symbol for the actual operator. For example, if + is applied to two IntSets, the compiler looks for a function with name operator+ that can be applied to two IntSet objects. For most operators, the function can either be a top-level function or a member of the type of the left-most operand, if it is of class type.",'2136,'97.11914063
'141,'Text 1477,"'The following is a member function that defines the + operation to compute the union of two IntSets:",'2137,'91.89453125
'141,'Text 1478,"'class IntSet { public: IntSet operator+(con IntSet &rhs) const; };",'2138,'62.98828125
'141,'Text 1479,"'IntSet IntSet: : operator+ +(const IntSet &rhs) const { IntSet result = *this; for (int i = 0; i < rhs.num_elements; ++i) { result.insert(rhs.elements[i]); } return result; }",'2139,'56.39648438
'141,'Text 1480,"'The function first copies over the receiver object into a new local IntSet. It then iterates over the elements in the other IntSet, inserting them into the result. As we saw last time, the insert () function only inserts an element if the set does not already contain the item.",'2140,'95.99609375
'141,'Text 1481,"'We can now call the member function directly, or we can apply the + operator instead. When we do so, the compiler finds the overloaded operator+ and calls it for us.",'2141,'94.58007813
'141,'Text 1482,"'1 The operand can also be of enumeration type, which is beyond the scope of this course.",'2142,'71.67968750
'141,'Page number 138,"'136",'2143,'84.91210938
'142,'Header 130,"'Programming and Data Structures, Release 0.3",'2144,'50.97656250
'142,'Figure 44,"",'2145,'36.42578125
'142,'Text 1483,"'int main() { IntSet set set1.insert (32); setl.insert (42) set1. insert (7) IntSet set2; set2.inserte (12) ; set2. insert(-3) ; set2. insert(42) ; IntSet set3 = set1.operator+(set2); set3.print (cout) ; // prints { 32, 42, 7, 12, -3 } IntSet set4 = set1 + set2; set4.print (cout) ; // prints { 32, 42, 7, 12, -3 }",'2146,'27.05078125
'142,'Text 1484,"'}",'2147,'99.13269806
'142,'Text 1485,"'In theory, we could instead define the overloaded operator as a top-level function, declared as follows:",'2148,'86.27929688
'142,'Text 1486,"'IntSet operator+ (const IntSet &lhs, const IntSet &rhs)",'2149,'69.43359375
'142,'Text 1487,"'However, we did not define an interface for iterating through the elements of an IntSet from outside the class, SO we cannot actually implement this function.",'2150,'94.53125000
'142,'Text 1488,"'Overloaded operators can take arguments by value or by reference, like any other function. In most cases, we pass the arguments by reference to avoid making a copy.",'2151,'93.99414063
'142,'Text 1489,"'Though most operators can be overloaded either as top-level or member functions, there are some cases where we must use a top-level function:",'2152,'95.11718750
'142,'List 43,"",'2153,'94.58007813
'142,'Text 1490 - Part of List 43,"'The first operand is of atomic type. Atomic types are not classes, SO they do not have member functions.",'2154,'97.60742188
'142,'Text 1491 - Part of List 43,"'The first operand is of class type, but we do not have access to the class definition, SO we cannot define a new member function.",'2155,'97.41210938
'142,'Text 1492,"'An example of the latter is overloading the stream-insertion operator, where we do not have access to the definition of ostream. The following overloads insertion of an IntSet:",'2156,'96.04492188
'142,'Text 1493,"'std: : ostream & operator<<(std::ostream &os, const IntSet &set) { set.print (os) return os; }",'2157,'94.43359375
'142,'Text 1494,"'We saw previously that inserting to a stream evaluates back to the stream object. To support this properly, our overload returns the given stream object. It must return the object by reference:",'2158,'95.99609375
'142,'List 44,"",'2159,'93.21289063
'142,'Text 1495 - Part of List 44,"'Streams cannot be copied, SO the code would not compile if it returned a stream by value.",'2160,'97.46093750
'142,'Text 1496 - Part of List 44,"'Even if streams could be copied, we want to return the original stream object itself, not a copy.",'2161,'96.72851563
'142,'Text 1497 - Part of List 44,"'Even if a copy would work, we would end up with object slicing, since os actually will refer to an object of a class that derives from ostream.",'2162,'96.24023438
'142,'Text 1498,"'The parameters are in the same order as the operands, from left to right. The function need only call the print () member function on the IntSet and then return the given ostream object. Then we can insert an IntSet directly into a stream:",'2163,'95.99609375
'142,'Footer 92,"'23.1. Operator Overloading",'2164,'77.73437500
'142,'Page number 139,"'137",'2165,'76.36718750
'143,'Header 131,"'Programming and Data Structures, Release 0.3",'2166,'49.60937500
'143,'Text 1499,"'int main() { IntSet set; set. insert (32) ; set. insert (42) ; cout set endl ; // prints { 32, 42 }",'2167,'54.00390625
'143,'Text 1500,"'}",'2168,'98.91075897
'143,'Text 1501,"'In other cases, we need to define an operator as a member function:",'2169,'81.68945313
'143,'List 45,"",'2170,'91.60156250
'143,'Text 1502 - Part of List 45,"'If the overload needs access to private members, a member function would have access because it is part of the class.",'2171,'97.11914063
'143,'Text 1503 - Part of List 45,"'Some operators can only be overloaded as member functions: the assignment operator (=), the function-call operator (()), the subscript operator ([]), and the arrow operator (->). (We will see examples of overloading the first two operators later.)",'2172,'97.70507813
'143,'Text 1504,"'As an example, let's overload the subscript operator to check whether the given value is in the set. The following does SO:",'2173,'95.31250000
'143,'Text 1505,"'class IntSet { public: bool operator [] (int value) const; } bool IntSet : operator [] (int value) const { return contains(value); }",'2174,'93.01757813
'143,'Text 1506,"'The following is an example of applying the operator:",'2175,'91.94335938
'143,'Table 53,"",'2176,'35.57128906
'143,'Section header 98,"'23.2 Parametric Polymorphism",'2177,'86.32812500
'143,'Text 1507,"'The IntSet container only holds elements that are of type int. Suppose we wanted another container that holds char values. One solution is to copy and paste the IntSet code, then change int to char everywhere it refers to the element type:",'2178,'97.65625000
'143,'Text 1508,"'class CharSet { public: // Maximum size of a set. static const int MAX_SIZE = 10; // EFFECTS: Initializes this set to be empty.",'2179,'92.62695313
'143,'Text 1509,"'(continues on next page)",'2180,'68.16406250
'143,'Text 1510,"'2 In the future, we will see that we can use a friend declaration to give an outside class or function access to private members. Friend declarations are sometimes used with operator overloads.",'2181,'65.77148438
'143,'Footer 93,"'23.2. Parametric Polymorphism",'2182,'74.21875000
'143,'Page number 140,"'138",'2183,'83.74023438
'144,'Header 132,"'Programming and Data Structures, Release 0.3",'2184,'43.31054688
'144,'Text 1511,"'(continued from previous page)",'2185,'65.13671875
'144,'Text 1512,"'CharSet();",'2186,'52.05078125
'144,'List 46,"",'2187,'32.93457031
'144,'Text 1513 - Part of List 46,"'// REQUIRES: size() < MAX_SIZE // MODIFIES: *this // EFFECTS: Adds value to the set, if it isn't already in the set. void insert(char value); // MODIFIES: *this // EFFECTS: Removes value from the set, if it is in the set. void remove(char value); // EFFECTS: Returns whether value is in the set. bool contains (char value) const; // EFFECTS: Returns the number of elements. int size() const; // EFFECTS: Prints out the set in an arbitrary order. void print(std::ostream &os) const; private: char elements [MAX_SIZE]; int num_elements; // INVARIANTS: // 0 num_elements && num_elements <= MAX_SIZE // the first num_elements items in elements are the items in the set // the first num_elements items in elements contain no duplicates",'2188,'32.93457031
'144,'Text 1514,"'};",'2189,'80.95110321
'144,'Text 1515,"'This is not a very satisfying solution. It leads to duplication of nearly identical code. Furthermore, if we then wanted a set of doubles, we would have to define an almost identical DoubleSet, and SO on. We already know how to avoid code duplication when we have a value that can be different: add a function parameter that allows the user to specify the value they care about. The problem here is that our entity that differs is not a value, but a type. While function parameters can represent different argument values, we need another mechanism for specifying type arguments. The mechanism that C++ provides is a template. A template is a model for producing code. We write a generic version, parameterized by one or more template param- eters. The compiler then instantiates a specific version of the code by substituting arguments for the parameters and compiling the resulting code. We specify a template and its parameters by placing a template header before the entity that we are defining.",'2190,'26.02539063
'144,'Text 1516,"'template <typename T> class UnsortedSet { };",'2191,'68.35937500
'144,'Text 1517,"'The template header can go on the same line or the previous one: whitespace generally does not matter in C++. The header begins with the template keyword, followed by a parameter list surrounded by angle brackets. Within the parameter list, we introduce a template parameter by specifying the kind of entity the parameter can represent. The typename keyword indicates that the parameter is a type parameter. 3 The parameter name then follows. Here, we have",'2192,'94.82421875
'144,'Text 1518,"'3 The class keyword can be used instead of typename; the two are equivalent in this context. With either keyword, a non-class type can still be used as the type argument.",'2193,'70.50781250
'144,'Footer 94,"'23.2. Parametric Polymorphism",'2194,'59.27734375
'144,'Page number 141,"'139",'2195,'75.78125000
'145,'Header 133,"'Programming and Data Structures, Release 0.3",'2196,'63.52539063
'145,'Text 1519,"'chosen the name T, since we don't have further information about the type. (Value_type or Element_type are other common names to use with a container.)",'2197,'98.14453125
'145,'Text 1520,"'A template may have more than one parameter, and it can also have a parameter that is of integral type. The following is how the std: : array template is declared:",'2198,'96.58203125
'145,'Text 1521,"'template <typename T, std: size_t N> class array;",'2199,'72.31445313
'145,'Text 1522,"'Since the entity that follows the template header is a class, it is a class template. It takes two arguments, one for the element type and the other for the size of the container, which must be a compile-time constant. We can then create a std: : array of 10 ints as follows:",'2200,'97.16796875
'145,'Text 1523,"'std: : array<int, 10> items;",'2201,'88.18359375
'145,'Text 1524,"'The syntax for using a class template is to follow the name of the template with an argument list enclosed by angle brackets. We can similarly create and use an unsorted set of chars:",'2202,'97.31445313
'145,'Text 1525,"'UnsortedSet<char> char_set; char_set.insert('e'); char_set.insert('a'); char_set.insert('e') cout << char_set << endl; // prints { e, a }",'2203,'72.16796875
'145,'Text 1526,"'In order for this to work, we write the definition of UnsortedSet to use the template parameter T for the element type. The scope of a template parameter is the entire entity that follows; if it is a class, then the scope is the entire class definition.",'2204,'96.87500000
'145,'Table 54,"",'2205,'29.78515625
'145,'Text 1527,"'(continues on next page)",'2206,'73.38867188
'145,'Footer 95,"'23.2. Parametric Polymorphism",'2207,'49.21875000
'145,'Page number 142,"'140",'2208,'79.49218750
'146,'Header 134,"'Programming and Data Structures, Release 0.3",'2209,'51.75781250
'146,'Text 1528,"'(continued from previous page)",'2210,'55.56640625
'146,'Section header 99,"'private:",'2211,'58.88671875
'146,'Text 1529,"'T elements [MAX_SIZE]; int num_elements;",'2212,'52.92968750
'146,'List 47,"",'2213,'42.43164063
'146,'Text 1530 - Part of List 47,"'// INVARIANTS:",'2214,'38.76953125
'146,'Text 1531 - Part of List 47,"'// 0 <= num_elements && num_elements <= MAX_SIZE",'2215,'51.85546875
'146,'Text 1532 - Part of List 47,"'// the first num_elements items in elements are the items in the set",'2216,'56.78710938
'146,'Text 1533 - Part of List 47,"'// the first num_elements items in elements contain no duplicates }",'2217,'50.29296875
'146,'Text 1534,"'The actual type argument used to instantiate UnsortedSet may be something small like int, or it may be a large class type such as string. Thus, it is good practice to pass objects of a template parameter by reference rather than by value, avoiding copying potentially large objects.",'2218,'90.38085938
'146,'Text 1535,"'When we use UnsortedSet with a particular type argument, the compiler actually plugs the argument in for T, gener- ating code for that instantiation and compiling it with the rest of the program. For example, UnsortedSet<string> is instantiated as follows:",'2219,'87.98828125
'146,'Text 1536,"'class UnsortedSet<string> { public:",'2220,'42.52929688
'146,'Key value 34,"",'2221,'45.14160156
'146,'Page number 143,"'141",'2222,'88.91601563
'146,'Footer 96,"'23.2. Parametric Polymorphism",'2223,'78.61328125
'147,'Header 135,"'Programming and Data Structures, Release 0.3",'2224,'50.58593750
'147,'Section header 100,"'23.2.1 Function Templates",'2225,'58.20312500
'147,'Text 1537,"'We can also define a function as a template, resulting in a function template. For example, the following computes the maximum of two items of the same type:",'2226,'98.58398438
'147,'Section header 101,"'template <typename T>",'2227,'62.25585938
'147,'Figure 45,"",'2228,'49.31640625
'147,'Text 1538,"'T max (const T &value1, const T &value2) { return value2 > value1 ? value2 : value1; }",'2229,'94.48242188
'147,'Text 1539,"'As with a class template, we define a function template by preceding it with a template header, which introduces one or more template parameters. We can then use the parameter anywhere in the function definition. Here, our function template takes two arguments of the same type and compares them. The ?: operator is a conditional. It evaluates its first operand, and if the result is true, it produces the second operand. Otherwise, it produces the third operand.",'2230,'95.41015625
'147,'Text 1540,"'Similar to a class template, we can use a function template by following its name with an argument list enclosed by angle brackets:4",'2231,'92.43164063
'147,'Text 1541,"'int main() { int il = 3; int i2 = -3; cout << max<int> (i1, i2) << endl; cout << max<double> (3.1, 7.5) << endl; }",'2232,'93.26171875
'147,'Text 1542,"'Unlike a class template, however, the compiler is able in most cases to deduce the template argument from the arguments to the function call. In the first call above, the arguments are both of type int, SO the compiler can deduce that we want int as the template argument. Similarly, the arguments are both of type double in the second call, SO the compiler can deduce we want double. Thus, we can leave off the explicit template arguments:",'2233,'97.41210938
'147,'Text 1543,"'int main() { int i1 = 3; int i2 = 33 cout << max(i1, i2) << endl; // deduced as max<int> (i1, i2) cout << max (3. 7.5) << endl; // deduced as max<double> (3.1, 7.5) }",'2234,'82.42187500
'147,'Text 1544,"'The max () function template can only be applied to a type that supports the > operator. If we try to call it on objects that don't support the operator, the result is a compile error:",'2235,'96.48437500
'147,'Text 1545,"'int main() { Duck d1 (""Donald"") Duck d2 (""Scrooge"") ; Duck best_duck = max (d1, d2); cout << best_duck.get_name << "" wins! << endl; }",'2236,'91.11328125
'147,'Text 1546,"'This results in an error like the following:",'2237,'72.50976563
'147,'Text 1547,"'main. cpp: In instantiation of 'T (const T&, const T&) [with T = Duck] main. cpp: 20:30: required from here main. cpp: 14:17: error: no match for 'operator>' (operand types are 'const Duck' and (continues on next page)",'2238,'93.60351563
'147,'Text 1548,"'4 Depending on the compiler and what headers are included, we may have to tell the compiler that we intend to use our max function template rather than the one in the standard library. We can do SO by using the scope-resolution operator with nothing to the left: : :max<double> (3.1, 7.5).",'2239,'77.68554688
'147,'Footer 97,"'23.2. Parametric Polymorphism",'2240,'44.26269531
'147,'Page number 144,"'142",'2241,'84.03320313
'148,'Header 136,"'Programming and Data Structures, Release 0.3",'2242,'52.63671875
'148,'Text 1549,"'(continued from previous page)",'2243,'88.28125000
'148,'Text 1550,"'const Duck') return value2 > value1 ? value2 : value1;",'2244,'87.64648438
'148,'Text 1551,"'The offending line of code is the one marked as ""required from here"" - it is the line that attempts to call max () on two Duck objects. The compiler actually instantiates max<Duck>(), but the resulting instantiation produces errors when the compiler tries to compile it.",'2245,'97.60742188
'148,'Section header 102,"'23.2.2 Compiling Templates",'2246,'86.62109375
'148,'Text 1552,"'We saw previously that the C++ compiler only needs access to declarations when compiling code that uses a class or a function defined in some other source file. However, this is not the case for class and function templates. The compiler must actually instantiate the definitions for each set of template arguments, SO it must have access to the full definition of a template.",'2247,'96.72851563
'148,'Text 1553,"'To provide the compiler with access to the full definition of a template wherever it is used, we must arrange for the header file to contain the full definition. We can just define the template directly in the header file itself; it is still good practice to separate the declarations from the definitions for the benefit of anyone using our code.",'2248,'95.94726563
'148,'Text 1554,"'// max.hpp",'2249,'57.76367188
'148,'Text 1555,"'// EFFECTS: Returns the maximum of value1 and value2. template <typename T> T max(const T &value1, const T &value2) ;",'2250,'82.32421875
'148,'Text 1556,"'template <typename T> T max (const T &value1, const T &value2) { return value2 > value1 ? value2 : value1; }",'2251,'68.35937500
'148,'Text 1557,"'A better organization is to separate the definitions into their own file; common convention is to use a suffix like . tpp for this file. We can then use a #include directive to pull the code into the header file:",'2252,'95.60546875
'148,'Text 1558,"'// max.hpp // EFFECTS: Returns the maximum of value1 and value2. template <typename T> T max (const T &value1, const T &value2) #include ""max.tpp""",'2253,'95.94726563
'148,'Section header 103,"'// max. tpp",'2254,'42.52929688
'148,'Text 1559,"'template <typename T> T max (const T &value1, const T &value2) { return value2 > value1 ? value2 : value1; }",'2255,'77.34375000
'148,'Text 1560,"'Code that uses the max module would then just #include ""max.hpp"", which would transitively include max. tpp.",'2256,'94.87304688
'148,'Footer 98,"'23.2. Parametric Polymorphism",'2257,'71.14257813
'148,'Page number 145,"'143",'2258,'85.93750000
'149,'Header 137,"'Programming and Data Structures, Release 0.3",'2259,'56.00585938
'149,'Section header 104,"'23.2.3 Include Guards",'2260,'59.47265625
'149,'Text 1561,"'In complex programs, it is often the case that a single file inadvertently #includes the same header file more than once. For instance, it may be that module A depends on module B and thus includes its header. Then module C depends on both A and B, SO it includes both their headers. This results in module C including B's header twice, which can cause compiler errors that a function or a class is defined more than once.",'2261,'98.29101563
'149,'Text 1562,"'To avoid problems with a header being included more than once, headers generally have include guards that arrange for the compiler to ignore the code if the header is included a second time. The following is an example of include guards:",'2262,'96.38671875
'149,'Text 1563,"'#ifndef MAX_HPP #define MAX_HPP",'2263,'64.06250000
'149,'Text 1564,"'// max.hpp // EFFECTS: Returns the maximum of value1 and value2. template <typename T> T max(const T &value1, const T &value2) ; #include ""max. tpp"" #endif 1* MAX_HPP */",'2264,'89.84375000
'149,'Text 1565,"'The #i fndef and #define directives are the opening of the include guard, and the #endi f closes it. The code within is ignored if the header is included again. 5",'2265,'93.01757813
'149,'Section header 105,"'23.2.4 Member-Function Templates",'2266,'81.83593750
'149,'Text 1566,"'Defining a member function within the definition for a class template is no different than a member function within a class. Defining a member function outside the definition of a class template differs from that of a regular class; we must inform the compiler that the function is a member of a class template.",'2267,'97.65625000
'149,'Text 1567,"'template <typename T> bool UnsortedSet<T> : : contains (const T &value) const { return indexOf(value) != -1; } template <typename T> void UnsortedSet<T>:: insert (const T &value) { assert(size() < MAX_SIZE) if (!contains(value)) { elements[num_elements] = value; ++num_elements; } }",'2268,'43.40820313
'149,'Text 1568,"'Here, we must tell the compiler that contains() is a member of UnsortedSet<T>. However, before we can use the name T, we need to introduce it with a template header. The scope of a template header is the entity that immediately follows; thus, each member-function definition needs its own template header.",'2269,'94.23828125
'149,'Text 1569,"'5 The #i fndef checks whether the macro MAX_HPP is defined. If not, the compiler processes the code between the #i fndef and the #endif The #define introduces a definition for MAX_HPP. The next time the header is included, MAX_HPP is defined, SO the #ifndef becomes false, and the compiler ignores the code between the #ifndef and #endif. A widely supported but nonstandard alternative is #pragma once, which need only be placed at the top of file.",'2270,'54.00390625
'149,'Footer 99,"'23.2. Parametric Polymorphism",'2271,'67.67578125
'149,'Page number 146,"'144",'2272,'88.23242188
'150,'Header 138,"'Programming and Data Structures, Release 0.3",'2273,'46.38671875
'150,'Section header 106,"'23.2.5 Insertion-Operator Template",'2274,'71.77734375
'150,'Text 1570,"'Now that we have an UnorderedSet class template, we can write an insertion operator that works on any instantiation by defining it as a function template:",'2275,'98.63281250
'150,'Text 1571,"'template <typename T>",'2276,'27.05078125
'150,'Figure 46,"",'2277,'79.44335938
'150,'Text 1572,"'std: ostream & operator<<(std::ostream &os, const UnsortedSet<T> &set) { set.print(os); return os; }",'2278,'96.48437500
'150,'Text 1573,"'The function template is parameterized by the element type of an UnorderedSet, and we use the template parameter as part of the type for the second function parameter. The compiler is able to deduce the template argument when we insert a set into a stream:",'2279,'96.09375000
'150,'Text 1574,"'UnsortedSet<char> char_set; char_set.insert ('e'); char_set.insert('a'); char_set.insert('e'); cout < char_set << endl; // prints e, a }",'2280,'49.80468750
'150,'Section header 107,"'23.2.6 Another Example",'2281,'88.91601563
'150,'Text 1575,"'Let us write a function template that copies elements from an array into a set. We would like to use it as follows:",'2282,'96.33789063
'150,'Text 1576,"'int main() { UnsortedSet<int> set1; int arr1 = { 1, 2, 3, 2 }; fill_from_array(set1, arr1, 4); cout << set1 << endl; // prints { 1, 2, 3 } UnsortedSet<char> set2; char arr2 = { 'a', 'b', 'a' }; // prints { a, b} fill_from_array(set2 arr2, 3); }",'2283,'42.52929688
'150,'Text 1577,"'The fill_from_array() template must be parameterized by the element type, and we use that type for both the set and array function parameters:",'2284,'96.48437500
'150,'Figure 47,"",'2285,'39.69726563
'150,'Text 1578,"'template <typename T> void fill_from_array(UnsortedSet<T> &set, const T *arr, int size) { for (int i=0; size; ++i) { set.insert(arr[i]); } }",'2286,'96.77734375
'150,'Text 1579,"'The set is passed by reference, to avoid making a copy and to allow the function to modify the original set. The array decays into a pointer when it is passed, and we declare the pointer as a pointer to const, since we do not need to modify the array elements. The body of the function template just iterates over the array, inserting each element into the set; the set ignores insertion of duplicate values, SO there is no need to check whether the set already contains a value before inserting it.",'2287,'96.87500000
'150,'Footer 100,"'23.2. Parametric Polymorphism",'2288,'79.58984375
'150,'Page number 147,"'145",'2289,'83.93554688
'151,'Header 139,"'Programming and Data Structures, Release 0.3",'2290,'78.71093750
'151,'Section header 108,"'23.3 Static vs. Dynamic Polymorphism",'2291,'45.33691406
'151,'Text 1580,"'The template mechanism gives us parametric polymorphism; a template type parameter can take on the form of any type. The compiler instantiates the code at compile time, SO we also refer to this as static polymorphism. Compare this with subtype polymorphism, where the program resolves virtual function calls at runtime; we therefore use dynamic polymorphism to also refer to it.",'2292,'97.31445313
'151,'Text 1581,"'In designing an ADT, we have the choice of static polymorphism, dynamic polymorphism, or both. For instance, SortedSet and UnsortedSet share the same interface, SO we could define a common base interface and make use of dynamic binding. However, dynamic polymorphism comes with a runtime performance cost; a virtual function call generally requires two extra pointer dereferences compared to a non-virtual call. For a container, a program may make many calls to insert items, remove items, check whether an item is in the container, and SO on. Thus, the general convention in C++ is to avoid dynamic polymorphism with containers.",'2293,'96.82617188
'151,'Text 1582,"'Another reason why dynamic polymorphism is not a good fit for a container is that we usually make the decision of which container to use when we write our code, not when we run it. However, it is still good practice to write our code in such a way that we can easily change the container type we are using. Ideally, we would have a single location in our code that needs to change if we decide to use something else. We've seen this pattern already when it comes to a value that is used in many places: define a constant or variable, and use the associated name rather than the value directly. Thus, introducing a new name for an entity is a powerful form of abstraction, allowing us to avoid hardcoding the entity everywhere in our code. C++ gives us this capability for types with type aliases.",'2294,'95.41015625
'151,'Section header 109,"'23.3.1 Type Aliases",'2295,'89.06250000
'151,'Text 1583,"'A type alias is a new name for an existing type. We can introduce a type alias with a using declaration:",'2296,'96.87500000
'151,'Section header 110,"'using UnsortedIntSet = UnsortedSet<int>;",'2297,'75.00000000
'151,'Text 1584,"'The syntax for introducing a type alias with a using declaration is the using keyword, followed by the name we want to introduce, the = symbol, and the existing type that we want the name to alias. The example above introduces the name UnsortedIntSet as an alias for the type UnsortedSet<int>.",'2298,'97.65625000
'151,'Text 1585,"'A simple alias can also be defined with the typedef keyword:",'2299,'91.69921875
'151,'Section header 111,"'typedef UnsortedSet<int> UnsortedIntSet;",'2300,'52.24609375
'151,'Text 1586,"'The syntax is in the reverse order of a using declaration: the existing type first, then the new alias.",'2301,'95.50781250
'151,'Text 1587,"'A using declaration (but not a typedef) can also define an alias template, which introduces a new name that is a template for a set of types. The following is an example:",'2302,'95.41015625
'151,'Text 1588,"'template <typename T> using Set = UnsortedSet<T>",'2303,'52.34375000
'151,'Text 1589,"'Similar to any template, we introduce an alias template by placing a template header with the requisite parameters before the using declaration. Then we can use Set in the same way we would a class template:",'2304,'96.14257813
'151,'Section header 112,"'template <typename T> using Set = UnsortedSet<T>;",'2305,'36.25488281
'151,'Text 1590,"'template <typename T> void fill_from_array(Set<TX &set, const T *arr, int n); int main() {",'2306,'25.04882813
'151,'Text 1591,"'(continues on next page)",'2307,'56.29882813
'151,'Footer 101,"'23.3. Static vs. Dynamic Polymorphism",'2308,'80.17578125
'151,'Page number 148,"'146",'2309,'83.00781250
'152,'Header 140,"'Programming and Data Structures, Release 0.3",'2310,'62.35351563
'152,'Text 1592,"'(continued from previous page)",'2311,'60.59570313
'152,'Key value 35,"",'2312,'60.83984375
'152,'Text 1593,"'}",'2313,'88.41451263
'152,'Text 1594,"'The compiler treats Set<int> and Set<char> as UnsortedSet<int> and UnsortedSet<char>, since Set is an alias for UnsortedSet. If we decide to use sorted sets instead, there is just one place we need to change:",'2314,'93.35937500
'152,'Text 1595,"'template <typename T> using Set = SortedSet<T>;",'2315,'46.77734375
'152,'Figure 48,"",'2316,'31.39648438
'152,'Text 1596,"'Now the compiler will treat Set<int> and Set<char> as SortedSet<int> and SortedSet<char>.",'2317,'94.48242188
'152,'Section header 113,"'23.3.2 The Factory Pattern",'2318,'83.74023438
'152,'Text 1597,"'With dynamic polymorphism, we can defer the decision of which derived class to use until runtime. For example, the following code asks the user for what color bird they want, then calls a factory function to create the actual object:",'2319,'96.77734375
'152,'Text 1598,"'int main() { string color; cin >> color; Bird *bird = Bird_factory(color, ""Myrtle""); cout << ""Bird <<bird->get_name( <<"" is <<bird->get_age() <<"" and says: "" << bird->talk() << endl; delete bird; cin >> color; bird = Bird_factory (color, ""Heihei""); cout << ""Bird << bird->get_name <<""is""<< bird->get_age() <<"" and says: << bird->talk() << endl; delete bird;",'2320,'28.61328125
'152,'Text 1599,"'}",'2321,'98.31066132
'152,'Text 1600,"'The factory function creates an object of the appropriate derived type and returns a pointer to it. It cannot create the object in local memory - a local object dies when the function that created it returns, SO it would not live past the call to Bird_factory(). Instead, we create it in dynamic memory with the new operator:",'2322,'95.75195313
'152,'Text 1601,"'Bird * Bird_factory (const string &color, const string &name) { if (color == ""blue"") return new BlueBird(name) } else if (color == ""black"") { return new Raven (name) } }",'2323,'64.89257813
'152,'Text 1602,"'We then use the delete operator on the object's address when we no longer need it.",'2324,'76.07421875
'152,'Text 1603,"'We will start looking at dynamic memory in more detail next time.",'2325,'64.16015625
'152,'Footer 102,"'23.3. Static vs. Dynamic Polymorphism",'2326,'53.32031250
'152,'Page number 149,"'147",'2327,'89.59960938
'153,'Header 141,"'Programming and Data Structures, Release 0.3",'2328,'56.49414063
'153,'Section header 114,"'23.3.3 Liskov Substitution Principle",'2329,'46.87500000
'153,'Text 1604,"'When designing an inheritance hierarchy, an important property is substitutability of a derived-class object for a base- class one. This notion is formalized by the Liskov substitution principle, which states that in order for type S to be a subtype of type T, the following requirement must be met:",'2330,'98.14453125
'153,'Text 1605,"'Any property of objects of type T should also be a property of objects of type S.",'2331,'75.14648438
'153,'Text 1606,"'-Barbara Liskov, MIT",'2332,'75.58593750
'153,'Text 1607,"'This implies that in any code that depends on T's interface, an object of type S can be substituted without any unde- sirable effects. If the requirement above is not satisfied, S would be a derived type of T but not a subtype.",'2333,'95.26367188
'153,'Text 1608,"'A classic example is a ToyDuck class that derives from Duck:",'2334,'66.69921875
'153,'Text 1609,"'class ToyDuck : public Duck { public: // EFFECTS: Prints out quack if battery level >= 10. void talk() const override { if (battery_level >= 10) { cout << ""quack"" << endl; --battery_level; } } };",'2335,'95.31250000
'153,'Text 1610,"'Code that uses a Duck may assume that a quacking noise gets printed out each time talk() is called. A ToyDuck would violate this expectation, since it does not print anything out if the ToyDuck has insufficient battery. Thus, ToyDuck is a derived type of Duck, but not a subtype.",'2336,'95.65429688
'153,'Footer 103,"'23.3. Static vs. Dynamic Polymorphism",'2337,'84.17968750
'153,'Page number 150,"'148",'2338,'89.84375000
'154,'Header 142,"'Programming and Data Structures, Release 0.3",'2339,'80.27343750
'154,'Figure 49,"",'2340,'89.64843750
'154,'Text 1611,"'LISKOV SUBSTITUTION PRINCIPLE If It Looks Like A Duck, Quacks Like A Duck, But Needs Batteries - You Probably Have The Wrong Abstraction",'2341,'43.96972656
'154,'Text 1612,"'Figure 23.1: Liskov substitution principle. Credit: Derick Bailey, retrieved from Stack Overflow",'2342,'92.08984375
'154,'Footer 104,"'23.3. Static VS. Dynamic Polymorphism",'2343,'90.86914063
'154,'Page number 151,"'149",'2344,'88.08593750
'155,'Header 143,"'CHAPTER",'2345,'60.74218750
'155,'Header 144,"'TWENTYFOUR",'2346,'64.50195313
'155,'Title 38,"'MEMORY MODELS AND DYNAMIC MEMORY",'2347,'89.99023438
'155,'Text 1613,"'Recall that an object is a piece of data in memory, located at some address in memory. An object also has a storage duration that determines its lifetime. In this course, we consider three storage durations:",'2348,'95.41015625
'155,'List 48,"",'2349,'88.18359375
'155,'Text 1614 - Part of List 48,"'static: the lifetime is essentially the whole program",'2350,'97.75390625
'155,'Text 1615 - Part of List 48,"'automatic (also called local): the lifetime is tied to a particular scope, such as a block of code",'2351,'98.58398438
'155,'Text 1616 - Part of List 48,"'dynamic: the object is explicitly created and destroyed by the programmer",'2352,'97.36328125
'155,'Text 1617,"'The first two durations are controlled by the compiler, and an object with static or automatic scope is associated with a variable. Objects with dynamic storage are managed by the programmer, and they are not directly associated with variables.",'2353,'97.50976563
'155,'Text 1618,"'The following variables refer to objects with static storage duration:",'2354,'92.67578125
'155,'List 49,"",'2355,'86.96289063
'155,'Text 1619 - Part of List 49,"'global variables¹",'2356,'96.92382813
'155,'Text 1620 - Part of List 49,"'static member variables",'2357,'95.94726563
'155,'Text 1621 - Part of List 49,"'static local variables",'2358,'95.55664063
'155,'Text 1622,"'The lifetime of these objects is essentially the whole program, SO they can be used at any point in time in the program. 2",'2359,'94.48242188
'155,'Section header 115,"'24.1 Static Local Variables",'2360,'90.82031250
'155,'Text 1623,"'We have already seen global and static member variables. A static local variable is a local variable declared with the static keyword. Rather than living in the activation record for a function call, it is located in the same region of memory as other variables with static storage duration, and there is one copy of each static local variable in the entire program. The following is an example:",'2361,'97.07031250
'155,'Table 55,"",'2362,'28.14941406
'155,'Text 1624,"'1 Also those defined at namespace scope. 2 Initialization in C++ is rather complicated, and the details are beyond the scope of this course. A relatively safe assumption is that variables with static storage duration can be initialized in any order before main is run, but that they have all been initialized by the time main () is called.",'2363,'40.06347656
'155,'Page number 152,"'150",'2364,'88.18359375
'156,'Header 145,"'Programming and Data Structures, Release 0.3",'2365,'63.86718750
'156,'Text 1625,"'The count static local variable is initialized to 0, SO its value is 0 the first time count_calls() is called. The call increments count and returns the new value of 1. The next time count_calls() is called, count has value 1. It gets incremented again, and the call returns 2. And SO on. Thus, all calls to count_calls() use the same count object, unlike a non-static local variable, where each call would get its own object.",'2366,'97.55859375
'156,'Section header 116,"'24.2 Automatic Storage Duration",'2367,'62.50000000
'156,'Text 1626,"'Function parameters and local variables have automatic storage duration, also called local storage duration. The lifetime of the associated object corresponds to the variable's scope, the region of code where it is valid to refer to the variable. The scope of a variable begins at its point of declaration and ends at the end of the scope region in which it is defined. A scope region can be the body of a function, a whole loop or conditional, the body of a loop or conditional, or just a plain block denoted by curly braces. For example, consider the following code:",'2368,'97.75390625
'156,'Text 1627,"'void func (int X) { for (int = 2; i 10; ++i) { string "" cats""; cout << i << s << endl; } // end scope of i, S int y = 10; { int Z==3 cout << < << endl; } // end scope of Z } // end scope of X, y",'2369,'87.40234375
'156,'Text 1628,"'The variables fall into the following categories;",'2370,'45.70312500
'156,'List 50,"",'2371,'96.72851563
'156,'Text 1629 - Part of List 50,"'The scope of a parameter is the entire function body. Thus, the lifetime of the object associated with X begins when the function is called and ends when the function returns.",'2372,'98.33984375
'156,'Text 1630 - Part of List 50,"'The scope of a variable declared in a loop header is the entire loop. Thus, the lifetime of the object i begins when the loop starts and ends when the loop exits.",'2373,'97.90039063
'156,'Text 1631 - Part of List 50,"'The scope of a variable declared within a block is from its point of declaration to the end of the block. The lifetime of S begins when its initialization runs and ends at the end of a loop iteration - a new object associated with S is created in each iteration. The lifetime of y also begins when its initialization runs, and it ends when the function returns. Lastly, the lifetime of Z starts when its declaration is run and ends when the code exits the block containing z's declaration.",'2374,'98.19335938
'156,'Text 1632,"'Scope generally prevents us from using a local variable beyond the lifetime of its associated object. However, indirection through a pointer or reference can circumvent this protection. The following is an example:",'2375,'95.99609375
'156,'Text 1633,"'int *func1() int x = 3; return &x; } void func2() { int y = 5; }",'2376,'38.25683594
'156,'Text 1634,"'(continues on next page)",'2377,'83.69140625
'156,'Footer 105,"'24.2. Automatic Storage Duration",'2378,'61.52343750
'156,'Page number 153,"'151",'2379,'88.37890625
'157,'Header 146,"'Programming and Data Structures, Release 0.3",'2380,'71.87500000
'157,'Text 1635,"'(continued from previous page)",'2381,'71.67968750
'157,'Text 1636,"'int main() { int = func1(); func2(); assert == 3); // ASSERTION FAILURE }",'2382,'38.91601563
'157,'Figure 50,"",'2383,'91.65039063
'157,'Text 1637,"'Figure 24.1: Returning the address of a local variable results in a pointer that refers to a dead object. Dereferencing the pointer produces undefined behavior.",'2384,'92.48046875
'157,'Text 1638,"'When the program calls func1 (), it places the activation record on the stack, with X inside of the activation record. The call returns the address of X, which gets stored in Z. However, when the call returns, its activation record is destroyed, SO Z is actually pointing at a dead object. The memory for that activation record can then be reused for something else - in the case of Figure 24.1, the activation record for func2 placing y at the same address used for X. Dereferencing Z results in undefined behavior; in this case, since the memory was reused for y, dereferencing Z results in the value 5, not 3.",'2385,'96.38671875
'157,'Text 1639,"'There are cases, however, where we want an object's lifetime to last beyond the execution of the function that creates it. Previously, we saw the factory pattern, where a factory function creates an object and returns its address. We used the new operator to decouple the lifetime of the object from the duration of the function call:",'2386,'94.48242188
'157,'Text 1640,"'Bird Bird_factory (const string &color, const string &name) { if (color == ""blue"") { return new BlueBird (name) } else if (color == ""black"") { return new Raven (name) } }",'2387,'76.22070313
'157,'Section header 117,"'24.3 Address Space",'2388,'89.16015625
'157,'Text 1641,"'The new operator creates an object not in some activation record, but in an independent region of memory called the heap. The stack and heap are two of the segments that make up a program's address space, which is the total memory associated with a running program. Figure 24.2 depicts a typical layout for an address space.",'2389,'97.11914063
'157,'Text 1642,"'The text segment contains the actual machine instructions representing the program's code, and it is often placed at the bottom of a program's address space. (Nothing is located at address 0, since that is the representation used for a null pointer.) Space for objects in static storage generally is located above the text segment, followed by the heap. The latter can grow or shrink as objects in dynamic memory are created and destroyed; in most implementations the heap grows upward as needed, into the empty space between the heap and stack. The stack starts at the top of the address space, and it grows downward when a new activation record is created.",'2390,'97.16796875
'157,'Footer 106,"'24.3. Address Space",'2391,'80.37109375
'157,'Page number 154,"'152",'2392,'87.20703125
'158,'Header 147,"'Programming and Data Structures, Release 0.3",'2393,'62.45117188
'158,'Text 1643,"'Stack (grows down)",'2394,'97.36328125
'158,'Figure 51,"",'2395,'83.49609375
'158,'Text 1644,"'THE BIG VOID",'2396,'37.35351563
'158,'Figure 52,"",'2397,'95.11718750
'158,'Text 1645,"'Heap (grows up)",'2398,'61.42578125
'158,'Text 1646,"'Static Storage (Fixed size)",'2399,'60.59570313
'158,'Text 1647,"'Text (The program)",'2400,'62.15820313
'158,'Text 1648,"'Address 0",'2401,'53.80859375
'158,'Text 1649,"'Address MAX",'2402,'72.70507813
'158,'Text 1650,"'Figure 24.2: The address space of a program.",'2403,'96.04492188
'158,'Section header 118,"'24.4 The new and delete Operators",'2404,'80.61523438
'158,'Text 1651,"'The syntax of a new expression consists of the new keyword, followed by a type, followed by an optional initialization using parentheses or curly braces. The following are examples:",'2405,'96.58203125
'158,'Text 1652,"'// default initialization new int; // value initialization new int(); new int{}; // explicit initialization new int(3); new int{3};",'2406,'84.13085938
'158,'Text 1653,"'If no initialization is provided, the newly created object is default initialized. For an atomic type, nothing is done, SO the object's value is whatever is already there in memory. For a class type, the default constructor is called.",'2407,'92.91992188
'158,'Text 1654,"'Empty parentheses or curly braces result in value initialization. For an atomic type, the object is initialized to a zero value. For a class type, the default constructor is called.",'2408,'93.55468750
'158,'Text 1655,"'Explicit initialization can be done by supplying values in parentheses or curly braces. For atomic types, the value is used to initialize the object. For C-style ADTs, curly braces must be used, and the values within are used to initialize the member variables. For C++ ADTs, both parentheses and curly braces invoke a constructor with the values within as arguments.",'2409,'95.70312500
'158,'Text 1656,"'A new expression does the following:",'2410,'81.34765625
'158,'Text 1657,"'Allocates space for an object of the given type on the heap.",'2411,'96.38671875
'158,'Footer 107,"'24.4. The new and delete Operators",'2412,'77.78320313
'158,'Page number 155,"'153",'2413,'87.84179688
'159,'Header 148,"'Programming and Data Structures, Release 0.3",'2414,'78.22265625
'159,'List 51,"",'2415,'96.92382813
'159,'Text 1658 - Part of List 51,"'Initializes the object according to the given initialization expression.",'2416,'99.02343750
'159,'Text 1659 - Part of List 51,"'Evaluates to the address of the newly created object.",'2417,'98.53515625
'159,'Text 1660,"'The address is how we keep track of the new object; it is not associated with a variable name, SO we have to store the address somewhere to be able to use the object.",'2418,'98.38867188
'159,'Text 1661,"'int main(",'2419,'37.62207031
'159,'Text 1662,"'int *ptr = new int(3) ; cout << *ptr endl; // prints 3",'2420,'67.82226563
'159,'Text 1663,"'}",'2421,'69.53688812
'159,'Figure 53,"",'2422,'72.41210938
'159,'Text 1664,"'Figure 24.3: A new expression creates an object on the heap and evaluates to its address.",'2423,'94.09179688
'159,'Text 1665,"'The newly created object's lifetime is not tied to a particular scope. Rather, it begins when the new expression is evaluated and ends when the delete operator is applied to the object's address.",'2424,'96.43554688
'159,'Text 1666,"'delete ptr;",'2425,'84.37500000
'159,'Text 1667,"'Here, the operand to delete evaluates to the address value contained in ptr. The delete operator follows this address and destroys the object at that address.",'2426,'95.84960938
'159,'Figure 54,"",'2427,'81.34765625
'159,'Text 1668,"'Figure 24.4: Applying delete to an address in dynamic memory kills the object that lives at that address.",'2428,'96.14257813
'159,'Text 1669,"'The expression delete ptr; does not kill the ptr object - it is a local variable, and its lifetime ends when it goes out of scope. Rather, delete follows the pointer to the object it is pointing to and kills the latter. We can continue to use the pointer object itself:",'2429,'97.41210938
'159,'Table 56,"",'2430,'34.08203125
'159,'Footer 108,"'24.4. The new and delete Operators",'2431,'83.30078125
'159,'Page number 156,"'154",'2432,'91.16210938
'160,'Header 149,"'Programming and Data Structures, Release 0.3",'2433,'88.18359375
'160,'Title 39,"'24.5 Dynamic Arrays",'2434,'54.98046875
'160,'Text 1670,"'We saw previously that local and member-variable arrays must have a size that is known at compile time, SO the compiler can reason about the sizes of activation records and class-type objects. This restriction does not apply to dynamic arrays - since they are located on the heap rather than in an activation record or directly within a class-type object, the compiler does not need to know their size.",'2435,'97.31445313
'160,'Text 1671,"'The syntax for creating a dynamic array is the new keyword, an element type, square brackets containing an integer expression, and an optional initializer list. The expression within the square brackets need not be a compile-time constant:",'2436,'95.31250000
'160,'Text 1672,"'int main() { cout << ""How many elements? ""; int count; cin >> count; int *arr = new int[count] for (int i count; ++i) { arr[i] = i; } }",'2437,'79.29687500
'160,'Text 1673,"'A new array expression does the following:",'2438,'75.63476563
'160,'List 52,"",'2439,'96.04492188
'160,'Text 1674 - Part of List 52,"'Allocates space for an array of the given number of elements on the heap.",'2440,'97.21679688
'160,'Text 1675 - Part of List 52,"'Initializes the array elements according to the given initialization expression. If no initialization is provided, the elements are default initialized.",'2441,'97.65625000
'160,'Text 1676 - Part of List 52,"'Evaluates to the address of the first element of the newly created array.",'2442,'97.60742188
'160,'Text 1677,"'Previously, we saw that a local or member-variable array decays to a pointer to its first element when the array's value is required. A dynamic array immediately decays as part of the new array expression, SO the expression evaluates to the address of the first element.",'2443,'96.72851563
'160,'Text 1678,"'Figure 24.5 illustrates memory at the end of the code snippet above.",'2444,'93.21289063
'160,'Figure 55,"",'2445,'74.31640625
'160,'Text 1679,"'Figure 24.5: A new array expression creates an array on the heap and evaluates to the address of its first element.",'2446,'95.84960938
'160,'Text 1680,"'As with any pointer into an array, we can use the subscript operator to index into the array:",'2447,'95.94726563
'160,'Text 1681,"'arr[i] = i;",'2448,'67.13867188
'160,'Text 1682,"'This is equivalent to:",'2449,'90.96679688
'160,'Footer 109,"'24.5. Dynamic Arrays",'2450,'49.70703125
'160,'Page number 157,"'155",'2451,'80.17578125
'161,'Header 150,"'Programming and Data Structures, Release 0.3",'2452,'43.57910156
'161,'Text 1683,"'*(arr + i) = i;",'2453,'86.62109375
'161,'Text 1684,"'The lifetime of a dynamic array begins when it is created by a new array expression. It ends when the array-deletion operator delete is applied to the address of the array's first element:",'2454,'96.82617188
'161,'Text 1685,"'delete arr;",'2455,'69.09179688
'161,'Text 1686,"'Though the type of arr is int *, we cannot use the regular de lete operator on it; instead, we must inform the program with delete that we intend to delete a dynamic array, not just a single object on its own.",'2456,'93.26171875
'161,'Text 1687,"'Using the wrong deletion operator results in undefined behavior. It is also undefined behavior to apply delete [] to anything other than the address of the first element of a dynamic array.",'2457,'92.28515625
'161,'Text 1688,"'We cannot delete an individual element of an array. The lifetime of an array's elements are tied to the lifetime of the array as a whole; they are born when the array as a whole is born and die when the array dies.",'2458,'92.33398438
'161,'Section header 119,"'24.6 Lifetime of Class-Type Objects",'2459,'85.59570313
'161,'Text 1689,"'When a class-type object is created, a constructor is run to initialize it. 3 When a class-type object dies, its destructor is run to clean up its data. For a local object, this is when the associated variable goes out of scope. For a dynamic object, it is when delete is applied to its address.",'2460,'96.28906250
'161,'Text 1690,"'If a class-type object is an element of an array, it dies when the array dies, SO its destructor runs when the array is dying.",'2461,'89.30664063
'161,'Text 1691,"'The lifetime of member variables of a class-type object is tied to the lifetime of the object as a whole. When the object dies, its members die as well; if they are of class-type themselves, their destructors run. Specifically, the members of a class-type object are automatically destroyed after the destructor of the object is run, in reverse order of their declarations. The following is an example:",'2462,'96.19140625
'161,'Table 57,"",'2463,'35.08300781
'161,'Text 1692,"'3 The exception is aggregates (C-style ADTs) that are initialized directly with an initializer list.",'2464,'58.59375000
'161,'Footer 110,"'24.6. Lifetime of Class-Type Objects",'2465,'67.38281250
'161,'Page number 158,"'156",'2466,'83.88671875
'162,'Header 151,"'Programming and Data Structures, Release 0.3",'2467,'47.75390625
'162,'Text 1693,"'(continued from previous page)",'2468,'82.66601563
'162,'Section header 120,"'private:",'2469,'41.87011719
'162,'Text 1694,"'string cstr; M ml; M m2; } ;",'2470,'88.76953125
'162,'Text 1695,"'int main() { C c1(""c1""); C *cptr = new C(""(*cptr)""); C c2(""c2""); delete cptr;",'2471,'88.13476563
'162,'Text 1696,"'}",'2472,'30.12695313
'162,'Text 1697,"'This prints the following when run:",'2473,'80.81054688
'162,'Table 58,"",'2474,'28.58886719
'162,'Text 1698,"'When main() is run, the declaration of c1 creates a C object and calls its constructor. The latter first initializes the members m1 and m2 in order before running the body of C's constructor. Thus, we get the output:",'2475,'97.02148438
'162,'Text 1699,"'M ctor: c1.m1 M ctor: c1.m2 C ctor: c1",'2476,'94.87304688
'162,'Text 1700,"'The code then constructs a C object in dynamic memory, resulting in:",'2477,'96.72851563
'162,'Text 1701,"'M ctor: (*cptr). ml M ctor: (*cptr). .m2 C ctor: (*cptr)",'2478,'88.47656250
'162,'Text 1702,"'It then creates another local C object:",'2479,'95.70312500
'162,'Text 1703,"'M ctor: c2.m1 M ctor: c2.m2 C ctor: c2",'2480,'86.66992188
'162,'Footer 111,"'24.6. Lifetime of Class-Type Objects",'2481,'47.85156250
'162,'Page number 159,"'157",'2482,'80.17578125
'163,'Header 152,"'Programming and Data Structures, Release 0.3",'2483,'70.41015625
'163,'Text 1704,"'The program proceeds to apply delete to the address of the dynamic C object, which causes its destructor to run. The body of ~C() runs first, and then the members are destroyed in reverse order:",'2484,'98.48632813
'163,'Text 1705,"'C dtor: (*cptr) M dtor: (*cptr) m2 M dtor: (*cptr) m1",'2485,'72.26562500
'163,'Text 1706,"'The string cstr is also destroyed, since it is a class-type object, and it is destroyed after m1. However, the string destructor doesn't print anything out, SO we do not see it in the output.",'2486,'96.77734375
'163,'Text 1707,"'The order in which the bodies of the destructors are run is the reverse of the constructors - we get the same ""socks- and-shoes"" ordering that we saw with base-class and derived-class constructors and destructors.",'2487,'95.89843750
'163,'Text 1708,"'When execution reaches the end of main(), both c1 and c2 go out of scope, SO their associated objects are destroyed in reverse order of construction. Thus, c2 dies first, followed by c1:",'2488,'96.53320313
'163,'Text 1709,"'C dtor: c2 M dtor: c2.m2 M dtor: c2.m1 C dtor: c1 M dtor: c1.m2 M dtor: c1.m1",'2489,'87.59765625
'163,'Section header 121,"'24.7 Dynamic-Memory Errors",'2490,'91.74804688
'163,'Text 1710,"'The compiler manages objects with static and automatic storage duration, and the management of subobjects is di- rectly tied to the objects that contain them. Dynamic objects, on the other hand, must be explicitly managed by the programmer. Improper management can result in many kinds of errors that are unique to dynamic memory.",'2491,'98.04687500
'163,'Text 1711,"'The most common error with dynamic memory is a memory leak, where a program is no longer in need of a dynamic object but has failed to delete it. The usual cause of a memory leak is orphaned memory, when we lose track of a dynamic object, inevitably resulting in a leak. The following is an example:",'2492,'97.11914063
'163,'Section header 122,"'void func1() {",'2493,'44.94628906
'163,'Text 1712,"'double *ptr = new double(3.0) } int main() { func1(); }",'2494,'72.16796875
'163,'Text 1713,"'When func1() is called, it allocates a dynamic object and stores its address in the local variable ptr. When func1() returns, its activation record is destroyed and ptr dies. Thus, the program no longer knows the address of the dynamic object that func1 () created - the object has been orphaned, and there is no way to get to it to delete it. Thus, the corresponding memory is leaked.",'2495,'96.38671875
'163,'Text 1714,"'The solution is to apply delete to the address before we lose track of it:",'2496,'83.69140625
'163,'Section header 123,"'void func1() {",'2497,'34.96093750
'163,'Text 1715,"'double *ptr = new double(3.0) delete ptr; }",'2498,'87.10937500
'163,'Text 1716,"'(continues on next page)",'2499,'83.88671875
'163,'Footer 112,"'24.7. Dynamic-Memory Errors",'2500,'58.15429688
'163,'Page number 160,"'158",'2501,'80.76171875
'164,'Header 153,"'Programming and Data Structures, Release 0.3",'2502,'55.66406250
'164,'Text 1717,"'(continued from previous page)",'2503,'85.25390625
'164,'Text 1718,"'int main() { func1() }",'2504,'66.25976563
'164,'Text 1719,"'Memory leaks result in a program using more memory than it needs. This is problematic on systems that run more than one program at once, which is the case for most machines - it reduces the amount of physical memory available to the other programs, potentially slowing them down. It is our responsibility as programmers to write well-behaved programs that avoid memory leaks.",'2505,'98.24218750
'164,'Text 1720,"'Another memory error is a double free, also called a double delete, where a program deletes the same object more than once:",'2506,'96.19140625
'164,'Text 1721,"'void func2() { int X = 0; int *ptr1 = new int(1); int *ptr2 = new int(2) ptr2 = ptr1; delete ptr1; delete ptr2; }",'2507,'62.79296875
'164,'Text 1722,"'Here, the second dynamic int is orphaned by the assignment ptr2 = ptr1. The program then applies delete to the same address twice; this is a double free, which results in undefined behavior.",'2508,'97.02148438
'164,'Text 1723,"'Another category of errors is a bad delete, which is when a delete operator is applied to the wrong kind of address. This includes applying delete to the address of a non-dynamic object and applying delete[] to anything other than the address of the first element in a dynamic array. The result of a bad delete is undefined behavior.",'2509,'97.65625000
'164,'Text 1724,"'Deleting a dynamic object is not enough to avoid a memory error. If we keep around its address, we have a dangling pointer - a pointer that points to a dead object. If we then dereference the pointer, we get undefined behavior. The following is an example:",'2510,'97.36328125
'164,'Section header 124,"'void func3() {",'2511,'33.42285156
'164,'Text 1725,"'int *ptr = new int (42) cout << *ptr endl; delete ptr; int *ptr2 = new int(3); cout << *ptr endl; // oops delete ptr2; }",'2512,'88.47656250
'164,'Text 1726,"'In this code, we have accidentally dereferenced ptr after applying delete to it. The object it is pointing at is dead, and the memory may have been reused for something else.",'2513,'96.04492188
'164,'Text 1727,"'We can avoid dangling pointers by restricting the scope of a pointer to the region of code where it is expected to be used4. One way to do SO is by moving that code into its own block, as in the following:",'2514,'94.92187500
'164,'Text 1728,"'4 An alternative strategy is to set a pointer to null after applying delete to it. Dereferencing a null pointer still results in undefined behavior, but implementations almost universally detect this, resulting in a segmentation fault or a bad access. However, there are two downsides to this strategy. First, it complicates the code, making it harder to read and maintain. Second, deleting a null pointer is valid in C++ - it has no effect. This means that if we set a pointer to null and then subsequently delete it a second time, we will not encounter an error. However, this may hide a logic bug - perhaps we expected the pointer to still be alive even though it was deleted earlier, in which case we would prefer a visible error from a double delete rather the code passing our test cases. For these reasons, it is better to rely on scoping to detect dangling pointers at compile time rather than relying on runtime checks.",'2515,'93.84765625
'164,'Footer 113,"'24.7. Dynamic-Memory Errors",'2516,'81.39648438
'164,'Page number 161,"'159",'2517,'78.80859375
'165,'Header 154,"'Programming and Data Structures, Release 0.3",'2518,'44.94628906
'165,'Text 1729,"'void func3 () { { int *ptr = new int(42); cout << *ptr << endl; delete ptr; } int *ptr2 = new int(3) cout << *ptr << endl // oops delete ptr2; }",'2519,'67.33398438
'165,'Text 1730,"'Now ptr is no longer in scope when we mistakenly access it, and the compiler will detect this and give us a meaningful error.",'2520,'94.38476563
'165,'Section header 125,"'24.8 Uses for Dynamic Memory",'2521,'87.30468750
'165,'Text 1731,"'Dynamic memory adds another use for indirection through a pointer or reference. Since a dynamic object is not directly associated with a variable, we are forced to interact with the object indirectly.",'2522,'94.97070313
'165,'Text 1732,"'We have already seen two uses for dynamic memory:",'2523,'89.79492188
'165,'List 53,"",'2524,'92.87109375
'165,'Text 1733 - Part of List 53,"'The factory pattern, where a factory function creates objects of specific derived types based on runtime informa- tion.",'2525,'97.70507813
'165,'Text 1734 - Part of List 53,"'Dynamic arrays, where the size can be determined at runtime.",'2526,'97.16796875
'165,'Text 1735,"'The factory pattern is an example of decoupling the lifetime of an object from a particular scope. Next time, we will make use of dynamic arrays to build a container ADT without a fixed maximum capacity; we will do SO by decoupling the storage for the container's elements from that of the container itself. However, we will see that this results in nontrivial memory-management issues, and we will learn how to address them.",'2527,'96.77734375
'165,'Footer 114,"'24.8. Uses for Dynamic Memory",'2528,'79.63867188
'165,'Page number 162,"'160",'2529,'90.13671875
'166,'Header 155,"'CHAPTER",'2530,'47.85156250
'166,'Header 156,"'TWENTYFIVE",'2531,'49.21875000
'166,'Title 40,"'MANAGING DYNAMIC MEMORY",'2532,'86.66992188
'166,'Text 1736,"'We saw previously that the compiler and runtime automatically manage the lifetime of objects associated with static, local, and member variables. For instance, if we declare an array as a local variable, it will die when the variable goes out of scope:",'2533,'98.82812500
'166,'Text 1737,"'int main() { int arr [10]; for (int i0;i<10;i) { arr[i] = i; } } // arr dies here",'2534,'76.41601563
'166,'Text 1738,"'An automatically managed array must have a size that is known at compile time, SO that the compiler can properly manage it. The compiler does not automatically manage dynamic arrays:",'2535,'96.04492188
'166,'Section header 126,"'int main() {",'2536,'34.03320313
'166,'Text 1739,"'int size; cout << ""Enter a size:"" << endl; cin >> size; int *darr = new int[size]; for (int i = 0; i < size; ++i) { darr[i] = i; } } // the pointer darr dies here, but not the memory it is pointing to",'2537,'60.69335938
'166,'Text 1740,"'The code above contains a memory leak, since we did not delete the memory we dynamically allocated.",'2538,'95.21484375
'166,'Text 1741,"'We also have seen that when a class-type object dies, its destructor is run:",'2539,'88.91601563
'166,'Text 1742,"'class C public: ~C() cout << ""C dtor"" << endl; } };",'2540,'96.24023438
'166,'Text 1743,"'(continues on next page)",'2541,'78.90625000
'166,'Page number 163,"'161",'2542,'83.69140625
'167,'Header 157,"'Programming and Data Structures, Release 0.3",'2543,'72.16796875
'167,'Text 1744,"'(continued from previous page)",'2544,'40.82031250
'167,'Text 1745,"'int main() { C C; cout << ""end of c's scope"" << endl; } // C dies here",'2545,'77.44140625
'167,'Text 1746,"'This prints out the following when run:",'2546,'94.18945313
'167,'Text 1747,"'end of c's scope C dtor",'2547,'92.87109375
'167,'Text 1748,"'Here, the compiler automatically manages the lifetime of the object associated with the local variable C, and since it is of class type, its destructor is run when the object dies.",'2548,'95.21484375
'167,'Section header 127,"'25.1 RAII",'2549,'82.37304688
'167,'Text 1749,"'We can leverage automatic memory management and destructors by wrapping up the management of a dynamic re- source in a class. In particular, we will arrange for the constructor of a class-type object to allocate a resource and for the destructor to release that resource. Doing SO ties the management of the resource to the lifetime of the class-type object. This strategy is called resource acquisition is initialization (RAII), and it is also known as scope-based resource management.",'2550,'97.60742188
'167,'Text 1750,"'The following is a class that manages a dynamic array:",'2551,'87.30468750
'167,'Table 59,"",'2552,'26.29394531
'167,'Footer 115,"'25.1. RAII",'2553,'68.70117188
'167,'Page number 164,"'162",'2554,'80.61523438
'168,'Title 41,"'Programming and Data Structures, Release 0.3",'2555,'45.99609375
'168,'Text 1751,"'When a Dynami IntArray object is created, it allocates a dynamic array of the specified size. The subscript operator is overloaded to index into the array. There are two overloads, one that returns a modifiable element by reference if applied to a non-const DynamicIntArray, and another that returns a non-modifiable element by reference to const when applied to a const DynamicIntArray The class also provides a size () member function to query the size of the array. When the DynamicIntArray object dies, it deletes the dynamic array that it had allocated, SO that memory does not leak.",'2556,'99.41406250
'168,'Text 1752,"'The following is an example that uses Dynami cIntArray:",'2557,'89.01367188
'168,'Text 1753,"'int main() { int size; cout << ""Enter a size:"" << endl; cin >> size; DynamicIntArray darr(size); // internally allocates an array for (int i =0;i<darr.size(); ++i) { // size() member function darr[i] = i; // overloaded subscript } // darr dies here, causing its destructor to run and free the // array it allocated",'2558,'76.95312500
'168,'Text 1754,"'}",'2559,'92.38770294
'168,'Text 1755,"'When the object associated with darr is created, it allocates a dynamic array, storing the address of the first element in its elements member.",'2560,'91.50390625
'168,'Figure 56,"",'2561,'91.89453125
'168,'Text 1756,"'Figure 25.1: A Dynami cIntArray object manages an array in dynamic memory.",'2562,'97.21679688
'168,'Text 1757,"'When darr goes out of scope, its associated object dies, and the DynamicIntArray destructor is run. The destructor deletes the array, cleaning up the resource that it was using.",'2563,'97.99804688
'168,'Text 1758,"'Thus, with the RAII pattern, we have leveraged automatic memory management and a class-type object to successfully manage a dynamic array.",'2564,'97.31445313
'168,'Footer 116,"'25.1. RAII",'2565,'86.42578125
'168,'Page number 165,"'163",'2566,'82.66601563
'169,'Header 158,"'Programming and Data Structures, Release 0.3",'2567,'66.45507813
'169,'Text 1759,"'~DynamicIntArray()",'2568,'38.72070313
'169,'Figure 57,"",'2569,'96.53320313
'169,'Text 1760,"'Figure 25.2: The destructor for Dynami IntArray deletes the array that it is managing.",'2570,'92.23632813
'169,'Section header 128,"'25.2 Growable Set",'2571,'85.74218750
'169,'Text 1761,"'Let's use a similar strategy to write a new version of UnsortedSet without a fixed-capacity limitation. We allow the set to have an arbitrary number of elements by decoupling the storage of the elements from that of the set object, using dynamic memory for the former.",'2572,'95.84960938
'169,'Text 1762,"'We modify the data representation SO that the member variable elements is now a pointer to the first element of a dynamic array. We also add a capacity member variable to keep track of the size of that dynamic array. The resulting class definition for UnsortedSet is as follows:",'2573,'94.92187500
'169,'Table 60,"",'2574,'33.49609375
'169,'Text 1763,"'(continues on next page)",'2575,'43.96972656
'169,'Page number 166,"'164",'2576,'87.20703125
'169,'Footer 117,"'25.2. Growable Set",'2577,'87.06054688
'170,'Header 159,"'Programming and Data Structures, Release 0.3",'2578,'56.78710938
'170,'Text 1764,"'(continued from previous page)",'2579,'71.92382813
'170,'Text 1765,"'// Initial size of a set. static const int INITIAL_SIZE = 5;",'2580,'57.95898438
'170,'Figure 58,"",'2581,'29.05273438
'170,'Text 1766,"'T *elements; int capacity; int num_elements;",'2582,'80.85937500
'170,'List 54,"",'2583,'80.56640625
'170,'Text 1767 - Part of List 54,"'// INVARIANTS:",'2584,'85.98632813
'170,'Text 1768 - Part of List 54,"'// elements points to the sole dynamic array associated with this set",'2585,'96.97265625
'170,'Text 1769 - Part of List 54,"'// capacity is the size of the array that elements points to",'2586,'97.11914063
'170,'Text 1770 - Part of List 54,"'// O <= num_elements && num_elements <= capacity",'2587,'95.94726563
'170,'Text 1771 - Part of List 54,"'// the first num_elements items in elements are the items in the set",'2588,'95.99609375
'170,'Text 1772 - Part of List 54,"'// the first num_elements items in elements contain no duplicates };",'2589,'92.23632813
'170,'Text 1773,"'We have added two representation invariants:",'2590,'89.64843750
'170,'List 55,"",'2591,'89.89257813
'170,'Text 1774 - Part of List 55,"'elements points to the start of the sole dynamic array associated with the set, and each set has its own dynamic array",'2592,'95.60546875
'170,'Text 1775 - Part of List 55,"'capacity is the size of dynamic array that elements points to",'2593,'95.99609375
'170,'Text 1776,"'We have also added two private members:",'2594,'90.57617188
'170,'List 56,"",'2595,'87.35351563
'170,'Text 1777 - Part of List 56,"'grow () doubles the capacity of the set",'2596,'95.16601563
'170,'Text 1778 - Part of List 56,"'INITIAL SIZE is a constant whose value is the initial size of a set",'2597,'97.21679688
'170,'Text 1779,"'The following is the new constructor for UnsortedSet:",'2598,'91.99218750
'170,'Figure 59,"",'2599,'27.19726563
'170,'Text 1780,"'template <typename T> UnsortedSet<T> : : UnsortedSet() : elements (new T[INITIAL_SIZE]), capacity (INITIAL_SIZE), num_elements (0) {}",'2600,'80.12695313
'170,'Text 1781,"'The constructor allocates a dynamic array of size INITIAL_SIZE and stores the address of its first element in elements. We satisfy the remaining representation invariants by setting capacity to INITIAL SIZE and num_elements to 0.",'2601,'93.31054688
'170,'Text 1782,"'We modify insert () SO that if the set is out of space, it calls the grow () member function to increase the available capacity:",'2602,'90.96679688
'170,'Section header 129,"'template <typename T>",'2603,'27.07519531
'170,'Text 1783,"'void UnsortedSet<T> :insert (const T &value) { if (contains(value)) { return; } if (num_elements == capacity) { grow(); // double the capacity; } elements [num_elements] = value; ++num_elements; }",'2604,'94.87304688
'170,'Text 1784,"'The grow() member function doubles the capacity of the set. In C++, an array has a fixed size, even if it is dynamic, SO we cannot change the size of the existing elements array. Instead, we allocate a new dynamic array, copy over the elements, and discard the old array, as shown in Figure 25.3.",'2605,'90.96679688
'170,'Footer 118,"'25.2. Growable Set",'2606,'66.25976563
'170,'Page number 167,"'165",'2607,'80.41992188
'171,'Header 160,"'Programming and Data Structures, Release 0.3",'2608,'66.69921875
'171,'Figure 60,"",'2609,'96.19140625
'171,'Text 1785,"'Stack",'2610,'79.73632813
'171,'Text 1786,"'Heap",'2611,'61.66992188
'171,'Text 1787,"'Figure 25.3: The grow() operation creates a new, larger array, copies the elements to the new array, and deletes the old array.",'2612,'97.70507813
'171,'Text 1788,"'The following implements this:",'2613,'89.50195313
'171,'Text 1789,"'template <typename T> void UnsortedSet<T: grow() { T *new_arr = new T[2 * capacity]; // allocate a new array that is twice as big for (int i = 0; i num_elements; ++i) { // copy the elements to the new array new_arr[i]=elements[i]; } capacity *=2; // update capacity delete[] elements; // free the old array elements = new_arr; // set elements to point to first element of the new array }",'2614,'82.08007813
'171,'Text 1790,"'The function allocates a new array and deletes the old one, satisfying the invariant that there is exactly one dynamic array associated with the set. It sets elements to point to that array and updates capacity to be the array's size. Copying the elements to the new array satisfies the representation invariant that the first num_elements items in elements are the ones in the set.",'2615,'97.46093750
'171,'Text 1791,"'The grow() operation demonstrates the power of indirection. By decoupling the storage for the elements from that of the UnsortedSet object, we have also decoupled their lifetimes. Thus, if the old storage no longer meets our needs, we can replace it with different storage that does, killing the old array and creating a new one. Compare this to storing the array directly within the memory for the set, which both limits the array to be of a fixed size and ties its lifetime to that of the set.",'2616,'97.60742188
'171,'Text 1792,"'Since UnsortedSet now manages the resource of dynamic memory, we need to write a destructor that frees the resource when the UnsortedSet object dies.",'2617,'95.89843750
'171,'Text 1793,"'Before we proceed to write the destructor, a clarification is in order. The destructor does not cause the object to die. The object dies when its lifetime ends:",'2618,'95.94726563
'171,'List 57,"",'2619,'95.80078125
'171,'Text 1794 - Part of List 57,"'if it is associated with a local variable, when the variable goes out of scope",'2620,'98.04687500
'171,'Text 1795 - Part of List 57,"'if it is associated with a static variable, when the program ends",'2621,'97.70507813
'171,'Text 1796 - Part of List 57,"'if it is a member of a class-type object, when the latter object dies",'2622,'97.60742188
'171,'Text 1797 - Part of List 57,"'if it is an element of an array, when the array dies",'2623,'97.16796875
'171,'Text 1798 - Part of List 57,"'if it is a dynamic object, when delete is applied to its address",'2624,'96.77734375
'171,'Text 1799,"'The destructor merely runs when the object dies it gives the object a chance to put its affairs in order while it is on its deathbed. If the object is managing dynamic memory, it needs to release that memory.",'2625,'95.94726563
'171,'Footer 119,"'25.2. Growable Set",'2626,'81.25000000
'171,'Page number 168,"'166",'2627,'76.41601563
'172,'Header 161,"'Programming and Data Structures, Release 0.3",'2628,'55.37109375
'172,'Title 42,"'template <typename T>",'2629,'29.78515625
'172,'Text 1800,"'UnsortedSet<T> : ~UnsortedSet { delete[ elements; }",'2630,'82.91015625
'172,'Text 1801,"'The representation invariant that there is exactly one dynamic array associated with each UnsortedSet ensures that after the destructor runs, there is no longer a live array associated with the dying set.",'2631,'97.31445313
'172,'Text 1802,"'With the destructor, we have ensured that in simple cases, UnsortedSet properly manages memory. However, there is one case that we missed: copying a set. Consider the following code:",'2632,'96.58203125
'172,'Key value 36,"",'2633,'54.68750000
'172,'Text 1803,"'The code creates a set s1 and adds five items to the set, filling it to capacity. It then creates s2 as a copy of s1; by default, this does a member-by-member copy, SO that both s1.elements and s2. elements point to the same dynamic array. We then add an item into s2, causing it to grow and delete its old array. This is the same array that s1. elements is pointing to, SO that when we proceed to print out s1, it accesses a dead object. The result is undefined behavior.",'2634,'96.28906250
'172,'Text 1804,"'Had we not caused a grow, there would have been a double delete when s2 and s1 die, since they would both delete the same array. This still results in undefined behavior. The fundamental problem is that the copy violates the representation invariant that each set has its own array. We will see how to fix this next time.",'2635,'96.82617188
'172,'Footer 120,"'25.2. Growable Set",'2636,'45.80078125
'172,'Page number 169,"'167",'2637,'85.93750000
'173,'Text 1805,"'CHAPTER",'2638,'40.20996094
'173,'Text 1806,"'TWENTYSIX",'2639,'46.19140625
'173,'Title 43,"'THE BIG THREE",'2640,'47.85156250
'173,'Text 1807,"'We saw last time that copying an UnsortedSet ultimately results in undefined behavior. Before we fix the issue, we need to understand how C++ copies class-type objects and what mechanisms it provides to control the behavior of a copy.",'2641,'98.58398438
'173,'Text 1808,"'By default, a copy just copies over the members one by one, as we saw when we first discussed class-type objects:",'2642,'93.50585938
'173,'Text 1809,"'Person elise = { ""Elise"", 22, true }; Person tali = elise;",'2643,'91.16210938
'173,'Text 1810,"'The result is shown in Figure 26.1.",'2644,'80.66406250
'173,'Table 61,"",'2645,'58.30078125
'173,'Text 1811,"'Stack",'2646,'61.13281250
'173,'Text 1812,"'Figure 26.1: The default copy behavior for a class-type object is to copy each of its members.",'2647,'98.14453125
'173,'Text 1813,"'The code above is an example of making a copy when initializing a new object. There are several forms of syntax we can use for initialization as a copy:",'2648,'97.80273438
'173,'Text 1814,"'Person tali = elise; Person tali (elise) ; Person tali{elise}; Person tali = {elise};",'2649,'95.11718750
'173,'Text 1815,"'Initialization as a copy also occurs when we pass an object by value:",'2650,'95.11718750
'173,'Page number 170,"'168",'2651,'76.26953125
'174,'Title 44,"'Programming and Data Structures, Release 0.3",'2652,'50.78125000
'174,'Section header 130,"'void func (Person p);",'2653,'55.90820313
'174,'Text 1816,"'int main( () { Person elise = { ""Elise"", 22, true }; func (elise): }",'2654,'87.25585938
'174,'Text 1817,"'The parameter p is associated with an object that lives in the activation record for func() and the object is initialized when the function is called. It is initialized as a copy of the argument value elise.",'2655,'95.36132813
'174,'Text 1818,"'Just like we can pass an object by value, we can also return an object by value, which generally makes a copy:",'2656,'88.72070313
'174,'Text 1819,"'Person func2() { Person elise = { ""Elise"", 22, true }; return elise; } int main() { Person tali = func2 ( () }",'2657,'45.33691406
'174,'Section header 131,"'26.1 Copy Constructor",'2658,'89.50195313
'174,'Text 1820,"'We also previously discussed that a constructor is always called when a class-type object is created (except for C-style ADTs when the members are initialized directly, like elise above). Copy initialization of a class-type object also invokes a constructor, specifically the copy constructor for the class. The following is an example of explicitly defining a copy constructor:",'2659,'97.94921875
'174,'Text 1821,"'class Example { public: Example(int x_in, double y_in) : x(x_in), y(y_in) {} Example (const Example &other) : (other.x), y(other.y) { cout << ""Example copy ctor: << x << "", "" y endl; } int get_x() const { return x; } double get_y () const { return y; } private: int x ; double y; };",'2660,'29.95605469
'174,'Text 1822,"'The second constructor above is the copy constructor, and it takes a reference to an existing object as the parameter.",'2661,'83.54492188
'174,'Footer 121,"'26.1. Copy Constructor",'2662,'64.69726563
'174,'Page number 171,"'169",'2663,'80.27343750
'175,'Header 162,"'Programming and Data Structures, Release 0.3",'2664,'69.92187500
'175,'Text 1823,"'The parameter must be passed by reference - otherwise, a copy will be done to initialize the parameter, which itself will invoke the copy constructor, which will call the copy constructor to initialize its parameter, and SO on.",'2665,'98.77929688
'175,'Text 1824,"'We have instrumented the copy constructor to print a message when it is called. Thus, the code",'2666,'94.43359375
'175,'Text 1825,"'int main() { Example e1(2, -1.3) ; Example e2 = e1; }",'2667,'82.03125000
'175,'Text 1826,"'will print the following when run:",'2668,'93.99414063
'175,'Text 1827,"'Example copy ctor: 2, -1.3",'2669,'92.96875000
'175,'Text 1828,"'The program invokes the copy constructor to initialize e2 from e1.",'2670,'94.72656250
'175,'Text 1829,"'The C++ compiler provides an implicit copy constructor if a user-defined one is not present. The implicit copy con- structor just does a member-by-member copy, SO in the case of Example, it acts like the following:",'2671,'96.67968750
'175,'Text 1830,"'Example(const Example &other) : x(other.x), y(other.y) {}",'2672,'91.06445313
'175,'Section header 132,"'26.2 Assignment Operator",'2673,'86.52343750
'175,'Text 1831,"'Assignment is another situation where an object is copied; unlike initialization, however, assignment copies into an existing object rather than a new one. The following is an example:",'2674,'97.16796875
'175,'Text 1832,"'int main() { Example e1(2, -1.3); Example e2(3, 4.1); e2 = e1; }",'2675,'92.04101563
'175,'Text 1833,"'An assignment expression consists of a left-hand-side object, the = operator, and a right-hand-side object or value. The expression evaluates the right-hand side, copies it into the left-hand-side object, and then evaluates back to the left-hand-side object. We can then use the result in a larger expression:",'2676,'96.38671875
'175,'Text 1834,"'cout << (e2 = e1).get_x() << endl; // prints 2",'2677,'87.59387970
'175,'Text 1835,"'Like most operators, the assignment operator can be overloaded; the overload must be a member function of the type of the left-hand side.",'2678,'96.33789063
'175,'Text 1836,"'class Example { public: Example & operator=(const Example &rhs) };",'2679,'92.72460938
'175,'Text 1837,"'The function takes in an Example by reference to const, corresponding to the right-hand operand of the assignment. 1 The return value will be the left-hand-side object itself, and it needs to be returned by reference rather than by value (the latter would make a copy rather than returning the object itself). Thus, the return type is Example &.",'2680,'94.28710938
'175,'Text 1838,"'The following is a definition of the overloaded assignment operator that just does a member-by-member copy:",'2681,'66.35742188
'175,'Text 1839,"'1 In C++, a reference to const can bind to a temporary, allowing the right-hand operand of the assignment to be a value rather than an object.",'2682,'81.34765625
'175,'Footer 122,"'26.2. Assignment Operator",'2683,'66.35742188
'175,'Page number 172,"'170",'2684,'84.32617188
'176,'Header 163,"'Programming and Data Structures, Release 0.3",'2685,'49.70703125
'176,'Text 1840,"'Example & Example: operator=( (const Example &rhs) { X = rhs.x; y = rhs.y; return *this; }",'2686,'92.04101563
'176,'Text 1841,"'The two members are individually copied from the right-hand side. The left-hand-side object must be returned; we need to dereference the this pointer to get to the object to which it is pointing.",'2687,'96.19140625
'176,'Text 1842,"'Like the copy constructor, the compiler provides an implicit definition of the assignment operator if a user-defined one is not present. Like the implicitly defined copy constructor, the implicit assignment operator performs a member-by- member copy.",'2688,'95.36132813
'176,'Section header 133,"'26.3 Shallow and Deep Copies",'2689,'86.62109375
'176,'Text 1843,"'For most class types, a member-by-member copy is sufficient, and there is no need to write a custom copy constructor or assignment operator. However, for a type that manages a dynamic resource, a member-by-member copy generally results in incorrect sharing of a resource. For example, consider the following code that copies an UnsortedSet:",'2690,'96.77734375
'176,'Key value 37,"",'2691,'25.87890625
'176,'Text 1844,"'The initialization of s2 calls the implicit copy constructor, which does a member-by-member copy, as if it were written as follows:",'2692,'96.58203125
'176,'Text 1845,"'template <typename T> UnsortedSet<T> : UnsortedSet (const UnsortedSet &other) : elements(other.elements) capacity(other.capacity), num_elements(other.num_elements) {}",'2693,'91.50390625
'176,'Text 1846,"'The result is that s1.elements and s2. elements point to the same array, as depicted by Figure 26.2.",'2694,'90.33203125
'176,'Text 1847,"'Inserting 5 into s2 causes a grow operation, which creates a new array and deletes the old one. The result is shown in Figure 26.3.",'2695,'95.06835938
'176,'Text 1848,"'Then printing out s1 accesses the old, deleted array, resulting in undefined behavior.",'2696,'90.13671875
'176,'Text 1849,"'The fundamental problem is that the implicitly defined member-by-member copy is a shallow copy: it copies the pointer to the array of elements, rather than following it and copying the array as a whole. This violates the representation invariant that each set has its own array. Instead, we need a deep copy, where we make a copy of the underlying",'2697,'96.87500000
'176,'Footer 123,"'26.3. Shallow and Deep Copies",'2698,'83.64257813
'176,'Page number 173,"'171",'2699,'85.20507813
'177,'Header 164,"'Programming and Data Structures, Release 0.3",'2700,'67.82226563
'177,'Figure 61,"",'2701,'81.00585938
'177,'Text 1850,"'Stack",'2702,'37.37792969
'177,'Text 1851,"'Heap",'2703,'48.53515625
'177,'Text 1852,"'Figure 26.2: The implicit copy constructor copies each member one by one, resulting in a shallow copy.",'2704,'91.40625000
'177,'Figure 62,"",'2705,'84.66796875
'177,'Text 1853,"'Stack",'2706,'99.99262238
'177,'Text 1854,"'Figure 26.3: A subsequent grow() results in one of the sets using a dead array.",'2707,'82.66601563
'177,'Text 1855,"'Heap",'2708,'28.61328125
'177,'Footer 124,"'26.3. Shallow and Deep Copies",'2709,'85.30273438
'177,'Page number 174,"'172",'2710,'87.25585938
'178,'Header 165,"'Programming and Data Structures, Release 0.3",'2711,'60.20507813
'178,'Text 1856,"'resource rather than having the two sets share the same resource. To obtain a deep copy, we need to provide a custom implementation of the copy constructor:",'2712,'99.12109375
'178,'Text 1857,"'template <typename T> class UnsortedSet { public: UnsortedSet (const UnsortedSet &other); }; template <typename T> UnsortedSet<T> UnsortedSet (const UnsortedSet &other) : elements (new T[other.capacity]), // create new array capacity (other. capacity), // shallow copy non-resources num_elements(other.num_elements) { for (int i = 0; i < num_elements; ++i) { // copy over the elements elements[i] other.elements[i]; } }",'2713,'75.19531250
'178,'Text 1858,"'Rather than copying the elements pointer, we initialize the new set's member to point to the start of a dynamic array of the same capacity as other's. The members that don't represent resources are just copied directly (capacity and num_elements). The body of the constructor copies each element from the old set to the new one. The result is that each set has its own, independent copy of the elements, as shown in Figure 26.4.",'2714,'96.09375000
'178,'Figure 63,"",'2715,'92.28515625
'178,'Text 1859,"'Stack",'2716,'83.44726563
'178,'Text 1860,"'Heap",'2717,'87.15820313
'178,'Text 1861,"'Figure 26.4: The custom copy constructor for UnorderedSet performs a deep copy, providing the new set with its own array.",'2718,'97.80273438
'178,'Text 1862,"'The custom copy constructor provides a deep copy in the case of initializing a new set as a copy. We need a deep copy in assignment as well:",'2719,'97.60742188
'178,'Text 1863,"'s2 = s1;",'2720,'93.11523438
'178,'Text 1864,"'Thus, we need a custom assignment operator in addition to a custom copy constructor. The following is a first attempt at defining one:",'2721,'97.21679688
'178,'Footer 125,"'26.3. Shallow and Deep Copies",'2722,'82.86132813
'178,'Page number 175,"'173",'2723,'85.05859375
'179,'Header 166,"'Programming and Data Structures, Release 0.3",'2724,'49.60937500
'179,'Text 1865,"'template <typename T> class UnsortedSet { public: UnsortedSet & operator=(const UnsortedSet &rhs); }; template <typename T> UnsortedSet<T> &UnsortedSet<T>::operator=(const UnsortedSet &rhs) { delete elements; // delete old array elements = new T[rhs.capacity]; // make new array of the required size capacity = rhs. capacity; // shallow copy non-resources num_elements = rhs.num_elements; for (int i = 0; i < num_elements; ++i) { // copy over the elements elements[i] = rhs.elements[i]; } return *this; // return LHS object }",'2725,'29.10156250
'179,'Text 1866,"'The function first deletes the old array before creating a new one. It may be the case that the size of the rhs set is larger than the capacity of the set receiving the copy, in which case creating a new array is necessary. The function then makes a shallow copy of the non-resources, followed by copying over each of the elements. Finally, it returns the left-hand-side object.",'2726,'93.79882813
'179,'Text 1867,"'While this assignment operator works in most cases, it fails in the case of self assignment. An expression such as s2 = s2 will delete s2. elements before proceeding to access the elements in the subsequent loop. Instead, the assignment should have no effect when both operands are the same object, SO we need to check for this case before doing any work. We do SO as follows:",'2727,'91.06445313
'179,'Text 1868,"'template <typename T> UnsortedSet<T> & UnsortedSet<T>::operator=(const UnsortedSet &rhs) { if (this == &rhs) { // self-assignment check return *this; } delete elements; // delete old array elements = new T[rhs.capacity]; // make new array of the required size capacity = rhs.capacity; // shallow copy non-resources num_elements = rhs.num_elements; for (int i = O; i < num_elements; ++i) { // copy over the elements elements[i] = rhs.elements[i]; } return *this; // return LHS object }",'2728,'47.55859375
'179,'Text 1869,"'The this pointer points to the left-hand-side operand, while the parameter rhs is an alias for the right-hand-side operand. We need to obtain the address of rhs to compare to the address stored in the this pointer. If the two addresses are the same, then the two operands are the same object, SO we immediately return the left-hand-side object.",'2729,'93.65234375
'179,'Footer 126,"'26.3. Shallow and Deep Copies",'2730,'75.78125000
'179,'Page number 176,"'174",'2731,'87.93945313
'180,'Header 167,"'Programming and Data Structures, Release 0.3",'2732,'64.35546875
'180,'Text 1870,"'(We cannot return rhs because it is declared as a reference to const, while the return type is not.)",'2733,'92.72460938
'180,'Section header 134,"'26.4 The Law of the Big Three",'2734,'87.40234375
'180,'Text 1871,"'We have seen that the implicitly defined copy constructor and assignment operator both do a shallow copy, and that this behavior is incorrect for classes that manage a dynamic resource. Instead, we need a deep copy, which requires us to write our own custom versions of the two functions.",'2735,'92.38281250
'180,'Text 1872,"'We also saw last time that resource management requires us to write our own custom destructor as well. It is not a coincidence that we needed to write custom versions of all three of the destructor, copy constructor, and assignment operator. The Law of the Big Three (also know as the Rule of Three) is a rule of thumb in C++ that if a custom version of any of the destructor, copy constructor, or assignment operator is required, almost certainly all three need to be custom. We refer to these three members as the big three.",'2736,'93.94531250
'180,'Text 1873,"'By default, C++ provides implicit definitions of each of the big three:",'2737,'87.59765625
'180,'List 58,"",'2738,'87.79296875
'180,'Text 1874 - Part of List 58,"'The implicitly defined destructor does no special cleanup; it is equivalent to a destructor with an empty body. Like other destructors, it does implicitly destroy the members as well as the base class, if there is one.",'2739,'97.90039063
'180,'Text 1875 - Part of List 58,"'The implicitly defined copy constructor does a member-by-member shallow copy.",'2740,'97.85156250
'180,'Text 1876 - Part of List 58,"'The implicitly defined assignment operator does a member-by-member shallow copy.",'2741,'96.58203125
'180,'Text 1877,"'When a class manages a resource, however, the programmer must provide custom versions of the big three:",'2742,'94.77539063
'180,'List 59,"",'2743,'78.61328125
'180,'Text 1878 - Part of List 59,"'The destructor should free the resources.",'2744,'95.80078125
'180,'Text 1879 - Part of List 59,"'The copy constructor should make a deep copy of the resources and shallow copy the non-resources.",'2745,'96.82617188
'180,'Text 1880 - Part of List 59,"'The assignment operator should:",'2746,'95.41015625
'180,'Text 1881 - Part of List 59,"'- Do a self-assignment check.",'2747,'95.21484375
'180,'Text 1882 - Part of List 59,"'- Free the old resources.",'2748,'95.70312500
'180,'Text 1883 - Part of List 59,"'- Make a deep copy of the right-hand-side object's resources.",'2749,'95.89843750
'180,'Text 1884 - Part of List 59,"'- Shallow copy the non-resources from the right-hand-side object.",'2750,'96.24023438
'180,'Text 1885 - Part of List 59,"'- Return the left-hand-side object with *this.",'2751,'96.43554688
'180,'Section header 135,"'26.5 Example: Calls to the Big Three",'2752,'87.50000000
'180,'Text 1886,"'To better understand when the big three are invoked, we instrument the big three for the following class to print a message:",'2753,'96.92382813
'180,'Text 1887,"'class Foo { public: Foo(const string &str_in) str(str_in) { cout << ""Foo ctor str << endl; } Foo (const Foo &other) : str(other.str) { cout ""Foo copy ctor << str << endl; } Foo & operator=(const Foo &rhs) {",'2754,'86.81640625
'180,'Text 1888,"'(continues on next page)",'2755,'75.68359375
'180,'Footer 127,"'26.4. The Law of the Big Three",'2756,'71.77734375
'180,'Page number 177,"'175",'2757,'85.64453125
'181,'Header 168,"'Programming and Data Structures, Release 0.3",'2758,'48.14453125
'181,'Text 1889,"'(continued from previous page)",'2759,'76.26953125
'181,'Text 1890,"'cout << ""Foo assign "" << rhs. str << to "" << str << endl ; str = rhs.str; return *this; } ~Foo () cout ""Foo dtor "" << str << endl; } private: string str; };",'2760,'62.06054688
'181,'Text 1891,"'The Foo class has a str member variable that we will use to distinguish between different Foo objects. The construc- tors, assignment operator, and destructor all print the value of str.",'2761,'94.62890625
'181,'Text 1892,"'Let us take a look at a small program that uses Foo:",'2762,'70.41015625
'181,'Table 62,"",'2763,'27.46582031
'181,'Text 1893,"'This prints the following when run:",'2764,'65.57617188
'181,'Text 1894,"'Foo ctor apple Foo ctor banana Foo ctor craisin Foo copy ctor banana Foo copy ctor apple Foo dtor apple Foo dtor banana Foo copy ctor craisin Foo assign craisin to be craisin Foo dtor craisin Foo dtor craisin Foo dtor banana Foo dtor apple",'2765,'86.18164063
'181,'Text 1895,"'In main(), the variables a, b, and C are constructed in order, resulting in the Foo ctor outputs. Then func () is called. The first parameter is passed by reference, SO no copy is made. The second parameter is passed by value, SO the parameter object is initialized as a copy of the argument. This invokes the copy constructor, which prints Foo copy ctor banana. Within the body of func (), Z is initialized as a copy of X, resulting in Foo copy ctor apple. When func () returns, the local objects are destructed in reverse order of construction: Z is destructed first, producing Foo",'2766,'96.28906250
'181,'Footer 128,"'26.5. Example: Calls to the Big Three",'2767,'82.37304688
'181,'Page number 178,"'176",'2768,'83.20312500
'182,'Header 169,"'Programming and Data Structures, Release 0.3",'2769,'48.33984375
'182,'Text 1896,"'dtor apple, then y is destructed, printing Foo dtor banana.",'2770,'63.18359375
'182,'Text 1897,"'Continuing in main(), c2 is initialized as a copy of C, invoking the copy constructor and printing Foo copy ctor craisin. In the next line, c2 already exists, SO the expression is an assignment and calls the assignment operator, which prints Foo assign craisin to craisin. At the end of main(), the local objects are destructed in reverse order: c2, then C, then b, and then a. The last four lines of output are the result.",'2771,'95.01953125
'182,'Section header 136,"'26.6 Destructors and Polymorphism",'2772,'79.63867188
'182,'Text 1898,"'We saw previously that applying the delete operator to a pointer follows the pointer and kills the object at the given address. If the object is of class type, its destructor is run. However, a subtle issue arises when the static and dynamic type of the object do not match: does the destructor use static or dynamic binding? Consider the following example:",'2773,'96.58203125
'182,'Table 63,"",'2774,'35.52246094
'182,'Text 1899,"'Running this code results in:",'2775,'68.84765625
'182,'Text 1900,"'$ /a.out Base dtor",'2776,'74.02343750
'182,'Text 1901,"'The destructor is statically bound, SO ~Base is invoked rather than ~Derived(). This is problematic: even though Derived itself is not managing dynamic memory, its member variable i tems is. Since the destructor for Derived was not called, the members introduced by Derived were also not destructed. Running Valgrind on the program illustrates the issue:",'2777,'95.65429688
'182,'Footer 129,"'26.6. Destructors and Polymorphism",'2778,'76.56250000
'182,'Page number 179,"'177",'2779,'78.85742188
'183,'Title 45,"'Programming and Data Structures, Release 0.3",'2780,'45.14160156
'183,'Key value 38,"",'2781,'48.43750000
'183,'Text 1902,"'The error message indicates that the memory allocated by the items vector is never freed.",'2782,'81.83593750
'183,'Text 1903,"'The solution is to use dynamic binding for the destructor instead by declaring it as virtual:",'2783,'78.22265625
'183,'Text 1904,"'class Base public: virtual void add(int x = 0; virtual ~Base () { cout ""Base dtor"" << endl; } }; class Derived : public Base {",'2784,'63.08593750
'183,'Text 1905,"'(continues on next page)",'2785,'72.80273438
'183,'Footer 130,"'26.6. Destructors and Polymorphism",'2786,'95.45898438
'183,'Page number 180,"'178",'2787,'70.55664063
'184,'Header 170,"'Programming and Data Structures, Release 0.3",'2788,'64.94140625
'184,'Text 1906,"'(continued from previous page)",'2789,'60.93750000
'184,'Section header 137,"'public:",'2790,'66.89453125
'184,'Text 1907,"'void add(int x) override { items.push_back(x) } ~Derived() { // virtual implicitly inherited cout << ""Derived dtor"" << endl; } private: vector<int> items; }; int main() { Base *bptr = new Derived; bptr->add(3) ; delete bptr; }",'2791,'78.27148438
'184,'Text 1908,"'Now the following is printed when the code is run:",'2792,'82.91015625
'184,'Text 1909,"'$ ./a.out Derived dtor Base dtor",'2793,'93.89648438
'184,'Text 1910,"'Valgrind also no longer reports an error.",'2794,'90.72265625
'184,'Text 1911,"'In general, a base class should always declare the destructor to be virtual if the class will be used polymorphically (meaning that a base-class pointer or reference may be bound to a derived-class object). If the base class destructor has no work to do, it may be defaulted. The derived class destructor need not be explicitly defined, since ""virtualness"" is inherited even if the destructor is implicitly defined by the compiler.",'2795,'97.75390625
'184,'Table 64,"",'2796,'43.11523438
'184,'Footer 131,"'26.6. Destructors and Polymorphism",'2797,'76.61132813
'184,'Page number 181,"'179",'2798,'83.83789063
'185,'Title 46,"'Programming and Data Structures, Release 0.3",'2799,'46.38671875
'185,'Text 1912,"'Valgrind does not show a memory leak:",'2800,'44.06738281
'185,'Text 1913,"'$ valgrind --leak-check=full ./a.out ==13479== Memcheck, a memory error detector ==13479== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al. ==13479== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info ==13479== Command: ./a.out ==13479== ==13479== ==13479== HEAP SUMMARY: ==13479== in use at exit: 0 bytes in 0 blocks ==13479== total heap usage: 3 allocs, 3 frees, 72,740 bytes allocated ==13479== ==13479== All heap blocks were freed -- no leaks are possible ==13479== ==13479== For counts of detected and suppressed errors, rerun with: -V ==13479== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)",'2801,'60.20507813
'185,'Footer 132,"'26.6. Destructors and Polymorphism",'2802,'86.91406250
'185,'Page number 182,"'180",'2803,'73.73046875
'186,'Text 1914,"'CHAPTER",'2804,'45.89843750
'186,'Header 171,"'TWENTYSEVEN",'2805,'35.66894531
'186,'Text 1915,"'LINKED LISTS",'2806,'81.68945313
'186,'Text 1916,"'A sequential container is a container that holds elements and allows them to be accessed in sequential order. The simplest sequential container is a built-in array, which stores its elements contiguously in memory:",'2807,'98.58398438
'186,'Text 1917,"'const int SIZE = 5; int array [SIZE] = { 1, 2, 3, 4, 5 }; // iterate over elements in order with traversal by pointer for (int *ptr = array; ptr != array + SIZE; ++ptr) { cout << *ptr << endl; }",'2808,'91.40625000
'186,'Text 1918,"'We can also traverse over arrays by index, using random access to get to an element:",'2809,'94.87304688
'186,'Text 1919,"'const int SIZE = 5; int array[SIZE] = { 1, 2, 3, 4, 5 }; // iterate over elements in order with traversal by index for (int i=0; i SIZE; ++i) { cout array[i] << endl; }",'2810,'95.55664063
'186,'Text 1920,"'The fact that the elements are stored contiguously makes random access efficient: it translates directly to pointer arith- metic, SO that it takes the same amount of time to access an element in the middle of the array as one at the beginning.",'2811,'96.92382813
'186,'Text 1921,"'cout << (array + i) << endl;",'2812,'30.73730469
'186,'Text 1922,"'However, arrays have significant limitations: their size is fixed upon creation, and for non-dynamic arrays, the size must be known at compile time.",'2813,'97.11914063
'186,'Text 1923,"'A vector is a class template that provides an abstraction over a dynamically allocated array. Like UnsortedSet, it grows as needed by swapping out an old array for a new one. A vector also provides an interface for iterating over the elements in order:",'2814,'97.31445313
'186,'Text 1924,"'vector<int> data; // add elements to the vector for (int i = 1; i <= ++i) { data.push_back(i) ; } // iterate over elements in order with traversal by iterator for (vector<int>::iterator it = data.begin(); it != vec. end () ; ++it) { cout << *it << endl; }",'2815,'96.43554688
'186,'Text 1925,"'We will cover iterators and traversal by iterator next time.",'2816,'88.57421875
'186,'Page number 183,"'181",'2817,'87.64648438
'187,'Header 172,"'Programming and Data Structures, Release 0.3",'2818,'63.42773438
'187,'Text 1926,"'Sequence abstractions based on contiguous memory have the drawback of inefficient insertion at the beginning or middle of the sequence. For instance, to insert an item at a particular position, we need to first move the elements at that position and later out of the way, as shown in Figure 27.1.",'2819,'97.85156250
'187,'Figure 64,"",'2820,'46.09375000
'187,'Text 1927,"'Figure 27.1: Inserting in the middle of a contiguous data structure requires elements to be shifted out of the way.",'2821,'95.75195313
'187,'Text 1928,"'Thus, insertion at the beginning or middle is a linear-time operation.",'2822,'85.15625000
'187,'Text 1929,"'On the other hand, if we give up the abstraction of contiguous memory, we can place a new item anywhere in memory. Since the elements are no longer stored contiguously, we cannot move to the next element by just incrementing an address. Instead, we have to explicitly keep track of where the next element is through a pointer.",'2823,'94.09179688
'187,'Table 65,"",'2824,'35.22949219
'187,'Table 66,"",'2825,'29.73632813
'187,'Text 1930,"'Figure 27.2: A noncontiguous data structure can use pointers to keep track of each element's location. Inserting in the middle can be done by just modifying a pointer.",'2826,'97.85156250
'187,'Text 1931,"'As illustrated in Figure 27.2, inserting in the middle now just involves changing the value of a pointer.",'2827,'97.94921875
'187,'Text 1932,"'For each element in our sequence, we need to keep track of both the datum itself as well as a pointer to the next piece of the sequence. This is heterogeneous data, SO we use a node class-type object to keep track of the two values:",'2828,'98.29101563
'187,'Text 1933,"'struct Node { int datum; Node *next; };",'2829,'82.32421875
'187,'Text 1934,"'We define the Node type as plain-old data, using the struct keyword and accessing the members directly. For now, we will stick to int as the element type; later, we will convert our abstraction into a template. The remaining Node member is a pointer to the next Node in our sequence.",'2830,'97.50976563
'187,'Text 1935,"'The sequence of Node objects in Figure 27.3 represents the elements ( 1234)",'2831,'94.09179688
'187,'Text 1936,"'We use a null pointer as a sentinel denoting the end of the sequence, storing that in the next pointer of the last node. We refer to the sequence of nodes as a linked list, as it consists of a list of items linked together by pointers.",'2832,'95.99609375
'187,'Text 1937,"'Rather than exposing the nodes directly as part of an abstract data type, we define an IntList ADT that internally maintains a sequence of nodes. It need only keep track of the location of the first Node, since we can get to the others by following next pointers:",'2833,'96.53320313
'187,'Page number 184,"'182",'2834,'87.89062500
'188,'Header 173,"'Programming and Data Structures, Release 0.3",'2835,'58.39843750
'188,'Figure 65,"",'2836,'98.97460938
'188,'Text 1938,"'Figure 27.3: Nodes representing a sequence of four elements. A null pointer represents the end of the sequence.",'2837,'92.62695313
'188,'Figure 66,"",'2838,'50.58593750
'188,'Text 1939,"'Figure 27.4: An IntList object and its nodes.",'2839,'88.23242188
'188,'Text 1940,"'Since the Node objects are stored indirectly from the IntList object, they must be in dynamic memory, and IntList must ensure that their memory is properly managed.",'2840,'97.36328125
'188,'Text 1941,"'Before we consider the representation of IntList further, we first write some code that uses IntList in order to work out its interface:",'2841,'96.97265625
'188,'Table 67,"",'2842,'90.57617188
'188,'Page number 185,"'183",'2843,'93.21289063
'189,'Header 174,"'Programming and Data Structures, Release 0.3",'2844,'87.25585938
'189,'Header 175,"'(continued from previous page)",'2845,'41.57714844
'189,'Table 68,"",'2846,'46.77734375
'189,'Text 1942,"'}",'2847,'31.90917969
'189,'Text 1943,"'The class should have a default constructor that makes the list empty. It should also have a push_front () member function to insert an item at the beginning, as well as front () to retrieve the first item. The latter must support both reading and writing the first element. The remaining member functions are print (), pop_front () to remove the first item, and empty (). The following is the resulting interface:",'2848,'98.14453125
'189,'Text 1944,"'class IntList { public:",'2849,'44.16503906
'189,'Key value 39,"",'2850,'62.69531250
'189,'Text 1945,"'};",'2851,'29.17480469
'189,'Text 1946,"'Notice that Node appears nowhere in the interface. It is an implementation detail, SO it should be defined as a private member of IntList. This makes it a nested class, which is a class (or struct) defined as a member of another class.",'2852,'96.48437500
'189,'Text 1947,"'class IntList private: struct Node { int datum; Node *next;",'2853,'94.18945313
'189,'Text 1948,"'(continues on next page)",'2854,'93.26171875
'189,'Page number 186,"'184",'2855,'88.03710938
'190,'Header 176,"'Programming and Data Structures, Release 0.3",'2856,'56.98242188
'190,'Text 1949,"'(continued from previous page)",'2857,'81.25000000
'190,'Text 1950,"'} ;",'2858,'85.20507813
'190,'Text 1951,"'Node *first; };",'2859,'69.53125000
'190,'Text 1952,"'Now that we have a representation, the next step is to determine the representation invariants. We have already decided to use a null pointer to denote the end of the sequence of nodes. Similarly, we can store a null pointer in first to represent an empty list. Thus, the invariants are as follows:",'2860,'96.48437500
'190,'List 60,"",'2861,'92.77343750
'190,'Text 1953 - Part of List 60,"'first is either null or a pointer to a valid Node",'2862,'97.75390625
'190,'Text 1954 - Part of List 60,"'the next member of all but the last node points to another valid Node",'2863,'98.14453125
'190,'Text 1955 - Part of List 60,"'the next member of the last node is null",'2864,'97.46093750
'190,'Text 1956,"'We can now proceed to implement the constructor and the remaining member functions.",'2865,'93.06640625
'190,'Text 1957,"'The constructor must ensure that the list is initialized to satisfy the representation invariants. Since the default con- structor makes the list empty, it must initialize first to be null:",'2866,'95.60546875
'190,'Text 1958,"'IntList: : IntList() : first (nullptr) {}",'2867,'40.82031250
'190,'Text 1959,"'The empty function just needs to check whether first is null:",'2868,'92.62695313
'190,'Text 1960,"'bool IntList : empty const { return first == nullptr; // or just return !first; }",'2869,'74.31640625
'190,'Text 1961,"'For front (), we will first assert the REQUIRES clause that the list not be empty. If that is satisfied, the representation invariants tell us that first is pointing to a valid node. Its datum member holds the first element.",'2870,'95.16601563
'190,'Text 1962,"'int & IntList::frontO) assert ( empty C return first->datum; }",'2871,'89.45312500
'190,'Text 1963,"'The return by reference is necessary to allow code such as:",'2872,'95.80078125
'190,'Text 1964,"'list. front ()=4;",'2873,'86.23046875
'190,'Text 1965,"'The left-hand side of an assignment must be an object, not a temporary value, SO front () must return an object by reference.",'2874,'95.89843750
'190,'Text 1966,"'For push_front (), we need to consider two cases:",'2875,'91.40625000
'190,'List 61,"",'2876,'85.59570313
'190,'Text 1967 - Part of List 61,"'The list is empty, in which case first is null.",'2877,'96.43554688
'190,'Text 1968 - Part of List 61,"'The list is not empty, in which case first points to a valid node.",'2878,'96.43554688
'190,'Text 1969,"'In both cases, we construct a new Node in dynamic memory, set its datum to be the value that is being inserted, set its next to be the existing value of first, and set first to point to the new Node.",'2879,'95.31250000
'190,'Text 1970,"'void IntList : push_front (int datum) {",'2880,'48.92578125
'190,'Text 1971,"'Node *p = new Node; p->datum = datum;",'2881,'49.60937500
'190,'Text 1972,"'(continues on next page)",'2882,'88.91601563
'190,'Text 1973,"'1 There are two further invariants: a node is associated with exactly one list, and there are no cycles among the next pointers of the nodes. The latter makes it invalid, for instance, to have one node's next point to a second node and have the second's next point back to the first node.",'2883,'54.68750000
'190,'Page number 187,"'185",'2884,'83.00781250
'191,'Header 177,"'Programming and Data Structures, Release 0.3",'2885,'78.51562500
'191,'Figure 67,"",'2886,'62.25585938
'191,'Figure 68,"",'2887,'37.35351563
'191,'Text 1974,"'Figure 27.5: Inserting an element to the front of an empty and non-empty list.",'2888,'84.03320313
'191,'Text 1975,"'(continued from previous page)",'2889,'89.89257813
'191,'Text 1976,"'p->next = first; first = p; }",'2890,'81.34765625
'191,'Text 1977,"'A more succinct way to accomplish this is with an initializer list that directly initializes each member of the new Node; this is permitted since Node is a C-style ADT.",'2891,'96.14257813
'191,'Text 1978,"'void IntList: : : push_front (int datum) { first = new Node{ datum, first }; }",'2892,'91.11328125
'191,'Text 1979,"'In pop_front (), we again assert the REQUIRES clause. We should then consider two possible cases:",'2893,'95.84960938
'191,'List 62,"",'2894,'91.94335938
'191,'Text 1980 - Part of List 62,"'The list has one item, in which case it will end up as empty.",'2895,'97.90039063
'191,'Text 1981 - Part of List 62,"'The list has more than one item, and it will not end up empty.",'2896,'97.80273438
'191,'Text 1982,"'In the former case, the sole node is the last one, and the representation invariants tell us that its next is null. Thus, setting first to the node's next suitably makes the list empty. In the second case, the first node's next is pointing to the second node in the list, SO first should end up pointing at that node when the first one is removed. Thus, in both cases, we need to assign the value of first->next to first.",'2897,'97.16796875
'191,'Text 1983,"'We also need to properly manage dynamic memory; in particular, we must delete the node that is being removed, as it is memory that no longer will be used.",'2898,'90.91796875
'191,'Text 1984,"'Consider the following implementation of pop_front():",'2899,'85.83984375
'191,'Text 1985,"'void IntList: pop_front() assert (!empty()): delete first; first = first->next; }",'2900,'95.80078125
'191,'Text 1986,"'This code dereferences first through the arrow operator after the underlying object has been deleted, resulting in undefined behavior. Let's try to fix this by reordering the statements:",'2901,'95.89843750
'191,'Figure 69,"",'2902,'30.39550781
'191,'Text 1987,"'void IntList : pop_front() assert ( empty( ()); first = first->next;",'2903,'79.63867188
'191,'Text 1988,"'(continues on next page)",'2904,'77.39257813
'191,'Page number 188,"'186",'2905,'88.67187500
'192,'Header 178,"'Programming and Data Structures, Release 0.3",'2906,'50.00000000
'192,'Text 1989,"'}",'2907,'81.01284790
'192,'Text 1990,"'(continued from previous page)",'2908,'86.08398438
'192,'Text 1991,"'delete first;",'2909,'62.69531250
'192,'Text 1992,"'Now, the assignment to first orphans what previously was the first node; we no longer have a means to get to that object, resulting in a memory leak. The code then proceeds to delete what used to be the second node.",'2910,'97.02148438
'192,'Text 1993,"'Neither ordering works correctly on its own. What we need is a temporary to keep track of the first node, SO that we can change the value of first but still be able to delete the node that is being removed. The following are two correct implementations:",'2911,'96.48437500
'192,'Text 1994,"'void IntList :pop_front () assert (!empty()); Node *victim = first; first = first->next; delete victim; }",'2912,'84.66796875
'192,'Text 1995,"'// temporary keeps track of old first",'2913,'59.57031250
'192,'Text 1996,"'void IntList: pop_front() assert (! !empty()); Node *new_first = first->next; // temporary keeps track of new first delete first; first = new_first; }",'2914,'73.38867188
'192,'Text 1997,"'Figure 27.6 illustrates the first implementation of pop_front ().",'2915,'85.35156250
'192,'Figure 70,"",'2916,'91.89453125
'192,'Text 1998,"'Figure 27.6: Removing an element from the front of a list.",'2917,'76.90429688
'192,'Page number 189,"'187",'2918,'90.82031250
'193,'Header 179,"'Programming and Data Structures, Release 0.3",'2919,'44.55566406
'193,'Section header 138,"'27.1 Traversing a Linked List",'2920,'88.23242188
'193,'Text 1999,"'Iterating over a linked list's elements from outside the class requires an iterator abstraction that we will see next time: the Node struct is private, SO external code cannot use Nodes to iterate through the list. Code within IntList, on the other hand, does have access to Node, SO it can traverse the list by starting at the first member and following each node's next pointer until reaching the null sentinel. The following print member function uses this strategy:",'2921,'98.48632813
'193,'Text 2000,"'void IntList: : print (std: ostream &os) const { for (Node *node_ptr = first; node_ptr; node_ptr = node_ptr->next) { os << node_ptr->datum << ""; }",'2922,'89.74609375
'193,'Text 2001,"'The loop initializes node_ptr as a copy of first. If the list is empty, first is null, SO node_ptr will be initialized to null as well. The truth value of a null pointer is false, SO the condition of the loop will evaluate to false and the loop will exit. (Alternatively, node_ptr can be compared to nullptr instead: node_ptr nullptr.)",'2923,'87.06054688
'193,'Text 2002,"'If the list is not empty, node_ptr will not be initially null, and its truth value will be true. The body then executes, and it uses the -> operator to access the datum member of the node that node_ptr points to. The loop update then copies the node's next pointer into node_ptr, moving node_ptr to point to the next node. When the iteration reaches the last node in the list, its next is null, SO the update sets node_ptr to be null. This results in the loop condition being false, SO the loop exits.",'2924,'91.40625000
'193,'Figure 71,"",'2925,'94.72656250
'193,'Text 2003,"'Figure 27.7: Traversal of the nodes in a list, starting at first, following next pointers, and ending at the null sentinel.",'2926,'93.35937500
'193,'Section header 139,"'27.2 Linked List Big Three",'2927,'92.72460938
'193,'Text 2004,"'Inserting an element into a list allocates a Node in dynamic memory, SO the list must properly manage the node objects to avoid a memory leak. The compiler-generated destructor does not free the nodes' memory, SO we need to write a custom destructor instead. The law of the big three then tells us that we need to write a custom copy constructor and assignment operator as well.",'2928,'96.87500000
'193,'Text 2005,"'Both the destructor and the assignment operator must free the list's resources, and both the copy constructor and assignment operator perform a deep copy of another list's resources. To avoid code duplication, we write a pop_all() member function to free all the elements and their nodes, and a push_all() function to copy all the elements from another list. These functions are not part of the interface, SO we write them as private members:",'2929,'94.67773438
'193,'Footer 133,"'27.1. Traversing a Linked List",'2930,'82.86132813
'193,'Page number 190,"'188",'2931,'88.67187500
'194,'Header 180,"'Programming and Data Structures, Release 0.3",'2932,'53.02734375
'194,'Text 2006,"'class IntList { private: // EFFECTS: Removes all the elements from this list. void pop_all(); // EFFECTS: Adds all elements from other into this list. void push_all (const IntList &other); }",'2933,'79.44335938
'194,'Text 2007,"'With these two functions, we can write the big three as follows:",'2934,'53.71093750
'194,'Text 2008,"'IntList: IntList(const IntList &other) : IntList() push_all(other); } IntList & IntList: operator=(const IntList &rhs) { if (this != &rhs) { pop_all(); push_all(rhs); } return *this; } IntList::~IntList() pop_all(); }",'2935,'43.01757813
'194,'Text 2009,"'The copy constructor delegates to the default constructor to make the list empty, then calls push_all to copy all the elements from the other list. The assignment operator does a self-assignment check, calls pop_all() to remove all the existing elements, and invokes push_all( to copy the elements from the other list. The destructor just calls pop_all() to remove all the elements and free their associated nodes.",'2936,'93.89648438
'194,'Text 2010,"'The implementation of pop_all() is straightforward: we already have a pop_front() function that removes a single item, SO we just need to repeatedly call it until the list is empty:",'2937,'92.52929688
'194,'Section header 140,"'void IntList::pop_allO)",'2938,'46.97265625
'194,'Text 2011,"'while (!empty()) { pop_front() } }",'2939,'92.43164063
'194,'Text 2012,"'The push_all() function needs to iterate over each of the elements in the other list, adding them one by one to the current list. We can follow the same iteration pattern we used in print (), and we have a push_front () function that adds a single element:",'2940,'97.31445313
'194,'Text 2013,"'void IntList: : push_all(const IntList &other) { for (Node *node_ptr = other.first; node_ptr; node_ptr = node_ptr->next) { push_front (node_ptr->datum) } }",'2941,'94.38476563
'194,'Text 2014,"'However, this implementation ends up inserting the elements in reverse order: if other contains the elements ( 1 2 3 ), the code would insert 1, then 2 before that, then 3 before that, resulting in ( 3 2 1 ).",'2942,'92.28515625
'194,'Footer 134,"'27.2. Linked List Big Three",'2943,'61.76757813
'194,'Page number 191,"'189",'2944,'77.97851563
'195,'Header 181,"'Programming and Data Structures, Release 0.3",'2945,'51.46484375
'195,'Text 2015,"'Rather than inserting each element at the beginning of the list, we need to insert at the end with a push_back() function.",'2946,'97.99804688
'195,'Text 2016,"'void IntList: : push_all (const IntList &other) { for (Node *node_ptr = other.first; node_ptr; node_ptr = node_ptr->next) { push_back(node_ptr->datum) ; } }",'2947,'95.16601563
'195,'Section header 141,"'27.3 Insertion and Removal at the End",'2948,'73.92578125
'195,'Text 2017,"'With our current list representation, push_back() must traverse the entire list to insert the new element:",'2949,'94.62890625
'195,'Text 2018,"'void IntList :push_back(int datum) { Node *new_node = new Node{ datum, nullptr }; if (empty()) { first = new_node; } else { Node *node_ptr = first; for (; node_ptr->next; node_ptr = node_ptr->next) ; // find last node node_ptr->next = new_node; // set last node's next to new_node }",'2950,'95.41015625
'195,'Text 2019,"'This is a very inefficient algorithm; the core problem is our list implementation only keeps track of the first node, but we need to insert after the last node. We can make push_back() much more efficient by changing our list representation to keep track of the last node as well:",'2951,'96.82617188
'195,'Section header 142,"'class IntList {",'2952,'32.69042969
'195,'Text 2020,"'private: Node *first; Node *last; };",'2953,'79.19921875
'195,'Figure 72,"",'2954,'92.18750000
'195,'Text 2021,"'Figure 27.8: Double-ended list representation with first and last pointers.",'2955,'78.90625000
'195,'Footer 135,"'27.3. Insertion and Removal at the End",'2956,'81.64062500
'195,'Page number 192,"'190",'2957,'88.28125000
'196,'Header 182,"'Programming and Data Structures, Release 0.3",'2958,'50.97656250
'196,'Text 2022,"'We update our representation invariants SO that an empty list is represented by both last and first being null, and that last points to the last node in the sequence for a non-empty list.",'2959,'98.68164063
'196,'Text 2023,"'We can then write push_back() as follows:",'2960,'90.13671875
'196,'Text 2024,"'void IntList : : push_back(int datum) { Node *new_node = new Node{ datum, nullptr }; if (empty()) { first = last = new_node; } else { last = last->next = new_node; } }",'2961,'96.72851563
'196,'Text 2025,"'In the case of inserting into an empty list, we need to set both first and last pointing at the new node. (We would need to modify pop_front() to do this as well.) When inserting at the end of a non-empty list, we have to set the next pointer of what used to be the last node to point to the new node, and we must also update the last member of the IntList SO that it points to the new node.",'2962,'96.53320313
'196,'Text 2026,"'Now that we have push_back the logical next step is to provide pop_back() as well. Unfortunately, pop_back() requires setting the last pointer to point to what used to be the second-to-last node, and we can only get to that node by traversing the entire list from the beginning. Here, the problem is that our nodes only have a next pointer, SO they allow us to traverse in the forward direction but not in reverse. We can modify our representation once more to enable backwards traversal by adding a prev pointer to each node:",'2963,'96.82617188
'196,'Text 2027,"'class IntList { private: struct Node { int datum; Node *prev; Node *next; }; Node *first; Node *last; };",'2964,'92.23632813
'196,'Text 2028,"'This is now a doubly linked list, since each node has two links, one to the previous node and one to the next node. Our original list is a singly linked list.",'2965,'96.92382813
'196,'Text 2029,"'The standard library provides both implementations: std: : forward_list is a singly linked list, while std: : list is a doubly linked list. The former uses less space than the latter, since the nodes don't have a pointer to the previous node, but it does not provide the ability to iterate backwards over the list.",'2966,'96.87500000
'196,'Section header 143,"'27.4 List Template",'2967,'87.64648438
'196,'Text 2030,"'We can generalize the IntList class to hold objects of other types by making it a template. Each instantiation is still homogeneous: List<int> only holds ints, List<string> only holds strings, and SO on.",'2968,'97.26562500
'196,'Section header 144,"'template <typename T>",'2969,'38.86718750
'196,'Figure 73,"",'2970,'50.68359375
'196,'Text 2031,"'class List { public: List()",'2971,'34.47265625
'196,'Text 2032,"'(continues on next page)",'2972,'82.61718750
'196,'Footer 136,"'27.4. List Template",'2973,'45.33691406
'196,'Page number 193,"'191",'2974,'80.81054688
'197,'Header 183,"'Programming and Data Structures, Release 0.3",'2975,'71.24023438
'197,'Figure 74,"",'2976,'96.04492188
'197,'Text 2033,"'Figure 27.9: Doubly linked list with next and prev pointers in each node.",'2977,'86.37695313
'197,'Text 2034,"'(continued from previous page)",'2978,'90.96679688
'197,'Table 69,"",'2979,'29.78515625
'197,'Text 2035,"'By placing the Node struct inside the List template, each instantiation of List will have its own Node type; List<int> : : Node, List<string> : : Node, and List<Duck> : : Node are all distinct types.",'2980,'61.86523438
'197,'Text 2036,"'Now that our container is a template, we pass elements by reference. For List<int>, the elements are small enough to copy, but for class-type elements such as in List<string> or List<Duck>, we want to avoid making unnecessary copies. A good rule of thumb is to pass a function parameter by reference if the function parameter's type is a template parameter, since the latter may be instantiated with a large class type.",'2981,'91.79687500
'197,'Footer 137,"'27.4. List Template",'2982,'61.23046875
'197,'Page number 194,"'192",'2983,'89.55078125
'198,'Header 184,"'CHAPTER TWENTYEIGHT",'2984,'29.17480469
'198,'Title 47,"'IMPLEMENTING ITERATORS",'2985,'79.39453125
'198,'Text 2037,"'Last time, we saw how to iterate over the elements of a linked list from within the list class itself:",'2986,'97.31445313
'198,'Section header 145,"'template <typename T>",'2987,'37.57324219
'198,'Figure 75,"",'2988,'25.34179688
'198,'Text 2038,"'void List<T>: print (std: :ostream &os) const { for (Node *node_ptr = first; node_ptr != nullptr; node_ptr = node_ptr->next) { os << node_ptr->datum << ""; } }",'2989,'96.28906250
'198,'Text 2039,"'The strategy is to start with the first node in the list, then follow the nodes' next pointers until reaching the null sentinel. We can try to follow the same strategy from outside the class:",'2990,'93.16406250
'198,'Text 2040,"'List<int> list;",'2991,'25.46386719
'198,'Text 2041,"'for (Node *node_ptr = list.first; node_ptr != nullptr; node_ptr = node_ptr->next) { cout << node_ptr->datum << endl; }",'2992,'91.79687500
'198,'Text 2042,"'However, this strategy doesn't work from outside the list because the nested Node class is private - it is an implemen- tation detail, SO outside code should not depend on it anyway. The first member is also private, SO the initialization of node_ptr is invalid. Instead, we need to provide a different interface for iterating over a list.",'2993,'94.58007813
'198,'Text 2043,"'We have seen two patterns for iterating over a sequential container, traversal by index and traversal by pointer. In traversal by index, we use a loop variable of integral type, increment it in each iteration, and access an element by using the index as an offset into the container:",'2994,'95.21484375
'198,'Text 2044,"'const int SIZE = 5; int array[SIZE] = { 1, 2, 3, 4, 5 }; // iterate over elements in order with traversal by index for (int i=o; SIZE; ++i) { cout << array[i] << endl; }",'2995,'94.67773438
'198,'Text 2045,"'To use this pattern with a container, it must support random access, the ability to directly access an element through an index. Array-based sequential containers generally support random access. For built-in arrays, it translates directly to pointer arithmetic. Array-based class types such as std: : array and std: vector overload the subscript operator to index into the underlying array, which then turns into pointer arithmetic.",'2996,'95.94726563
'198,'Text 2046,"'Linked lists do not provide random access; since they are not array-based, accessing an element in the middle of the list cannot be done with pointer arithmetic, but must traverse from the start of the list as in print (). Thus, traversal by index is not an appropriate pattern for a linked list.",'2997,'96.14257813
'198,'Page number 195,"'193",'2998,'78.80859375
'199,'Header 185,"'Programming and Data Structures, Release 0.3",'2999,'47.16796875
'199,'Text 2047,"'Traversal by pointer, on the other hand, starts with a pointer to the beginning of a sequence and iterates by moving that pointer forward to each subsequent element, until that pointer reaches past the end of the sequence:",'3000,'97.90039063
'199,'Text 2048,"'const int SIZE = 5; int array [SIZE] = { 1, 2, 3, 4, 5 }; // iterate over elements in order with traversal by pointer for (int *ptr = array; ptr != array + SIZE; ++ptr) { cout << *ptr << endl; }",'3001,'67.91992188
'199,'Text 2049,"'A similar pattern would work for a linked list: start off with something like a pointer that ""points"" to the beginning of the list, move it forward one element at a time, and stop when we get past the end of the list:",'3002,'93.70117188
'199,'Text 2050,"'List<int> list; for (Iterator it = list.begin(); it != list.end() ++it) { cout << *it << endl; }",'3003,'86.18164063
'199,'Text 2051,"'We use an object called an iterator to iterate over the elements. The pattern above is called traversal by literator, and it is a generalization of traversal by pointer.",'3004,'93.50585938
'199,'Text 2052,"'To traverse with an iterator, it must provide the following operations: 1",'3005,'93.94531250
'199,'List 63,"",'3006,'93.84765625
'199,'Text 2053 - Part of List 63,"'dereference (prefix *)",'3007,'97.41210938
'199,'Text 2054 - Part of List 63,"'increment (prefix ++)",'3008,'96.82617188
'199,'Text 2055 - Part of List 63,"'equality checks (== and !=)",'3009,'96.04492188
'199,'Text 2056,"'In addition, the container itself must provide two member functions:",'3010,'94.23828125
'199,'List 64,"",'3011,'79.88281250
'199,'Text 2057 - Part of List 64,"'begin() returns an iterator to the start of the sequence",'3012,'96.04492188
'199,'Text 2058 - Part of List 64,"'end () returns a ""past-the-end"" iterator that represents a position that is past the last element of the sequence",'3013,'95.80078125
'199,'Text 2059,"'An iterator is a class-type object that has the same interface as a pointer. We provide the same interface by overloading the required operators:",'3014,'95.21484375
'199,'Text 2060,"'template <typename T> class Iterator { public: T & operator* const; Iterator &operator++(); bool operator==(Iterator rhs) const; bool operator!=(Iterator rhs) const; } ;",'3015,'45.89843750
'199,'Figure 76,"",'3016,'26.29394531
'199,'Text 2061,"'The unary * operator is overloaded to return the element the iterator is pointing to by reference. The prefix ++ operator moves the iterator to point to the next element in the sequence, and it returns the iterator itself by reference. This allows the operator to be chained:",'3017,'93.11523438
'199,'Text 2062,"'++++it;",'3018,'68.60351563
'199,'Text 2063,"'1 There are many kinds of iterators in C++. We will only implement a subset of the operations required for an input iterator.",'3019,'73.77929688
'199,'Page number 196,"'194",'3020,'88.23242188
'200,'Header 186,"'Programming and Data Structures, Release 0.3",'3021,'76.22070313
'200,'Text 2064,"'The equality operators determine if the receiver points to the same element as the rhs iterator. Unlike most class types, we pass iterators by value - they are generally small, and it is standard practice in C++ to make copies of them when we pass them to a function, just like we would for pointers.",'3022,'97.11914063
'200,'Text 2065,"'Before we proceed to implement the operators, we need a data representation. The representation of an iterator is specific to a particular kind of container. For a linked list, traversal by iterator is just an abstraction over the traversal in print ()",'3023,'95.06835938
'200,'List 65,"",'3024,'93.45703125
'200,'Text 2066 - Part of List 65,"'A list iterator is an abstraction over a pointer to a node.",'3025,'97.11914063
'200,'Text 2067 - Part of List 65,"'The call list. begin() returns an iterator constructed from first.",'3026,'96.97265625
'200,'Text 2068 - Part of List 65,"'The past-the-end iterator returned by list end() is represented by a null pointer.",'3027,'97.36328125
'200,'Text 2069 - Part of List 65,"'Comparing two iterators compares their underlying node pointers.",'3028,'96.77734375
'200,'Text 2070 - Part of List 65,"'Incrementing an iterator moves its node pointer to the next node using the original node's next member.",'3029,'97.80273438
'200,'Text 2071 - Part of List 65,"'Derferencing the iterator obtains the datum member of the underlying node.",'3030,'97.07031250
'200,'Text 2072,"'Thus, we represent an iterator with just a pointer to a node.",'3031,'92.62695313
'200,'Text 2073,"'template <typename T> class Iterator { private: Node *node_ptr; };",'3032,'37.89062500
'200,'Figure 77,"",'3033,'92.87109375
'200,'Text 2074,"'Figure 28.1: A list iterator is an abstraction of a pointer to a node.",'3034,'65.33203125
'200,'Text 2075,"'As mentioned above, we use a null pointer for an iterator that is past the end of a list. The end condition for the traversal in print () is when the node pointer is null - after the traversal reaches the last node, it sets the pointer to the value of the last node's next member, which is null according to the list's representation invariant. Thus, it makes sense to use a null pointer to represent a past-the-end iterator.",'3035,'88.13476563
'200,'Text 2076,"'Now that we have a representation, we should consider representation invariants. It is the case that node_ptr will either be null or point to a valid list node when the iterator is created. However, we will see that an iterator may be",'3036,'65.03906250
'200,'Page number 197,"'195",'3037,'89.89257813
'201,'Header 187,"'Programming and Data Structures, Release 0.3",'3038,'76.07421875
'201,'Figure 78,"",'3039,'99.31640625
'201,'Text 2077,"'Figure 28.2: A list past-the-end iterator has a null pointer as its stored node pointer.",'3040,'89.69726563
'201,'Text 2078,"'invalidated, which will result in node_ptr pointing to an invalid node. Thus, there is no invariant that will hold for a list iterator's representation.",'3041,'95.11718750
'201,'Section header 146,"'28.1 Iterator Definition",'3042,'86.76757813
'201,'Text 2079,"'Before we proceed to implement Iterator, observe the following issues with its definition:",'3043,'96.48437500
'201,'List 66,"",'3044,'96.87500000
'201,'Text 2080 - Part of List 66,"'Node is not a top-level type, but a member of the List class template, SO it cannot be named from the outside without the scope-resolution operator.",'3045,'98.73046875
'201,'Text 2081 - Part of List 66,"'The Node struct is private, SO it cannot be accessed from outside code.",'3046,'98.19335938
'201,'Text 2082 - Part of List 66,"'The iterator type is associated with List, SO it should be encapsulated within the List template.",'3047,'98.43750000
'201,'Text 2083,"'We can solve these issues by defining Iterator as a member of the List template:",'3048,'94.67773438
'201,'Text 2084,"'template <typename T> class List { private: struct Node { int datum; Node *next; }; public: class Iterator { public: T & operator* * () const; Iterator &operator++()",'3049,'31.44531250
'201,'Text 2085,"'(continues on next page)",'3050,'83.05664063
'201,'Footer 138,"'28.1. Iterator Definition",'3051,'61.13281250
'201,'Page number 198,"'196",'3052,'89.20898438
'202,'Header 188,"'Programming and Data Structures, Release 0.3",'3053,'82.66601563
'202,'Text 2086,"'(continued from previous page)",'3054,'66.69921875
'202,'Text 2087,"'bool operator== (Iterator rhs) const;",'3055,'53.32031250
'202,'Text 2088,"'bool operator!=(Iterator rhs) const; private: Node *node_ptr; };",'3056,'39.47753906
'202,'Text 2089,"'private: Node *first; Node *last; };",'3057,'62.69531250
'202,'Text 2090,"'We must define the Iterator class after the definition of the Node struct SO that Node is in scope when it is referenced in the Iterator class. Iterator itself is part of the interface for List, SO it is defined as public within List.",'3058,'90.82031250
'202,'Text 2091,"'We can now implement the member functions of Iterator.",'3059,'85.25390625
'202,'Section header 147,"'28.1.1 Dereference and Increment Operators",'3060,'75.92773438
'202,'Text 2092,"'The dereference operator requires that the iterator is dereferenceable, which means that it is pointing to a valid element in the container. We cannot in general check that this is the case, but we can check whether the iterator is a past-the-end iterator:",'3061,'95.80078125
'202,'Text 2093,"'// REQUIRES: this is a dereferenceable iterator // EFFECTS: Returns the element that this iterator points to. template <typename T> T & List<T> : Iterator : operator* O const { assert (node_ptr) // check whether this is a past-the-end iterator return mode_ptr->datum; }",'3062,'53.32031250
'202,'Text 2094,"'The operator* () function is a member of Iterator, which itself is a member of List<T> - thus, we need two scope-resolution operators when referring to the function. After asserting that the iterator is not past the end, the function just returns the datum member of the underlying node. The return is by reference, SO that the element can be modified through the iterator:",'3063,'95.70312500
'202,'Text 2095,"'List<int> Iterator it = ; *it = 3; // LHS of assignment must be an object",'3064,'59.71679688
'202,'Text 2096,"'The dereference operator does not modify the iterator. In addition, while the function returns an object by reference to non-const, modifying that object does not modify the iterator, since the object is not a member of the iterator itself. Thus, the dereference operator can be declared as a const member function.",'3065,'94.48242188
'202,'Text 2097,"'The operator++ () function modifies the iterator by moving it to ""point to"" the next element, SO it cannot be declared as const. As with dereference, the past-the-end iterator cannot be incremented - node_ptr would be null, and there wouldn't be a next pointer to move the iterator to.",'3066,'93.40820313
'202,'Text 2098,"'// REQUIRES: this is a dereferenceable iterator // EFFECTS: Returns the element that this iterator points to. template <typename T>",'3067,'57.56835938
'202,'Text 2099,"'(continues on next page)",'3068,'75.92773438
'202,'Text 2100,"'2 The scope of a class member begins at the member declaration and includes the rest of the class body, all member-function bodies, and all member-initializer lists.",'3069,'67.67578125
'202,'Footer 139,"'28.1. Iterator Definition",'3070,'44.84863281
'202,'Page number 199,"'197",'3071,'86.76757813
'203,'Header 189,"'Programming and Data Structures, Release 0.3",'3072,'74.07226563
'203,'Text 2101,"'(continued from previous page)",'3073,'76.70898438
'203,'Text 2102,"'typename List<T>::Iterator & List<T>::Iterator: operator++ { assert (node_ptr); // check whether this is a past-the-end iterator node_ptr = node_ptr->next; return *this; }",'3074,'50.48828125
'203,'Text 2103,"'The function moves the iterator to the next element by following the next pointer of the current node. Once the iterator has been moved, the function returns the iterator by reference, in keeping with the pattern for prefix increment.3",'3075,'93.70117188
'203,'Section header 148,"'28.1.2 The typename Keyword",'3076,'80.51757813
'203,'Text 2104,"'The return type of operator++() is a reference to List<T>: Iterator; Iterator is a member of a template that is dependent on the template parameter T. C++ requires the typename keyword before a dependent name that refers to a type, SO that the compiler knows that it is a type and not a value.4 4",'3077,'96.92382813
'203,'Text 2105,"'The following illustrates when the typename keyword is required:",'3078,'91.99218750
'203,'Text 2106,"'template <typename U> void func() { IntList list; // not a qualified type IntList::Iterator it1; // outer class does not depend on template parameter U List<int>:: Iterator it2; // outer class does not depend on template parameter U typename List<U>: Iterator it3; // outer class depends on template parameter U int capacity = SortedSet<U> MAX_CAPACITY; // member is not a type }",'3079,'69.67773438
'203,'Text 2107,"'An unqualified name, one without the scope-resolution operator, never needs the typename keyword. In a qualified name, if the outer type does not depend on a template parameter, then no typename keyword is required. If the outer type does depend on a template parameter, then the typename keyword is required when the inner name refers to a type. If the inner name does not refer to a type, the typename keyword is erroneous to use, since it explicitly tells the compiler that the inner name is a type.",'3080,'97.36328125
'203,'Text 2108,"'In practice, compilers can often determine when the typename keyword is required, and many C++ programmers rely on the compiler to tell them that it is needed rather than learning the rules:",'3081,'94.97070313
'203,'Text 2109,"'$ g++ --std=c++17 foo. cpp foo. cpp: 5:20: error: expected ';' after expression List<U> Iterator it; ^ ; foo. cpp: 5:21: error: use of undeclared identifier 'it'",'3082,'84.86328125
'203,'Text 2110,"'(continues on next page)",'3083,'75.14648438
'203,'Text 2111,"'3 The postfix increment operator can be overloaded as well. To distinguish its signature from prefix, C++ uses a dummy int parameter for postfix:",'3084,'90.28320313
'203,'Text 2112,"'template <typename T> typename List<T>::Iterator list<T>::Iterator: coperator++( { assert(node_ptr) // check whether this is a past-the-end iterator Iterator tmp = *this; // make a copy of this iterator node_ptr = node_ptr->next; return tmp; // return the copy }",'3085,'90.28320313
'203,'Text 2113,"'We need not provide a parameter name, since we are not actually using the parameter object. In keeping with the contract for postfix increment, the function returns a copy of the original iterator by value. 4 The reasons are beyond the scope of this course, but they have to do with the way the compiler instantiates templates.",'3086,'39.03808594
'203,'Footer 140,"'28.1. Iterator Definition",'3087,'42.62695313
'203,'Page number 200,"'198",'3088,'86.03515625
'204,'Header 190,"'Programming and Data Structures, Release 0.3",'3089,'53.51562500
'204,'Text 2114,"'(continued from previous page)",'3090,'60.49804688
'204,'Text 2115,"'List<U> : Iterator it; ^ foo. .cpp:5:3: error: missing 'typename' prior to dependent type name 'List<int> : : Iterator' List<U> Iterator it; foo. cpp:9:3: note: in instantiation of function template specialization 'func<int>' requested here func<int>() A 3 errors generated.",'3091,'45.50781250
'204,'Section header 149,"'28.1.3 Equality Comparisons",'3092,'70.55664063
'204,'Text 2116,"'Two iterators are defined as equal if either they are both past the end, or they ""point to"" the same element in the same list. Thus, they are equal exactly when their node. ptr members point to the same node.",'3093,'90.96679688
'204,'Figure 79,"",'3094,'96.33789063
'204,'Text 2117,"'Figure 28.3: Two iterators are equal when their node pointers store the same address, pointing to the same node.",'3095,'95.01953125
'204,'Text 2118,"'Comparing two iterators does not require them to be dereferenceable or even pointing to a valid element. Thus, the operators do not have a REQUIRES clause.",'3096,'97.36328125
'204,'Figure 80,"",'3097,'61.76757813
'204,'Text 2119,"'template <typename T> bool List<T> : : Iterator: : operator==(Iterator rhs) const { return node_ptr == rhs.node_ptr; } template <typename T> bool List<T> : : Iterator: : operator != (Iterator rhs) const { return node_ptr != rhs.node_ptr; }",'3098,'56.29882813
'204,'Footer 141,"'28.1. Iterator Definition",'3099,'59.57031250
'204,'Page number 201,"'199",'3100,'91.16210938
'205,'Header 191,"'Programming and Data Structures, Release 0.3",'3101,'50.48828125
'205,'Text 2120,"'We do not need to qualify Iterator in the parameter type - once the compiler knows that we are defining a member of Iterator, we can refer to the class with an unqualified name.",'3102,'96.14257813
'205,'Section header 150,"'28.1.4 Creating Iterators",'3103,'74.31640625
'205,'Text 2121,"'We have defined the operator overloads for Iterator. However, we have not provided a means of creating an Iterator object. Without a user-defined constructor, we do get an implicit default constructor, but it just initializes node_ptr with a junk value. Instead, we define the following two constructors:",'3104,'97.02148438
'205,'List 67,"",'3105,'87.93945313
'205,'Text 2122 - Part of List 67,"'an explicit default constructor that makes the iterator a past-the-end iterator",'3106,'97.70507813
'205,'Text 2123 - Part of List 67,"'a constructor that takes in a pointer to a node",'3107,'97.85156250
'205,'Text 2124,"'The latter is a private constructor - the Node class is not part of the interface for the list, SO the constructor that takes a node pointer also is not part of the interface, and the outside world would not be able to call it even if it were.",'3108,'96.87500000
'205,'Text 2125,"'The constructor definitions are as follows:",'3109,'66.69921875
'205,'Text 2126,"'template <typename T> class List { public: class Iterator { public: // EFFECTS: Constructs a past-the-end iterator. Iterator() : node_ptr(nullptr) {}",'3110,'39.74609375
'205,'Text 2127,"'private: // EFFECTS: Constructs an iterator from the given node pointer. Iterator (Node *node_ptr_in) : node_ptr(node_ptr_in) {} Node *node_ptr; }; };",'3111,'39.37988281
'205,'Text 2128,"'We can now implement begin() and end () member functions in List that return a start and past-the-end iterator, respectively.",'3112,'88.37890625
'205,'Text 2129,"'template <typename T> class List { public: // EFFECTS: Returns an iterator that points to the first element, // or a past-the-end iterator if this list is empty Iterator begin { return Iterator (first) ; } // EFFECTS: Returns a past-the-end literator. Iterator end () { return Iterator () ; } };",'3113,'46.09375000
'205,'Footer 142,"'28.1. Iterator Definition",'3114,'49.41406250
'205,'Page number 202,"'200",'3115,'83.30078125
'206,'Header 192,"'Programming and Data Structures, Release 0.3",'3116,'52.44140625
'206,'Text 2130,"'The begin( function returns an iterator that points to the first element in the list. However, if the list is empty, first is null; this is the representation of a past-the-end iterator, SO begin() returns such an iterator when the list is empty. The end() function returns a default-constructed past-the-end iterator.",'3117,'98.68164063
'206,'Text 2131,"'Unfortunately, the implementation of begin () does not compile:",'3118,'92.43164063
'206,'Text 2132,"'/List.hpp: 122:12: error: calling a private constructor of class 'List<int> : : Iterator' return Iterator (first) ; ^",'3119,'84.86328125
'206,'Text 2133,"'A private member is only accessible from within the scope of the class that defines the member. The private Iterator constructor is a member of Iterator, but it is being accessed from outside the Iterator class. On the other hand, Iterator is within the scope of List, SO it can access private List members such as Node. Thus, a nested class can access private members of the outer class, but not vice versa.",'3120,'96.53320313
'206,'Section header 151,"'28.2 Friend Declarations",'3121,'85.49804688
'206,'Text 2134,"'The solution to the problem above is a friend declaration, in which a class gives an outside entity access to the class's private members.",'3122,'97.21679688
'206,'Text 2135,"'template <typename T> class List { public: class Iterator { friend class List; }; };",'3123,'93.50585938
'206,'Text 2136,"'A friend declaration can appear anywhere directly within a class body, and it tells the compiler that the given entity is allowed to access private members. The entity may be a function or a type; for instance, it is common practice to define the insertion operator as a friend:",'3124,'97.46093750
'206,'Section header 152,"'class Card {",'3125,'37.10937500
'206,'Text 2137,"'private: std: :string rank; std: string suit; friend std: ostream & operator<<(std::ostream &os, const Card &card) ; }; std: ostream & operator<<(std::ostream &os, const Card &card) { return os << card. rank << "" "" of "" << card. suit;",'3126,'94.77539063
'206,'Text 2138,"'}",'3127,'73.56455994
'206,'Text 2139,"'Friendship is given, not taken. For instance, class C may declare F as a friend:",'3128,'94.58007813
'206,'Section header 153,"'friend class F;",'3129,'65.38085938
'206,'Text 2140,"'This allows F to access the private members of C, but it does not allow C to access the private members of F.",'3130,'97.07031250
'206,'Footer 143,"'28.2. Friend Declarations",'3131,'53.02734375
'206,'Page number 203,"'201",'3132,'81.54296875
'207,'Header 193,"'Programming and Data Structures, Release 0.3",'3133,'59.71679688
'207,'Text 2141,"'The friend declaration completes our iterator implementation, SO we can now perform a traversal by iterator:",'3134,'97.31445313
'207,'Text 2142,"'List<int> list; for (int i = 1;i < 5; ++i) { list.push_back(i); } for (List<int>::) Iterator it = list.begin(); it != list.end() ++it) { cout *it << endl; }",'3135,'26.66015625
'207,'Text 2143,"'This is just an abstraction over a loop that uses a node pointer directly:",'3136,'85.69335938
'207,'Text 2144,"'for (Node *node_ptr = list.first; node_ptr != nullptr; node_ptr = node_ptr->next) { cout << node_ptr->datum << endl; }",'3137,'93.16406250
'207,'Text 2145,"'The iterator starts at the first member, just like the traversal using a node pointer. Incrementing the iterator moves it to the next node, the same as in the loop above. Dereferencing the iterator accesses the respective node's datum member, as in the body of the loop above. The traversal ends when the iterator reaches a null pointer, just like the node-pointer loop. Thus, the iterator provides the same traversal as can be done from within the List template, but with the interface of a pointer rather than having the user rely on implementation details.",'3138,'96.19140625
'207,'Section header 154,"'28.3 Generic Iterator Functions",'3139,'84.32617188
'207,'Text 2146,"'Iterators provide a common interface for traversing through a sequence of elements, and the standard-library sequences all support the iterator interface.",'3140,'97.07031250
'207,'Text 2147,"'vector<int> vec = 1, 2, 3, 4 }; for (vector<int>::iterator it = vec.begin(); it != vec.end(); ++it) { cout << *it << endl; }",'3141,'94.87304688
'207,'Text 2148,"'The common interface allows us to write generic functions that work on any sequence. For instance, we can write a function template for finding the maximum element in a sequence:",'3142,'95.36132813
'207,'Text 2149,"'// REQUIRES: end is after or equal to begin // EFFECTS: Returns an iterator to the maximum element in [begin, end). // Returns begin when the sequence is empty. template <typename Iter_type> Iter_type max_element (Iter_type begin, Iter_type end) { Iter_type max_so_far = begin; for (; begin != end; ++begin) { if (*max_so_far < *begin) { max_so_far = begin; } } return max_so_far; }",'3143,'95.94726563
'207,'Text 2150,"'The max_element() function template takes a begin and end iterator of any type and returns an iterator to the max- imum element that is between the two iterators. As is standard in C++, the end iterator is an exclusive bound - the",'3144,'93.35937500
'207,'Footer 144,"'28.3. Generic Iterator Functions",'3145,'63.76953125
'207,'Page number 204,"'202",'3146,'79.58984375
'208,'Header 194,"'Programming and Data Structures, Release 0.3",'3147,'59.71679688
'208,'Text 2151,"'function stops when it reaches end and does not dereference it. Then max_element () implements a standard find- the-max algorithm: start with the first element as the maximum SO far, then update the max SO far when a larger item is encountered. The iterators must be dereferenced to get to the elements to compare them, and the element type must support the < operator.",'3148,'99.16992188
'208,'Text 2152,"'We can use max_element () with any iterator and element type, as long as the element type supports <:",'3149,'96.92382813
'208,'Key value 40,"",'3150,'48.24218750
'208,'Text 2153,"'As usual with function templates, the compiler deduces the template parameter from the function arguments. The last example illustrates that we can even use max_element() with an array; since a pointer has the same interface as an iterator, we just need to provide max_element() with a pointer to the first element and another that is just past the end.",'3151,'95.80078125
'208,'Text 2154,"'The standard <algorit library contains many function templates such as std: :max_element () that operate on iterators. However, the standard-library function templates require an iterator to define several member type aliases to work:",'3152,'96.09375000
'208,'Text 2155,"'template <typename T> class List { public: class Iterator { public: using iterator_category = std: : input_iterator_tag; using value_type = T; using difference_type = void; using pointer = void; using reference = &; }; };",'3153,'94.09179688
'208,'Text 2156,"'A discussion of these type aliases is beyond the scope of this course.",'3154,'90.47851563
'208,'Text 2157,"'As another example, the following is a function template that determines whether a sequence contains a duplicate item. It compares every pair of elements with the == operator to determine if any are equal:",'3155,'96.87500000
'208,'Text 2158,"'template <typename Iter_type> bool no_duplicates (Iter_type begin, Iter_type end) { for (; begin != end; ++begin)",'3156,'88.62304688
'208,'Text 2159,"'(continues on next page)",'3157,'84.03320313
'208,'Footer 145,"'28.3. Generic Iterator Functions",'3158,'50.78125000
'208,'Page number 205,"'203",'3159,'81.64062500
'209,'Header 195,"'Programming and Data Structures, Release 0.3",'3160,'67.04101563
'209,'Text 2160,"'(continued from previous page)",'3161,'93.06640625
'209,'Text 2161,"'Iter_type other = begin; ++other; for (; other != end; ++other) { if (*begin == *other) { return false; } } } return true;",'3162,'63.33007813
'209,'Text 2162,"'// copy iterator to current element // move copy one element forward // compare element with those that come after",'3163,'74.16992188
'209,'Text 2163,"'}",'3164,'86.69935608
'209,'Section header 155,"'28.4 Iterator Invalidation",'3165,'69.09179688
'209,'Text 2164,"'Recall that a dangling pointer points to an invalid object, one that is no longer alive. Since iterators represent indirection to sequence elements, an iterator can also end up pointing to an invalid object. Such an iterator is said to be invalidated. The following is an example:",'3166,'96.63085938
'209,'Text 2165,"'List<int> list; list.push_back(3) list.push_back(-5) list.push_back(2) list.push_back(4) List<int>::Iterator iter = list.begin() ; cout *iter << endl; list.pop_front() // invalidates iter cout << *iter << endl; // UNDEFINED BEHAVIOR",'3167,'91.30859375
'209,'Text 2166,"'The code constructs a list and inserts elements into it. It then creates an iterator that is pointing to the first element before proceeding to remove that element. This invalidates the iterator, SO that dereferencing the iterator results in undefined behavior.",'3168,'97.60742188
'209,'Text 2167,"'In general, modifying a sequence can invalidate existing iterators. An iterator may be invalidated even if the element it is pointing to is not removed. For instance, a vector iterator is invalidated when a grow operation occurs, since the element the iterator is pointing to moves to a different location. A member function's documentation should indicate whether it may invalidate iterators, as in the cppreference.com documentation for std: vector: : push_back():",'3169,'97.50976563
'209,'Text 2168,"'If the new size () is greater than capacity () then all iterators and references (including the past-the-end iterator) are invalidated. Otherwise only the past-the-end iterator is invalidated.",'3170,'93.94531250
'209,'Footer 146,"'28.4. Iterator Invalidation",'3171,'60.74218750
'209,'Page number 206,"'204",'3172,'82.91015625
'210,'Header 196,"'Programming and Data Structures, Release 0.3",'3173,'59.81445313
'210,'Figure 81,"",'3174,'98.73046875
'210,'Text 2169,"'Figure 28.4: Removing the element that an iterator is pointing to invalidates the iterator.",'3175,'89.89257813
'210,'Section header 156,"'28.5 Type Deduction",'3176,'86.27929688
'210,'Text 2170,"'Suppose we wanted to write a function template that prints out the elements of a sequence. We could write it to work with iterators:",'3177,'97.31445313
'210,'Text 2171,"'template <typename Iter_type> void print_all(Iter_type begin, Iter_type end) for (Iter_type it = begin; it != end; ++it) cout << *it << endl; } }",'3178,'97.36328125
'210,'Text 2172,"'On the other hand, we desire an interface that works directly on a sequence container:",'3179,'96.92382813
'210,'Text 2173,"'template <typename Sequence> void print_all (const Sequence &sequence) { for (typename Sequence : Iterator it = sequence.begin() it!=sequence.end() ++it) { cout << *it << endl; } }",'3180,'98.29101563
'210,'Text 2174,"'Declaring the iterator type is very verbose, as it consists of both a qualified name and the typename keyword, since the qualified name is a dependent type. Furthermore, the declaration makes the assumption that the iterator type is named Iterator, which is not true for standard-library containers that use lower-case type names.",'3181,'97.21679688
'210,'Text 2175,"'Rather than writing out the type of it explicitly, we can ask the compiler to deduce it for us by using the auto keyword:",'3182,'94.09179688
'210,'Text 2176,"'template <typename Sequence> void print_all (const Sequence &sequence) { for (auto it = sequence.begin(); it != sequence. end () ; ++it) { cout *it << endl;",'3183,'92.23632813
'210,'Text 2177,"'(continues on next page)",'3184,'76.61132813
'210,'Footer 147,"'28.5. Type Deduction",'3185,'57.27539063
'210,'Page number 207,"'205",'3186,'81.15234375
'211,'Header 197,"'Programming and Data Structures, Release 0.3",'3187,'56.00585938
'211,'Text 2178,"'(continued from previous page)",'3188,'61.13281250
'211,'Text 2179,"'}",'3189,'43.57910156
'211,'Text 2180,"'}",'3190,'46.58203125
'211,'Text 2181,"'The compiler deduces the type from its initialization. If the return type of sequence. . begin O is List<int> : : Iterator, then the type of it is deduced to have type List<int>: : Iterator. On the other hand, if the return type is vector<Duck> : : iterator, then the type of it is deduced to be vector<Duck> : : iterator. The return type need not be a nested type; if it is char *, then it will be deduced to have type char *. Thus, not only does type deduction save us keystrokes for complicated types, it also abstracts over how the types are defined.",'3191,'89.30664063
'211,'Footer 148,"'28.5. Type Deduction",'3192,'75.58593750
'211,'Page number 208,"'206",'3193,'50.97656250
'212,'Title 48,"'Part IV",'3194,'38.40332031
'212,'Text 2182,"'Functional Programming",'3195,'25.26855469
'212,'Page number 209,"'207",'3196,'78.71093750
'213,'Header 198,"'CHAPTER",'3197,'39.50195313
'213,'Header 199,"'TWENTYNINE",'3198,'43.67675781
'213,'Title 49,"'FUNCTION OBJECTS",'3199,'65.13671875
'213,'Text 2183,"'Last time, we saw iterators, which are a common interface for traversing over the elements of a sequence. For instance, the following function template works over any sequence of integers, determining if there is and odd element in the sequence:",'3200,'98.38867188
'213,'Text 2184,"'// REQUIRES: begin is before or equal to end // EFFECTS: Returns true if any element in the sequence // [begin, end) is odd. template <typename Iter_type> bool _of_odd(Iter_type begin, Iter_type end) { for (Iter_type = begin; it != end; ++it) { if (*it % 2 !=0) return true; } } return false; }",'3201,'94.97070313
'213,'Text 2185,"'We can then use any_of_odd() with any sequence type, as long as the elements are integers:",'3202,'88.57421875
'213,'Text 2186,"'List<int> list; vector<int> vec; int array[10]; cout << any_of_odd(list.begin(), , list.end()) << endl; cout << any_of_odd(vec.begin(), vec.end()) << endl; cout << any_of_odd(array, array + 10)) << endl;",'3203,'94.97070313
'213,'Text 2187,"'The template is generic over the iterator type, but it is not generic over the condition that an element must meet - it only searches for odd elements and no other characteristic. Suppose we wanted instead to determine whether the sequence contains an even element. We could write an any_of_even() template:",'3204,'96.72851563
'213,'List 68,"",'3205,'34.15527344
'213,'Text 2188 - Part of List 68,"'// REQUIRES: begin is before or equal to end // EFFECTS: Returns true if any element in the sequence // [begin, end) is even.",'3206,'46.77734375
'213,'Text 2189 - Part of List 68,"'template <typename Iter_type> bool y_of_even(Iter_type begin, Iter_type end) { for (Iter_type begin; it != end; ++it) { if (*it % 2 == 0) return true;",'3207,'40.03906250
'213,'Text 2190 - Part of List 68,"'}",'3208,'25.41503906
'213,'Text 2191 - Part of List 68,"'}",'3209,'30.20019531
'213,'Text 2192,"'(continues on next page)",'3210,'80.81054688
'213,'Page number 210,"'208",'3211,'81.05468750
'214,'Header 200,"'Programming and Data Structures, Release 0.3",'3212,'73.33984375
'214,'Text 2193,"'(continued from previous page)",'3213,'47.07031250
'214,'Title 50,"'return false;",'3214,'27.83203125
'214,'Text 2194,"'}",'3215,'33.93554688
'214,'Text 2195,"'This code is almost exactly the same as that for any_of_odd(); the only difference is the computation done in the test of the conditional. Most of the code is duplicated, which is undesirable. Furthermore, if we wanted to determine whether a sequence contained an element that met some other condition, say whether an element is positive, we would have to write additional function templates that duplicate code.",'3216,'97.99804688
'214,'Text 2196,"'Our general strategy for avoiding code duplication in a procedural abstraction is to introduce parameters for the pieces that differ. For a value that differs, we add a function parameter:",'3217,'94.67773438
'214,'Table 70,"",'3218,'29.78515625
'214,'Text 2197,"'When it is a type that differs, we make the function a template and introduce a template parameter:",'3219,'81.64062500
'214,'Text 2198,"'int max_int (int X, { returnx<yy:x; } Card max_card(const Card &x, const Card &y) { returnx<yyx } template <typename T> // add template parameter to generalize T max (const T &x, const T &y) { // pass objects of template-parameter type",'3220,'53.22265625
'214,'Text 2199,"'(continues on next page)",'3221,'59.81445313
'214,'Page number 211,"'209",'3222,'85.00976563
'215,'Header 201,"'Programming and Data Structures, Release 0.3",'3223,'61.23046875
'215,'Text 2200,"'(continued from previous page)",'3224,'51.26953125
'215,'Text 2201,"'// by reference return . x y y y y x x } int main() { cout << max (3, -1) << endl: ; // template parameter deduced from arguments cout max(Card(Card: : RANK_TWO, Card: : SUIT_SPADES), Card(Card: : RANK_TOW, Card: : SUIT_HEARTS)) << endl ; }",'3225,'56.29882813
'215,'Text 2202,"'For a generic any _of(), however, it is an actual computation that differs: *it % 2 != 0 for odd numbers, *it % 2 0 for even numbers, *it > 0 for positive numbers, and SO on. We can use a function to represent such a computation:",'3226,'88.62304688
'215,'Table 71,"",'3227,'26.70898438
'215,'Text 2203,"'Once we have a function, the compiler translates it into machine code, which is placed in memory in the text segment when the program runs.",'3228,'95.16601563
'215,'Text 2204,"'Since the code is in memory, we can construct a pointer to it:",'3229,'87.84179688
'215,'Text 2205,"'bool (* func) (int) = &is_odd; func = &is_even;",'3230,'80.41992188
'215,'Text 2206,"'As the examples above demonstrate, we can apply the address-of operator to a function to obtain its address, just like for an object. Unlike an object, however, the address-of operator is optional:",'3231,'97.16796875
'215,'Text 2207,"'func = is_positive;",'3232,'93.84765625
'215,'Text 2208,"'The compiler implicitly inserts the operator for us.",'3233,'95.01953125
'215,'Text 2209,"'We can call a function through a pointer by first dereferencing the pointer:",'3234,'94.58007813
'215,'Text 2210,"'bool (*func) (int) = is_odd; (*func) (-2) ; // returns false",'3235,'86.81640625
'215,'Text 2211,"'Like with the address-of operator, the compiler can implicitly insert this dereference for us:",'3236,'94.23828125
'215,'Text 2212,"'func(-2);",'3237,'51.26953125
'215,'Text 2213,"'// returns false",'3238,'54.29687500
'215,'Page number 212,"'210",'3239,'87.84179688
'216,'Header 202,"'Programming and Data Structures, Release 0.3",'3240,'59.37500000
'216,'Text 2214,"'Stack (grows down)",'3241,'97.07031250
'216,'Figure 82,"",'3242,'85.15625000
'216,'Text 2215,"'THE BIG VOID",'3243,'37.10937500
'216,'Figure 83,"",'3244,'95.70312500
'216,'Text 2216,"'Heap (grows up)",'3245,'81.98242188
'216,'Text 2217,"'Static Storage (Fixed size)",'3246,'78.22265625
'216,'Text 2218,"'Text (The program)",'3247,'83.98437500
'216,'Text 2219,"'Address 0",'3248,'53.32031250
'216,'Text 2220,"'Address MAX",'3249,'75.48828125
'216,'Text 2221,"'Figure 29.1: The memory for a program includes a segment that stores the program's code.",'3250,'95.45898438
'216,'Section header 157,"'29.1 Function-Pointer Types",'3251,'81.93359375
'216,'Text 2222,"'Before we proceed to implement a generic any_of(), let us examine the syntax of a function pointer more closely.",'3252,'97.26562500
'216,'Text 2223,"'bool *func) (int)",'3253,'77.73437500
'216,'Text 2224,"'C++ declarations are generally read from right to left. However, the parentheses around *func associate the * symbol with the name func. Without the parentheses, we would have the following:",'3254,'96.38671875
'216,'Text 2225,"'bool func2 (int) ;",'3255,'72.80273438
'216,'Text 2226,"'This is a declaration of a function called func2 that takes in an int and returns a pointer to a bool - the * is associated with the return type rather than the name func2.",'3256,'94.77539063
'216,'Text 2227,"'With the parentheses, the * has the same meaning as for other variables: it indicates that the variable we are declaring is a pointer. Thus, func is a pointer. The rest of the declaration tells us what kind of pointer it is: a pointer to a function that takes an int as a parameter and returns a bool.",'3257,'94.43359375
'216,'Text 2228,"'To declare an appropriate function pointer, we can use the following steps:",'3258,'90.77148438
'216,'List 69,"",'3259,'34.47265625
'216,'Text 2229 - Part of List 69,"'Start with a function signature:",'3260,'92.23632813
'216,'Text 2230 - Part of List 69,"'int max_int (int X, int y)",'3261,'91.30859375
'216,'Text 2231 - Part of List 69,"'Remove the parameter names, which serve only as documentation in a declaration:",'3262,'93.94531250
'216,'Text 2232 - Part of List 69,"'int max_int (int, int) ;",'3263,'87.35351563
'216,'Footer 149,"'29.1. Function-Pointer Types",'3264,'77.53906250
'216,'Page number 213,"'211",'3265,'84.42382813
'217,'Header 203,"'Programming and Data Structures, Release 0.3",'3266,'90.03906250
'217,'Text 2233,"'Replace the function name with a variable name and the * symbol to indicate it is a pointer, surrounded by parentheses:",'3267,'98.97460938
'217,'Text 2234,"'int (*func3) (int, int) ;",'3268,'84.52148438
'217,'Text 2235,"'The result is that func3 is a pointer to a function that takes two ints and returns an int.",'3269,'96.97265625
'217,'Section header 158,"'29.2 Function-Pointer Parameters",'3270,'81.68945313
'217,'Text 2236,"'We can now write a generic any_of() that is parameterized both by an iterator type as well as a function to test an element:",'3271,'96.63085938
'217,'Section header 159,"'template <typename Iter_type>",'3272,'43.31054688
'217,'Text 2237,"'bool any_of(Iter_type begin, Iter_type end, bool (*func) (int)) { for (Iter_type it = begin; it ! = end; ++it) { if (func(*it)) { return true; } } return false; }",'3273,'96.58203125
'217,'Text 2238,"'Since different iterators may have different types, we use a template parameter to allow an arbitrary kind of iterator. For the test of whether an element satisfies a condition, we add a function parameter that is a pointer to a function. We call it using parentheses like any other function, and the compiler automatically dereferences the pointer to get to its code.",'3274,'96.97265625
'217,'Text 2239,"'We can then specify which function to use when calling any_of():",'3275,'90.42968750
'217,'Text 2240,"'List<int> list; vector<int> vec; int array[10]; cout << any_of(list.begin() list.end(), is_odd) << endl; cout << any_of(vec.begin(), vec.end(), is_even) << endl; cout << any_of(array, array + 10, is_positive)) << endl;",'3276,'92.08984375
'217,'Text 2241,"'The compiler implicitly takes the address of a function when we pass it to a function pointer.",'3277,'87.98828125
'217,'Text 2242,"'Functions that take in an item and return a truth value are quite common, and they are called predicates. Thus, a better name for the function-pointer parameter in any_of() would be pred rather than func.",'3278,'96.43554688
'217,'Text 2243,"'// REQUIRES: begin is before or equal to end // EFFECTS: Returns true if pred returns true when applied to at // least one element in the sequence [begin, end). template <typename Iter_type> bool any_of(Iter_type begin, Iter_type end, bool (*pred) (int)) { for (Iter_type it = begin; it != end; ++it) { if (pred(*it)) { return true; } } return false; }",'3279,'94.09179688
'217,'Footer 150,"'29.2. Function-Pointer Parameters",'3280,'68.84765625
'217,'Page number 214,"'212",'3281,'86.32812500
'218,'Header 204,"'Programming and Data Structures, Release 0.3",'3282,'71.87500000
'218,'Title 51,"'29.3 Functors",'3283,'49.12109375
'218,'Text 2244,"'With any_of() and is_positive(), we can determine whether a sequence contains an element that is greater than zero. What if we are interested in other thresholds, such as 32 or 212? We don't want to write separate functions for each value, as this duplicates code:",'3284,'97.99804688
'218,'Section header 160,"'bool greater32(intx)",'3285,'34.03320313
'218,'Text 2245,"'return X > 32; }",'3286,'26.63574219
'218,'Text 2246,"'bool greater212(intx) { return X > 212; }",'3287,'77.19726563
'218,'Text 2247,"'Since what differs is just a value, we can write a function that has a parameter for the threshold value:",'3288,'94.48242188
'218,'Text 2248,"'bool greater (int X, int threshold) { return X > threshold; }",'3289,'79.49218750
'218,'Text 2249,"'Unfortunately, we cannot use this with any_of(): it requires a pointer to a function that takes in one argument, not two:",'3290,'93.94531250
'218,'Text 2250,"'main. cpp: 29:11: error: no matching function for call to 'any_of' cout << any_of(arr, arr + SIZE, greater) << endl; ^~NNN~ main. cpp: 13:6: note: candidate function not viable: no known conversion from 'bool (int, int) to 'bool (*) (int) for 3rd argument bool any_of(Iter_type begin, Iter_type end, bool (*pred) (int)) { 1 error generated.",'3291,'91.25976563
'218,'Text 2251,"'Furthermore, we need some way of specifying the threshold, and passing the greater() function directly to any_of() does not do SO. What we need is something that internally stores the threshold value and is callable with just one argument.",'3292,'95.50781250
'218,'Text 2252,"'More specifically, we want a first-class entity, which is an entity that supports the following:",'3293,'90.96679688
'218,'List 70,"",'3294,'91.16210938
'218,'Text 2253 - Part of List 70,"'It can store state.",'3295,'95.16601563
'218,'Text 2254 - Part of List 70,"'It can be created at runtime.",'3296,'94.33593750
'218,'Text 2255 - Part of List 70,"'It can be passed as an argument or returned from a function.",'3297,'95.41015625
'218,'Text 2256,"'Unfortunately, functions are not first-class entities in C++: they cannot be created at runtime, and they are very limited in how they can store information.",'3298,'92.18750000
'218,'Text 2257,"'Class types, on the other hand, do define first-class entities. A class-type object can store state in member variables, can be created at runtime, and can be passed between functions. So a class type could satisfy our needs, as long as there were a way to call it like a function. In fact, C++ does allow a class-type object to be called if the class overloads the function-call operator. We refer to such a class as a functor.",'3299,'95.21484375
'218,'Text 2258,"'A functor is a class type that provides the same interface as a function, much like an iterator is a class type that provides the same interface as a pointer. The following is a GreaterN class that stores a threshold and is also callable with a single argument:",'3300,'93.21289063
'218,'Text 2259,"'1 A function may have a static local variable, but it can only store a single value at a time. We need an arbitrary amount of storage - for instance, we may have any number of threshold values we care about for greater (), SO we need a way of creating multiple copies of the function that each have their own stored threshold value.",'3301,'85.83984375
'218,'Footer 151,"'29.3. Functors",'3302,'66.01562500
'218,'Page number 215,"'213",'3303,'80.76171875
'219,'Title 52,"'Programming and Data Structures, Release 0.3",'3304,'40.55175781
'219,'Text 2260,"'class GreaterN { public: // EFFECTS: Creates a GreaterN with the given threshold. GreaterN(int threshold_in) : threshold(threshold_in) {} // EFFECTS: Returns whether or not the given value is greater than // this GreaterN's threshold. bool operator()(int x) const { return X > threshold; } private: int threshold; };",'3305,'45.80078125
'219,'Text 2261,"'The function-call operator must be overloaded as a member function, SO it has an implicit this pointer that allows us to access a member variable. We have declared the this pointer as a pointer to const, since the function does not modify the GreaterN object. We also get to decide what the parameters are, as well as the return type. We have chosen a single parameter of type int and a bool return type, since we want a GreaterN object to act as a predicate on ints.",'3306,'92.67578125
'219,'Text 2262,"'We can create and use GreaterN objects as follows:",'3307,'66.01562500
'219,'Table 72,"",'3308,'78.46679688
'219,'Text 2263,"'We have declared GreaterN objects as local variables and initialized them by calling the constructor, the same as other class-type objects. We can then use a GreaterN object as the first operand of the function-call operator. We pass whatever arguments are needed to invoke the overloaded member function, and as with any non-static member function, the this parameter is implicitly passed.",'3309,'96.19140625
'219,'Text 2264,"'A GreaterN object provides the same interface as the functions required by any_of() However, it is not a function or a pointer to a function; its type is GreaterN, and it cannot be passed to the version of any_of() we wrote previously. Instead, we need to write a new version that allows predicates of any type. Since it is a type that differs, we add a template parameter to refer to that type:",'3310,'97.31445313
'219,'Text 2265,"'// REQUIRES: begin is before or equal to end // EFFECTS: Returns true if pred returns true when applied to at // least one element in the sequence [begin, end). template <typename Iter_type, typename Predicate> bool any_of(Iter_type begin, Iter_type end, Predicate pred) { for (Iter_type it = begin; it != end; ++it) { if (pred(*it)) {",'3311,'89.89257813
'219,'Text 2266,"'(continues on next page)",'3312,'81.83593750
'219,'Footer 152,"'29.3. Functors",'3313,'72.11914063
'219,'Page number 216,"'214",'3314,'87.01171875
'220,'Header 205,"'Programming and Data Structures, Release 0.3",'3315,'51.75781250
'220,'Figure 84,"",'3316,'81.98242188
'220,'Text 2267,"'Stack",'3317,'81.25000000
'220,'Text 2268,"'Figure 29.2: Invoking the overloaded function-call operator of a GreaterN object.",'3318,'94.97070313
'220,'Text 2269,"'(continued from previous page)",'3319,'94.04296875
'220,'Text 2270,"'return true; } } return false; }",'3320,'88.37890625
'220,'Text 2271,"'Like iterators, functors are generally passed by value. We can now use any_of() with a GreaterN object:",'3321,'96.09375000
'220,'Text 2272,"'List<int> list; // fill list with numbers GreaterN greater0(0) cout << any_of(list.begin(), list.end(), greater0); // pass existing functor cout << any_of(list.begin() list.end(), GreaterN(32)) // pass temporary functor",'3322,'94.04296875
'220,'Text 2273,"'The compiler deduces the template parameter Iter_type as List<int>: Iterator, and the parameter Predicate as GreaterN. We can still call any_of() with a function pointer:",'3323,'96.82617188
'220,'Text 2274,"'cout << any_of(list.begin(), list.end(), is_odd) // pass function",'3324,'52.14843750
'220,'Text 2275,"'In this case, the compiler deduces Predicate as the function-pointer type bool (*) (int).",'3325,'93.21289063
'220,'Text 2276,"'By parameterizing any_of() with the predicate type, we can now call it on sequences of objects that are of types other than int. As long as a sequence element can be passed to the predicate, the code will work.",'3326,'95.70312500
'220,'Text 2277,"'bool is_empty(const string &s) return s.empty(); }",'3327,'52.83203125
'220,'Text 2278,"'(continues on next page)",'3328,'82.03125000
'220,'Footer 153,"'29.3. Functors",'3329,'51.85546875
'220,'Page number 217,"'215",'3330,'85.98632813
'221,'Header 206,"'Programming and Data Structures, Release 0.3",'3331,'81.34765625
'221,'Text 2279,"'(continued from previous page)",'3332,'43.21289063
'221,'Header 207,"'int main() { vector<string> vec; // fill vec with strings cout << any_of(vec.begin(), vec.end(), is_empty) }",'3333,'44.26269531
'221,'Text 2280,"'Exercise 1 Write a function list_count() that counts the number of elements in a list for which the given predicate returns true. Assume that Node is defined as",'3334,'81.25000000
'221,'Text 2281,"'struct Node { int datum; Node *next; };",'3335,'90.96679688
'221,'Text 2282,"'and use recursion to traverse the sequence of nodes.",'3336,'90.13671875
'221,'Text 2283,"'// EFFECTS: Returns the number of elements in the list that // starts at the given node for which the predicate // returns true. template <typename Predicate> int last (const Node *node, Predicate pred) { // your code here }",'3337,'92.72460938
'221,'Section header 161,"'29.4 Comparators",'3338,'79.19921875
'221,'Text 2284,"'Recall the max_element () function template from last time:",'3339,'83.83789063
'221,'Text 2285,"'// REQUIRES: end is after or equal to begin // EFFECTS: Returns an iterator to the maximum element in [begin, end). // Returns begin when the sequence is empty. template <typename Iter_type> Iter_type max_element (Iter_type begin, Iter_type end) { Iter_type max_so_far = begin; for (; begin != end; ++begin) { if (*max_so_far < *begin) { max_so_far = begin; } } return max_so_far; }",'3340,'94.62890625
'221,'Text 2286,"'The function template uses the < operator to compare elements, SO it only works on types that provide that operator. It will not work with a type such as Duck that does not overload the less-than operator. However, we may still want to compare Ducks according to some criteria, such as by their names or their ages. Thus, we need a way of specifying how max_element () should compare objects. We can do SO by adding another parameter to represent a comparator, which takes two objects and returns a value that indicates how they compare to each other.",'3341,'94.97070313
'221,'Text 2287,"'// REQUIRES: end is after or equal to begin // EFFECTS: Returns an iterator to the maximum element in [begin, end)",'3342,'44.65332031
'221,'Text 2288,"'(continues on next page)",'3343,'54.58984375
'221,'Footer 154,"'29.4. Comparators",'3344,'58.98437500
'221,'Page number 218,"'216",'3345,'89.89257813
'222,'Title 53,"'Programming and Data Structures, Release 0.3",'3346,'44.26269531
'222,'Text 2289,"'(continued from previous page)",'3347,'79.24804688
'222,'Text 2290,"'// according to the given comparator. Returns begin when // the sequence is empty. template <typename Iter_type typename Comparator> Iter_type max_element (Iter_type begin, Iter_type end, Comparator less) { Iter_type max_so_far = begin; for (; begin != end; ++begin) { if (less (*max_so_far, *begin)) { max_so_far = begin; } } return max_so_far; }",'3348,'90.82031250
'222,'Text 2291,"'Standard comparators in C++ do a less-than comparison, SO we have modified max_element() to take in such a comparator. The type of the comparator is a template parameter SO that either a functor or a function pointer can be used. The code then calls the comparator with two arguments to determine if the first is less than the second.",'3349,'97.70507813
'222,'Text 2292,"'We can write a Duck comparator that compares two ducks by name:",'3350,'88.62304688
'222,'Text 2293,"'class DuckNameLess { public: bool operator() (const Duck &d1, const Duck &d2) const { return d1.get_name( < d2.get_name(); } };",'3351,'95.99609375
'222,'Text 2294,"'Here, we have written the comparator as a functor; since it doesn't require any storage, it could have been written as a function as well.² We can then call max_element () as follows:",'3352,'96.67968750
'222,'Text 2295,"'vector<Duck> vec; // fill vec with Ducks cout << (*max_element(vec.begin(), vec.end(), DuckNameLessO)).",'3353,'95.60546875
'222,'Text 2296,"'We pass a default-constructed DuckNameLess object as the comparator and get back an iterator to the Duck with the maximum name. We then dereference the iterator to get to the Duck object and call get_name () on it.³",'3354,'96.28906250
'222,'Text 2297,"'Given our modifications to max_element(), we can no longer call it without a comparator argument, even for types that support the < operator. However, the standard <algorithm> library provides a functor template std: : less that just invokes the < operator, SO we can use it with types that do have the operator:",'3355,'97.07031250
'222,'Text 2298,"'vector<int> vec; // fill vec with numbers cout << *max_element(vec.begin(), vec.end(), std::less<int>O)",'3356,'85.98632813
'222,'Text 2299,"'It is also possible to write max_element() to default to using std: : less when a comparator is not explicitly provided, but that is beyond the scope of this course.",'3357,'95.50781250
'222,'Text 2300,"'2 While either a functor or function would work, functors are actually more efficient since calling them does not require any indirection. The compiler can statically determine from the functor type which overloaded operator is called, while calling through a function pointer generally requires a dereference at runtime. Thus, functors are usually preferred over functions given a choice between the two. 3 Standard-library iterators overload the -> operator, SO we could use that operator to call get_name () directly rather than manually applying dereference followed by the dot operator.",'3358,'34.10644531
'222,'Footer 155,"'29.4. Comparators",'3359,'79.24804688
'222,'Page number 219,"'217",'3360,'82.08007813
'223,'Header 208,"'Programming and Data Structures, Release 0.3",'3361,'79.29687500
'223,'Title 54,"'29.5 Iterating over a Sequence",'3362,'47.55859375
'223,'Text 2301,"'Another common pattern is to iterate over a sequence, performing some operation on each element individually. We can write a for_each() function template that implements this pattern, taking in a function pointer or functor that applies to a single element:",'3363,'98.77929688
'223,'Text 2302,"'// REQUIRES: end is after or equal to end // EFFECTS: Applies func to each of the elements in the sequence // [begin, end) and returns func. template <typename Iter_t, typename Func_t> Func_t for_each(Iter_t begin, Iter_t end, Func_t func) { for (Iter_t it = begin; it != end; ++it) { func(*it); } return func; }",'3364,'97.46093750
'223,'Text 2303,"'We return the func argument, in case it contains data that are useful to the caller. For instance, the following functor stores the sum of integer elements:",'3365,'96.58203125
'223,'Text 2304,"'class Accumulator { public: void operator () (int { sum += x; } int get_sum() const { return sum; } private: int sum = 0; };",'3366,'95.06835938
'223,'Text 2305,"'We can then compute the sum of the elements in a sequence:",'3367,'95.16601563
'223,'Text 2306,"'vector<int> vec; // fill vec with numbers Accumulator summer; summer = for_each(vec.begin(), vec.end(), summer) ; cout << summer.get_sum() << endl;",'3368,'97.11914063
'223,'Text 2307,"'To print out the elements in a sequence to a stream, we can write a functor template for printing:",'3369,'95.89843750
'223,'Figure 85,"",'3370,'61.66992188
'223,'Text 2308,"'template <typename T> class Printer { public: Printer(std::ostream &os) : output(os) {}",'3371,'94.23828125
'223,'Text 2309,"'void operator() (const T &item) const { output << item << std: endl; }",'3372,'92.62695313
'223,'Text 2310,"'(continues on next page)",'3373,'86.91406250
'223,'Footer 156,"'29.5. Iterating over a Sequence",'3374,'78.12500000
'223,'Page number 220,"'218",'3375,'85.10742188
'224,'Header 209,"'Programming and Data Structures, Release 0.3",'3376,'42.43164063
'224,'Text 2311,"'(continued from previous page)",'3377,'85.20507813
'224,'Text 2312,"'private:",'3378,'48.24218750
'224,'Text 2313,"'std::ostream &output; };",'3379,'92.77343750
'224,'Text 2314,"'The member variable must be a reference, since streams do not generally support copying. We can then use Printer to print out each element in a sequence:",'3380,'96.77734375
'224,'Text 2315,"'int main() { List<int> list; // fill list with numbers ofstream fout (""list.out""); for_each(list.begin(), list.end(), , Printer<int> (fout)) ;",'3381,'91.79687500
'224,'Text 2316,"'}",'3382,'50.48828125
'224,'Footer 157,"'29.5. Iterating over a Sequence",'3383,'78.32031250
'224,'Page number 221,"'219",'3384,'86.18164063
'225,'Header 210,"'CHAPTER THIRTY",'3385,'43.40820313
'225,'Title 55,"'IMPOSTOR SYNDROME",'3386,'75.83007813
'225,'Text 2317,"'In addition to building our programming skills, it is also important to develop an appropriate awareness of our own abil- ities. Unfortunately, many of us encounter impostor syndrome, where we do not internalize our own accomplishments. Despite demonstrating success in a course like this, we often fear being exposed as a ""fraud.""",'3387,'93.11523438
'225,'Text 2318,"'Recognizing impostor syndrome is the first step to overcoming it. The following are common characteristics of people who have impostor syndrome:",'3388,'92.23632813
'225,'List 71,"",'3389,'85.40039063
'225,'Text 2319 - Part of List 71,"'They attribute their success to external factors.",'3390,'96.09375000
'225,'Text 2320 - Part of List 71,"'They fear being revealed as a fraud.",'3391,'95.45898438
'225,'Text 2321 - Part of List 71,"'They convince themselves that they are not good enough.",'3392,'96.38671875
'225,'Text 2322 - Part of List 71,"'They have a hard time accepting compliments for their accomplishments.",'3393,'95.26367188
'225,'Text 2323,"'Impostor syndrome differs from implicit bias in that the latter affects how we subconsciously view others, while the former affects how we view ourselves. The National Center for State Courts defines implicit bias as:",'3394,'88.86718750
'225,'Text 2324,"'The bias in judgment and/or behavior that results from subtle cognitive processes (e.g., implicit attitudes and stereotypes) that often operate at a level below conscious awareness and without intentional control.",'3395,'76.26953125
'225,'Text 2325,"'Of course, these implicit attitudes also affect how we view ourselves, SO even though impostor syndrome affects every- one, it tends to have a higher effect on people in underrepresented groups.",'3396,'89.20898438
'225,'Text 2326,"'The result of impostor syndrome is to doubt ourselves, having feelings such as:",'3397,'91.45507813
'225,'List 72,"",'3398,'85.20507813
'225,'Text 2327 - Part of List 72,"'""I was hired to fill a diversity quota.""",'3399,'95.89843750
'225,'Text 2328 - Part of List 72,"'""Everyone else seems smarter than me.""",'3400,'96.24023438
'225,'Text 2329 - Part of List 72,"'""If I'm not getting an A, how am I going to survive in future courses?""",'3401,'97.21679688
'225,'Text 2330 - Part of List 72,"'""Nobody else here is like me - I don't belong in this class"".",'3402,'95.50781250
'225,'Text 2331 - Part of List 72,"'""I don't like asking questions in class because I'm afraid others will realize I don't know what I'm doing.""",'3403,'96.19140625
'225,'Text 2332 - Part of List 72,"'""Maybe EECS isn't for me; I should drop.""",'3404,'94.33593750
'225,'Text 2333,"'The truth is that almost everyone suffers from feelings like this. Surveys on impostor syndrome have found that ""about 70 percent of people from all walks of life - men and women - have felt like impostors for at least some part of their careers.""4 The likelihood is that many of us are experiencing this right now, in this course.",'3405,'95.36132813
'225,'Text 2334,"'There are steps we can take to overcome impostor syndrome:",'3406,'89.45312500
'225,'List 73,"",'3407,'86.71875000
'225,'Text 2335 - Part of List 73,"'Stop comparing ourselves to others.",'3408,'96.19140625
'225,'Text 2336 - Part of List 73,"'Encourage each other.",'3409,'94.04296875
'225,'Text 2337 - Part of List 73,"'Join student organizations and connect with other students.",'3410,'95.84960938
'225,'Text 2338,"'4 Gravois, J. (2007). You're not fooling anyone. The Chronicle of Higher Education, 54(11), A1.",'3411,'51.85546875
'225,'Page number 222,"'220",'3412,'74.41406250
'226,'Header 211,"'Programming and Data Structures, Release 0.3",'3413,'65.57617188
'226,'List 74,"",'3414,'85.69335938
'226,'Text 2339 - Part of List 74,"'Accept our accomplishments.",'3415,'97.90039063
'226,'Text 2340 - Part of List 74,"'Find a mentor.",'3416,'97.50976563
'226,'Text 2341,"'We do not have to experience this alone; instead, we should support each other and find others we can lean on.",'3417,'88.33007813
'226,'Text 2342,"'The following are additional resources on impostor syndrome:",'3418,'80.12695313
'226,'List 75,"",'3419,'94.28710938
'226,'Text 2343 - Part of List 75,"'University of Michigan CAPS page on impostor syndrome",'3420,'97.41210938
'226,'Text 2344 - Part of List 75,"'TED talk on how students of color confront impostor syndrome",'3421,'97.60742188
'226,'Text 2345 - Part of List 75,"'American Psychological Association article on impostor syndrome",'3422,'97.50976563
'226,'Page number 223,"'221",'3423,'90.23437500
'227,'Text 2346,"'CHAPTER",'3424,'40.30761719
'227,'Text 2347,"'THIRTYONE",'3425,'32.00683594
'227,'Text 2348,"'RECURSION",'3426,'63.18359375
'227,'Text 2349,"'We have seen several forms of abstraction, where we use something for what it does rather than how it works. It can be useful to refer to an abstraction when we are still in the middle of implementing it. For instance, our definition of a linked-list node refers to itself:",'3427,'97.16796875
'227,'Text 2350,"'struct Node { int datum; Node *next; };",'3428,'92.91992188
'227,'Text 2351,"'Such a definition is recursive, where it uses itself as part of its definition.",'3429,'90.23437500
'227,'Text 2352,"'Functions can also be recursive. As an example, consider the factorial of a nonnegative integer:",'3430,'92.67578125
'227,'Text 2353,"'if n = O orn = 1 otherwise",'3431,'83.74023438
'227,'Text 2354,"'We can implement an iterative function to compute this:",'3432,'91.65039063
'227,'Text 2355,"'// REQUIRES n >= ( O // EFFECTS: Computes and returns n! int factorial (int n) { int result = 1; while (n > 0) { result *= n; --n; } return result; }",'3433,'93.75000000
'227,'Text 2356,"'On the other hand, we can observe that (n-1)!=(n-1) ***** * 1, SO that we can mathematically define factorial in terms of itself:",'3434,'92.33398438
'227,'Text 2357,"'if n = Oorn=1 otherwise",'3435,'72.31445313
'227,'Text 2358,"'Such a mathematical definition is called a recurrence relation. It translates into code as follows:",'3436,'95.11718750
'227,'Text 2359,"'// REQUIRES: n >= O // EFFECTS: Computes and returns n! int factorial (int n) { if (n=0n= 1) return 1;",'3437,'87.89062500
'227,'Text 2360,"'(continues on next page)",'3438,'78.90625000
'227,'Page number 224,"'222",'3439,'76.70898438
'228,'Title 56,"'Programming and Data Structures, Release 0.3",'3440,'45.99609375
'228,'Text 2361,"'(continued from previous page)",'3441,'76.12304688
'228,'Text 2362,"'} else { return n * factorial (n - 1); } }",'3442,'63.96484375
'228,'Text 2363,"'This function is recursive, since it calls itself as part of its definition. We can then call factorial () as follows:",'3443,'93.70117188
'228,'Text 2364,"'int main() { int result = factorial (3) cout ""3! = << result << endl; }",'3444,'74.16992188
'228,'Text 2365,"'The activation records created by this program are shown in Figure 31.1.",'3445,'70.80078125
'228,'Figure 86,"",'3446,'83.54492188
'228,'Text 2366,"'Figure 31.1: Activation records for a call to the recursive version of factorial().",'3447,'79.19921875
'228,'Text 2367,"'When the call factorial (3) is evaluated, an activation record is created, and the parameter n is initialized with value 3. The body of factorial () runs, and it calls factorial (2). This creates another activation record, and its param- eter n is initialized to 2. Within the context of that activation record, the body of factorial () is executed, and it calls factorial (1). Another activation record is created, with n initialized to 1. The body runs, returning 1, which replaces the function call in the caller. The activation record for factorial (1) is destroyed, and factorial (2) resumes. The latter computes 2 * 1 and returns 2. The activation record for factorial (2) is destroyed, and factorial (3) con- tinues where it left off. It computes 3 * 2, returning 6. Its activation record is reclaimed, and main() resumes, initializing result to 6, the correct value for 3!.",'3448,'95.41015625
'228,'Text 2368,"'Operationally, the recursive definition works because each invocation of factorial () gets its own activation record, and the body of the function is executed within the context of that activation record. More conceptually, it works by using factorial () as an abstraction, even while we are still in the midst of implementing that abstraction! We call this ""the recursive leap of faith"" - we trust that the abstraction works, even if we haven't finished writing it yet.",'3449,'91.89453125
'228,'Text 2369,"'In general, a recursive abstraction requires the following:",'3450,'71.53320313
'228,'List 76,"",'3451,'84.27734375
'228,'Text 2370 - Part of List 76,"'base cases, which are cases we can implement directly without recursion",'3452,'94.82421875
'228,'Text 2371 - Part of List 76,"'recursive cases, where we break down the problem into subproblems that are similar to the problem but ""smaller,"" meaning closer to a base case",'3453,'93.79882813
'228,'Text 2372,"'As another example, the following recursive function prints out the integers between a start and end:",'3454,'90.86914063
'228,'Page number 225,"'223",'3455,'90.96679688
'229,'Header 212,"'Programming and Data Structures, Release 0.3",'3456,'50.48828125
'229,'Text 2373,"'// REQUIRES: end >= start // MODIFIES: cout // EFFECTS: Prints the numbers in [start, end) in order. void print_numbers (int start, int end) { // base case if (start == end) { return; } // recursive case cout << start << endl; print_numbers (start + 1, end) }",'3457,'84.47265625
'229,'Text 2374,"'The base case is when the start and end are the same, in which case the function immediately returns without printing anything. The recursive case prints out a single number and then recursively computes the subproblem of printing the numbers in [start + 1, end). The latter is smaller than the original problem, since it requires printing out one fewer number.",'3458,'97.94921875
'229,'Text 2375,"'Let us consider another example, that of computing the number of ducks on a duck farm. Suppose the farm starts with five baby ducklings. Assume that a duck lays three eggs each month, once the duck is at least a month old itself. Furthermore, an egg takes a month to hatch, and our ducks never die. How many ducks does the farm have after n months?",'3459,'96.82617188
'229,'Text 2376,"'We start by working out the first few months by hand. In month 0, there are 5 baby ducklings, which are not old enough to lay eggs. In month 1, there are now 5 grown ducks, each of which lays 3 eggs, resulting in 15 eggs in total. Let's use a table to keep track of what we have:",'3460,'95.80078125
'229,'Table 73,"",'3461,'97.94921875
'229,'Text 2377,"'In month 2, the 15 eggs hatch, resulting in 15 ducklings. The 5 adult ducks lay 15 more eggs. In month 3, these eggs hatch, resulting in 15 ducklings. The previous 15 ducklings are now adults, SO that we have a total of 20 adult ducks, which lay 60 eggs. And SO on in months 4 and 5. The total number of ducks is 200 at month 5.",'3462,'96.87500000
'229,'Text 2378,"'We observe that the number of adult ducks in any particular month is the same as the total number of ducks in the previous month. The number of ducklings in a month is three times the number of adult ducks in the previous month, which is the same as the total number of ducks in the month before. This results in the following recurrence relation for the total number of ducks:",'3463,'97.46093750
'229,'Text 2379,"'fn = Oorn=1 -1)+3*ducks(n- 2) otherwise",'3464,'91.16210938
'229,'Text 2380,"'The base cases are the first two months, when there are 5 total ducks. (We cannot apply the recurrence for these cases, since it would rely on the number of ducks in month - -1, which is ill-defined.)",'3465,'97.07031250
'229,'Text 2381,"'We can now write a function to compute the number of ducks:",'3466,'93.31054688
'229,'Text 2382,"'// REQUIRES: O",'3467,'58.59375000
'229,'Text 2383,"'// EFFECTS: Computes the number of ducks in month n, assuming 5",'3468,'59.81445313
'229,'Text 2384,"'(continues on next page)",'3469,'38.81835938
'229,'Page number 226,"'224",'3470,'88.37890625
'230,'Title 57,"'Programming and Data Structures, Release 0.3",'3471,'51.56250000
'230,'Text 2385,"'(continued from previous page)",'3472,'81.15234375
'230,'Text 2386,"'// ducklings to start. int num_ducks(int n) { // base cases if (n <= 1) { return 5; } // recursive case return num_ducks(n - 1) + 3 * num_ducks( (n - 2) ; }",'3473,'75.14648438
'230,'Text 2387,"'Observe that there are two subproblems here, ducks(n - 1) - and ducks (n - 2). Both are closer to a base case than ducks (n), SO the recursive computation still works.",'3474,'95.75195313
'230,'Text 2388,"'Recursive algorithms are not just for math problems. The following is an algorithm for lifting a box of heavy books:",'3475,'91.11328125
'230,'Text 2389,"'void lift_box (Box &box) { if (too_heavy (box)) { // recursive case Book book = remove_book (box) ; lift_box (box) ; // ""smaller"" box add_book( (box, book) ; } else { // base case move_box(box) ; } }",'3476,'64.89257813
'230,'Text 2390,"'Here, the base case is when we can directly move the box, such as when it is empty. Otherwise, we reduce the problem of moving a heavy box to the subproblem of a box with one less book, using recursion to solve that subproblem. We take the recursive leap of faith that the function will correctly solve that subproblem. We then need only add back the book we removed.",'3477,'95.26367188
'230,'Figure 87,"",'3478,'90.57617188
'230,'Text 2391,"'Figure 31.2: Recursive algorithm for lifting a box of heavy books.",'3479,'90.13671875
'230,'Text 2392,"'As another non-math example, we write a recursive function to reverse the contents of an array. For an empty array or an array with one element, nothing needs to be done, constituting the base case. Otherwise, we reverse a smaller array,",'3480,'96.97265625
'230,'Page number 227,"'225",'3481,'84.91210938
'231,'Header 213,"'Programming and Data Structures, Release 0.3",'3482,'44.94628906
'231,'Text 2393,"'one that excludes the ends, and then swap the two ends:",'3483,'90.62500000
'231,'Text 2394,"'// EFFECTS: Reverses the array starting at ""left"" and ending at // (and including) 'right'. void reverse (int *left, int *right) { if (left < right) { reverse(left + 1, right - 1); int temp = *left; *left = *right; *right = temp; } }",'3484,'85.83984375
'231,'Text 2395,"'The function reverses the elements in [left,right]. The subproblem is the set of elements in [left + 1, right - 1], which is closer to the base case of an array with zero or one element. As always, we take the recursive leap of faith that the subproblem will be computed correctly.",'3485,'95.89843750
'231,'Text 2396,"'We can call reverse as follows:",'3486,'89.69726563
'231,'Text 2397,"'int main() { const int SIZE = 8; int array [SIZE] = { 1, 2, 3, 4, 5, 6, 7, 8 }; reverse(array, array + SIZE - 1); // reverse whole array reverse(array + 1, array + 3) // reverse elements 1-3 }",'3487,'43.11523438
'231,'Section header 162,"'31.1 Tail Recursion",'3488,'93.50585938
'231,'Text 2398,"'Consider the efficiency of the reverse function above. For an array of size n, it performs [n/2 swap operations, taking O(n) time. The algorithm also uses O(n) space: each recursive call has an activation record, and there are Ln/2 + 1 total calls.",'3489,'97.50976563
'231,'Text 2399,"'On the other hand, the following iterative algorithm uses only a single activation record, resulting in constant, O(1), space:",'3490,'96.04492188
'231,'Text 2400,"'// EFFECTS: Reverses the array starting at 'left' and ending at // (and including) 'right'. void reverse (int *left, int *right) { while (left < right) { int temp = *left; *left = *right; *right = temp; ++left; --right; } }",'3491,'88.42773438
'231,'Text 2401,"'The fundamental difference is that this algorithm solves the subproblem after doing the extra work for the original problem, i.e. swapping the two ends. An equivalent recursive implementation would be the following:",'3492,'94.43359375
'231,'Text 2402,"'// EFFECTS: Reverses the array starting at 'left' and ending at // (and including) 'right'. void reverse (int *left, int *right) {",'3493,'55.56640625
'231,'Text 2403,"'(continues on next page)",'3494,'76.22070313
'231,'Footer 158,"'31.1. Tail Recursion",'3495,'46.28906250
'231,'Page number 228,"'226",'3496,'79.44335938
'232,'Header 214,"'Programming and Data Structures, Release 0.3",'3497,'64.59960938
'232,'Text 2404,"'(continued from previous page)",'3498,'79.29687500
'232,'Text 2405,"'if (left < right) { int temp *left; *left = *right; *right = temp; reverse(left + 1, right 1) ; } }",'3499,'55.81054688
'232,'Text 2406,"'Here, the recursive call is a tail call, meaning that the call is the last thing that happens in the function, and no work is done after the tail call returns. Since no work is done after the tail call, there is no need to retain the activation record of the caller, and it can be discarded.",'3500,'97.85156250
'232,'Text 2407,"'Many compilers recognize tail calls and perform tail-call optimization (TCO), where the activation record for the tail call reuses the space of the caller's activation record. In the g++ compiler, TCO is enabled at optimization level 2 (-02). TCO is not restricted to recursive functions; as long as a function call is the last thing that happens in its caller, it is a tail call and the optimization can apply. However, tail-call optimization is most important for recursive functions, since it can reduce the space usage of the computation by a large factor.",'3501,'97.07031250
'232,'Text 2408,"'A function is said to be tail recursive if it is recursive, and all recursive calls are tail calls. Rather than using a linear amount of space, a tail-recursive computation requires only constant space when tail-call optimization is applied. For instance, the tail-recursive version of reverse( uses space for only a single activation record under TCO.",'3502,'95.84960938
'232,'Text 2409,"'In order for a computation to be tail recursive, it must do all its work in the active flow of the computation, before making a recursive call. A computation that does its work in the passive flow must wait until a recursive call completes before doing work, SO that the recursive call is not a tail call.",'3503,'96.43554688
'232,'Text 2410,"'As a concrete example, the prior recursive implementation of factorial () is not tail recursive, since it does its work in the passive flow:",'3504,'95.55664063
'232,'Text 2411,"'int actorial(intn) { if E(n=on= 1) { return 1; } else { return n * factorial(r - 1) } }",'3505,'97.85156250
'232,'Text 2412,"'The multiplication must be done after the recursive call returns, SO the function is not tail recursive.",'3506,'93.40820313
'232,'Text 2413,"'For the function to be tail recursive, we need the multiplication to be in the active flow. To do so, we compute n in the initial call to factorial () on N, n * (n - 1) in the call on n - 1, N: * (n - 1) * (n-2) in the call on n - 2, and SO on until we reach 1. At each step, we keep track of the product SO far:",'3507,'98.04687500
'232,'Text 2414,"'int factorial (int n, int resultSoFar) { if(n=0n1){ return resultSoFar; } else { return factorial(n 1, n * resultSoFar) } }",'3508,'97.02148438
'232,'Text 2415,"'To call this function, we need to seed resultSoFar with the multiplicative identity of 1:",'3509,'91.06445313
'232,'Text 2416,"'1 Whether or not a function call is a tail call is not a syntactic property, but is determined by whether or not work must be done after the call returns. For example, if a nontrivial destructor for a local variable must be run after the call returns, the call is not a tail call.",'3510,'56.10351563
'232,'Footer 159,"'31.1. Tail Recursion",'3511,'65.03906250
'232,'Page number 229,"'227",'3512,'46.67968750
'233,'Header 215,"'Programming and Data Structures, Release 0.3",'3513,'50.78125000
'233,'Header 216,"'cout << factorial (5, 1) << endl;",'3514,'44.94628906
'233,'Text 2417,"'However, this is a different interface than our previous versions of factorial(). To retain the same interface, we move the actual computation to a helper function and abstract the call to it:",'3515,'96.67968750
'233,'Text 2418,"'static int factorial_helper(int n, int resultSoFar) { if (n==0n== 1) { return resultSoFar; } else { return factorial_helper(n - 1, n * resultSoFar); } } int factorial (int n) { return factorial_helper( (n, 1) ; }",'3516,'93.16406250
'233,'Text 2419,"'Helper functions are a common pattern for tail-recursive computations that require a seed value. Not all tail-recursive algorithms require a helper function, however; the tail-recursive print_numbers () and reverse () functions above do not need a seed value, SO they work without helper functions.",'3517,'95.11718750
'233,'Section header 163,"'31.2 Kinds of Recursion",'3518,'93.21289063
'233,'Text 2420,"'We have now seen several different kinds of recursion. A function is linear recursive if it is recursive, but each invocation of the function makes at most one recursive call. Such a function reduces each recursive case to a single subproblem. The various recursive factorial () and reverse() functions above are all linear recursive.",'3519,'96.63085938
'233,'Text 2421,"'A function is tail recursive if it is linear recursive, and every recursive call is the last thing that happens in the invocation that makes the recursive call. We have seen both tail-recursive and non-tail-recursive variants of reverse and factorial ().",'3520,'96.24023438
'233,'Text 2422,"'A function is tree recursive if a single invocation of the function can make more than one recursive call. Such a function subdivides a recursive case into multiple subproblems. The num_ducks function above is tree recursive. Drawing out the recursive call graph for a tree-recursive function, we end up with a branching structure that resembles a tree, explaining the nomenclature.",'3521,'96.67968750
'233,'Figure 88,"",'3522,'86.18164063
'233,'Text 2423,"'Figure 31.3: Call structure of a tree-recursive function.",'3523,'83.93554688
'233,'Footer 160,"'31.2. Kinds of Recursion",'3524,'41.57714844
'233,'Page number 230,"'228",'3525,'88.81835938
'234,'Header 217,"'Programming and Data Structures, Release 0.3",'3526,'61.52343750
'234,'Section header 164,"'31.3 Iteration vs. Recursion",'3527,'56.49414063
'234,'Text 2424,"'Iteration and recursion are two approaches to solving complex problems. Conceptually, an iterative algorithm often divides a computation into individual discrete steps, the combination of which forms a solution to the whole problem. In contrast, recursive algorithms generally express a computation in terms of smaller versions of the same problem.",'3528,'97.55859375
'234,'Text 2425,"'Both iteration and recursion have the same computational power; an iterative algorithm can be converted to a tail- recursive implementation and vice versa. A non-tail-recursive computation can also be rewritten iteratively; however, the iterative version may require explicit storage. The non-tail-recursive algorithm can store data in multiple activation records, while the iterative one only has a single activation record to work with, SO it may need an explicit data structure such as a vector to store its data. Techniques such as dynamic programming can be used in general to convert a recursive algorithm to an iterative one, but they are beyond the scope of this course.",'3529,'97.02148438
'234,'Footer 161,"'31.3. Iteration vs. Recursion",'3530,'65.77148438
'234,'Page number 231,"'229",'3531,'80.81054688
'235,'Header 218,"'CHAPTER",'3532,'43.11523438
'235,'Header 219,"'THIRTYTWO",'3533,'48.43750000
'235,'Title 58,"'STRUCTURAL RECURSION",'3534,'83.30078125
'235,'Text 2426,"'Last time, we discussed the concept of recursion, where an abstraction uses itself as part of its implementation, and we saw its application to procedural abstractions. We turn our attention now to structural recursion, where we use recursion in defining the representation of an abstract data type.",'3535,'96.67968750
'235,'Section header 165,"'32.1 Recursive Lists",'3536,'87.10937500
'235,'Text 2427,"'The data representation of a linked list is an example of structural recursion: the Node type uses itself in its own representation:",'3537,'95.45898438
'235,'Text 2428,"'struct Node { int datum; Node *next; };",'3538,'88.52539063
'235,'Text 2429,"'This representation satisfies the requirements for a recursive abstraction:",'3539,'93.01757813
'235,'List 77,"",'3540,'74.31640625
'235,'Text 2430 - Part of List 77,"'The empty list is the base case, represented by a null pointer.",'3541,'96.33789063
'235,'Text 2431 - Part of List 77,"'A non-empty list is a recursive case; it can be subdivided into the first node and the rest of the list, which represents a list in its own right.",'3542,'95.45898438
'235,'Figure 89,"",'3543,'84.27734375
'235,'Text 2432,"'Smaller list",'3544,'44.45800781
'235,'Text 2433,"'Figure 32.1: The representation of a non-empty list consists of a node followed by the representation of a smaller list.",'3545,'95.65429688
'235,'Text 2434,"'Independent of its representation, a linked list can actually be defined recursively as either an empty list, or a datum followed by a smaller list.",'3546,'95.45898438
'235,'Text 2435,"'Given the recursive definition of a list, it is natural to process a list with a recursive function. The base case of the recursive function will be the minimum-size list allowed by the function, and larger lists will be handled in the recursive case. As an example, the following is a recursive function to compute the length of a list:",'3547,'94.67773438
'235,'Page number 232,"'230",'3548,'85.64453125
'236,'Title 59,"'Programming and Data Structures, Release 0.3",'3549,'43.40820313
'236,'Figure 90,"",'3550,'45.89843750
'236,'Text 2436,"'Figure 32.2: Recursive definition of a list.",'3551,'49.12109375
'236,'Text 2437,"'// REQUIRES: node represents a valid list // EFFECTS: Computes the length of the list that starts at the // given node. int length(const Node *list) { if (list == nullptr) { // empty list return 0; } else { // non-empty list return 1 + length(list->next) // list->next is a smaller list } }",'3552,'87.40234375
'236,'Text 2438,"'The length of an empty list is 0. The length of a non-empty list is one more than the length of the rest of the list; the elements in the list consist of the initial datum and the elements in the rest of the list. We use the length () function itself as an abstraction to compute the number of elements in the remainder of the list, taking the recursive leap of faith that it will compute the right answer.",'3553,'95.41015625
'236,'Text 2439,"'As another example, consider the problem of finding the maximum element in a list. Unlike for length(), the minimal list is not an empty one, since an empty list has no elements in it. Instead, the minimum required size is a list with a single datum, in which case the maximum element is just that lone datum, constituting our base case. For a larger list, we can break it down recursively as follows:",'3554,'95.80078125
'236,'List 78,"",'3555,'89.84375000
'236,'Text 2440 - Part of List 78,"'1. Find the maximum element in the rest of the list. This element is at least as large as any other element in the rest of the list.",'3556,'98.04687500
'236,'Text 2441 - Part of List 78,"'2. Compare the first element to the max of the remainder. The larger of the two is transitively at least as large as the elements in the rest of the list.",'3557,'97.50976563
'236,'Text 2442,"'The following implements this algorithm:",'3558,'58.30078125
'236,'Text 2443,"'// REQUIRES: node represents a valid, non-empty list // EFFECTS: Returns the maximum element in the list that starts at // the given node. int list_max (const Node *list) { if (list->next == nullptr) { // list has only one element return list->datum; } else { // list has more than one element return std: max(list->datum, // compare first datum to",'3559,'34.32617188
'236,'Text 2444,"'(continues on next page)",'3560,'44.26269531
'236,'Footer 162,"'32.1. Recursive Lists",'3561,'56.59179688
'236,'Page number 233,"'231",'3562,'92.67578125
'237,'Header 220,"'Programming and Data Structures, Release 0.3",'3563,'58.98437500
'237,'Text 2445,"'(continued from previous page)",'3564,'57.27539063
'237,'Header 221,"'list_max(list->next)): ; // max of rest of list",'3565,'47.94921875
'237,'Text 2446,"'}",'3566,'33.15429688
'237,'Text 2447,"'}",'3567,'31.15234375
'237,'Text 2448,"'The base case is a list with one element. Such a list has an empty next list, SO we check for that and return the list's lone datum. The recursive case computes the max of the rest of the list and then uses std: :max to determine the maximum of that item and the first item in the list. As always, we take the recursive leap of faith, assuming that the recursive call to list_max() computes the right answer for the smaller list.",'3568,'92.96875000
'237,'Text 2449,"'Exercise 2 Write a function list_sum() that recursively computes the sum of the elements in a list.",'3569,'55.71289063
'237,'Text 2450,"'// EFFECTS: Computes the sum of the elements in the list that // starts at the given node. int list_sum(const Node *node) { // your code here }",'3570,'91.89453125
'237,'Section header 166,"'Exercise 3 Write a function last () that recursively finds and returns the last element of a non-empty list.",'3571,'51.85546875
'237,'Text 2451,"'// REQUIRES: node represents a valid, non-empty list // EFFECTS: Returns the last element in the list that starts at // the given node. int last (const Node *node) { // your code here }",'3572,'94.28710938
'237,'Section header 167,"'32.2 Trees",'3573,'92.23632813
'237,'Text 2452,"'A list is a linear-recursive data structure: each non-empty list is subdivided into a datum and a single smaller list. A tree is a data structure that is, naturally, tree recursive. A non-empty tree is subdivided into a datum and several smaller trees. In this course, we only consider binary trees, where non-empty trees are subdivided into exactly two smaller trees.",'3574,'97.70507813
'237,'Text 2453,"'The term tree stems from the fact that its branching structure resembles that of a botanical tree. Terminology with respect to tree data structures borrows from both botanical and family trees.",'3575,'95.65429688
'237,'List 79,"",'3576,'89.50195313
'237,'Text 2454 - Part of List 79,"'The root is the node that originates the branching structure. In our diagrams, the root is pictured at the top of the tree.",'3577,'97.50976563
'237,'Text 2455 - Part of List 79,"'A non-empty tree consists of a parent node and two child nodes. For a binary tree, there is a left child and a right child. Nodes that have the same parent are siblings.",'3578,'96.82617188
'237,'Text 2456 - Part of List 79,"'A node whose children are all empty is a leaf.",'3579,'95.50781250
'237,'Text 2457 - Part of List 79,"'The size of a tree is the number of elements it contains.",'3580,'95.55664063
'237,'Text 2458 - Part of List 79,"'The height of a tree is the number of levels at which it has elements. Equivalently, it is the length of the longest path from the root to a leaf node.",'3581,'94.38476563
'237,'Text 2459,"'Algorithms on trees are often written as tree-recursive functions, SO that the recursive case makes more than one recursive call. The general strategy is to directly compute the result for the smallest tree allowed by the function, constituting the base case. The recursive case makes recursive calls to compute the results for the left and right children, then combines those results with the datum at the root to compute the answer for the whole tree.",'3582,'95.50781250
'237,'Text 2460,"'1 Pun intended.",'3583,'82.27539063
'237,'Footer 163,"'32.2. Trees",'3584,'58.30078125
'237,'Page number 234,"'232",'3585,'65.13671875
'238,'Header 222,"'Programming and Data Structures, Release 0.3",'3586,'50.68359375
'238,'Figure 91,"",'3587,'94.87304688
'238,'Text 2461,"'Figure 32.3: Recursive definition of a tree. A non-empty tree consists of a datum and two smaller trees.",'3588,'75.68359375
'238,'Figure 92,"",'3589,'93.50585938
'238,'Text 2462,"'Figure 32.4: The height of a tree is the number of levels that contain elements, or equivalently, the length of the longest path from root to a leaf.",'3590,'90.96679688
'238,'Page number 235,"'32.2. Trees",'3591,'54.10156250
'238,'Page number 236,"'233",'3592,'74.75585938
'239,'Header 223,"'Programming and Data Structures, Release 0.3",'3593,'67.91992188
'239,'Text 2463,"'As an example, the following algorithm computes the size of a tree:",'3594,'97.26562500
'239,'List 80,"",'3595,'93.99414063
'239,'Text 2464 - Part of List 80,"'The size of an empty tree is zero.",'3596,'96.87500000
'239,'Text 2465 - Part of List 80,"'The size of a non-empty tree is the size of the left child, plus the size of the right child, plus one for the root datum.",'3597,'98.43750000
'239,'Text 2466,"'Before we can implement this algorithm in code, we need a data representation. As with a list, we use a Node struct, but it now has a datum and pointers to left and right Nodes:",'3598,'96.77734375
'239,'Text 2467,"'struct Node { int datum; Node *left; Node *right; };",'3599,'89.25781250
'239,'Text 2468,"'Like a list, we use a null pointer to represent an empty tree.",'3600,'91.25976563
'239,'Figure 93,"",'3601,'95.36132813
'239,'Text 2469,"'Figure 32.5: Data representation of a tree, using a node for each element and null pointers for empty trees.",'3602,'90.91796875
'239,'Text 2470,"'We can now implement the size () function:",'3603,'83.44726563
'239,'Text 2471,"'// REQUIRES: node represents a valid tree // EFFECTS: Returns the number of elements in the tree represented // by the given node. int size (const Node *tree) { if (!tree) { // empty tree return 0 ; } else { // non-empty tree return 1 + size(tree->left) + size(tree->right). } }",'3604,'88.08593750
'239,'Text 2472,"'As with other recursive functions, we take the recursive leap of faith that size () computes the right answer on smaller trees.",'3605,'85.83984375
'239,'Text 2473,"'The height of a tree is the number of levels it contains. An empty tree contains no levels, SO its height is zero. For",'3606,'77.78320313
'239,'Page number 237,"'32.2. Trees",'3607,'39.42871094
'239,'Page number 238,"'234",'3608,'88.18359375
'240,'Header 224,"'Programming and Data Structures, Release 0.3",'3609,'59.91210938
'240,'Text 2474,"'a non-empty tree, we exploit the alternate definition of height, that it is the length of the longest path from root to leaf. The longest such patch is just one node longer than the longest path in the child subtrees, since the root adds one additional node to the part of the path contained in a child. Thus, we compute the height as follows:",'3610,'98.77929688
'240,'Text 2475,"'// REQUIRES: node represents a valid tree // EFFECTS: Returns the height of the tree represented by the given // node. int height (const Node *tree) { if (!tree) { // empty tree return 0; } else { // non-empty tree return 1 + std: :max (height (tree->left), height (tree->right)) ; } }",'3611,'90.13671875
'240,'Text 2476,"'We use std: :max () to obtain the longer path from the two child trees, then add one to the result to account for the root node.",'3612,'95.84960938
'240,'Text 2477,"'Exercise 4 Write a function tree_contains () that determines whether the given value is contained in the given tree.",'3613,'94.28710938
'240,'Text 2478,"'// EFFECTS: Returns whether the tree rooted at the given node // contains the given value. bool tree_contains (const Node *node, int value) { // your code here }",'3614,'96.24023438
'240,'Text 2479,"'Exercise 5 Write a function count_leaves() that counts the number of leaf nodes in the given tree.",'3615,'93.75000000
'240,'Text 2480,"'Hint: You will likely need two base cases.",'3616,'81.00585938
'240,'Text 2481,"'// EFFECTS: Returns the number of leaf nodes in the tree rooted // at the given node. int count_leaves (const Node *node) { // your code here }",'3617,'93.65234375
'240,'Section header 168,"'32.2.1 Tree Traversals",'3618,'81.83593750
'240,'Text 2482,"'The following function prints every element in a tree to standard output:",'3619,'93.75000000
'240,'Text 2483,"'// REQUIRES: node represents a valid tree // MODIFIES: cout // EFFECTS: Prints each element in the given tree to standard out, // with each element followed by a space. void print (const Node *tree) { if (tree) { // non-empty tree cout << tree->datum << "" "" ; print (tree->left) print (tree->right) } }",'3620,'31.83593750
'240,'Footer 164,"'32.2. Trees",'3621,'58.98437500
'240,'Page number 239,"'235",'3622,'81.98242188
'241,'Header 225,"'Programming and Data Structures, Release 0.3",'3623,'46.09375000
'241,'Text 2484,"'This algorithm processes a root datum before processing any of the data in the children. It thus implements a preorder traversal. For the tree in Figure 32.4, it prints the elements in the order 6 4 1 7 2 9",'3624,'98.48632813
'241,'Text 2485,"'Moving the print statement results in alternate orderings. The following implements an inorder traversal:",'3625,'74.31640625
'241,'Text 2486,"'if (tree) { // non-empty tree print (tree->left) cout << tree->datum << ""; print (tree->right); }",'3626,'69.58007813
'241,'Text 2487,"'The data in the left child is processed first, then the root datum, then the data in the right child. For the tree with height 5, it prints 1 4 6 2 5 9",'3627,'91.89453125
'241,'Text 2488,"'A postorder traversal processes the root datum after the data in the children:",'3628,'79.29687500
'241,'Table 74,"",'3629,'35.83984375
'241,'Text 2489,"'For the same tree, the postorder traversal prints 1459276",'3630,'79.58984375
'241,'Text 2490,"'The structure of a binary tree can be uniquely determined by knowing any two of these orderings.",'3631,'88.28125000
'241,'Footer 165,"'32.2. Trees",'3632,'85.69335938
'241,'Page number 240,"'236",'3633,'76.75781250
'242,'Header 226,"'THIRTYTHREE",'3634,'27.46582031
'242,'Text 2491,"'CHAPTER",'3635,'37.71972656
'242,'Title 60,"'BINARY SEARCH TREES (BSTS)",'3636,'66.65039063
'242,'Text 2492,"'Last time, we saw binary trees, which are a recursive data structure that is either empty, or consists of an element and two subtrees. A binary search tree (BST) is a binary tree whose elements are stored in an order that maintains a sorting invariant. Specifically, a binary search tree is either:",'3637,'95.75195313
'242,'List 81,"",'3638,'84.71679688
'242,'Text 2493 - Part of List 81,"'empty, or",'3639,'95.31250000
'242,'Text 2494 - Part of List 81,"'a root datum with two subtrees such that:",'3640,'95.06835938
'242,'Text 2495 - Part of List 81,"'1. The two subtrees are themselves binary search trees.",'3641,'95.50781250
'242,'Text 2496 - Part of List 81,"'2. Every element in the left subtree is strictly less than the root datum.",'3642,'96.48437500
'242,'Text 2497 - Part of List 81,"'3. Every element in the right subtree is strictly greater than the root datum. 1",'3643,'93.75000000
'242,'Text 2498,"'Figure 33.1 shows an example of a binary search tree.",'3644,'75.19531250
'242,'Figure 94,"",'3645,'93.89648438
'242,'Text 2499,"'Figure 33.1: A binary search tree.",'3646,'69.67773438
'242,'Text 2500,"'Every element in the left subtree is less that the root datum, and every element in the right subtree is greater than the root. The left and right subtrees meet the requirements for a binary search tree. Thus, the whole tree is a binary search tree.",'3647,'94.97070313
'242,'Text 2501,"'1 Our binary search trees do not permit duplicate elements, since we will be using them to build set and map abstractions. If a BST does permit duplicates, it will use a modified definition that allows items equal to the root in one of the subtrees.",'3648,'50.48828125
'242,'Page number 241,"'237",'3649,'86.86523438
'243,'Header 227,"'Programming and Data Structures, Release 0.3",'3650,'93.84765625
'243,'Text 2502,"'Figure 33.2 depicts trees that do not meet the definition of a binary search tree.",'3651,'93.65234375
'243,'Figure 95,"",'3652,'96.77734375
'243,'Text 2503,"'Figure 33.2: Trees that violate the invariants for a binary search tree.",'3653,'87.20703125
'243,'Text 2504,"'In the tree on the left, the left subtree contains the element 7, which is not smaller than the root element 5. This violates the second condition in the recursive definition above of a BST. In the tree on the right, the right subtree is empty, which is a valid binary search tree. However, the left subtree is not a valid BST, since it does not meet the sorting invariant for a BST. Thus, the tree on the right is not a binary search tree.",'3654,'95.11718750
'243,'Text 2505,"'A binary search tree is thus named because searching for an element can be done efficiently, in time proportional to the height of the tree rather than the size. A search algorithm need only recurse on one side of the tree at each level. For example, in searching for the element 2 in the BST in Figure 33.1, the element must be in the left subtree, since 2 is less than the root element 6. Within the left subtree, it must again be to the left, since 2 is less than 5. Within the next subtree, the 2 must be to the right of the 1, leading us to the actual location of the 2.",'3655,'95.89843750
'243,'Text 2506,"'More generally, the following algorithm determines whether or not a BST contains a particular value:",'3656,'93.45703125
'243,'List 82,"",'3657,'94.92187500
'243,'Text 2507 - Part of List 82,"'If the tree is empty, it does not contain the value.",'3658,'97.16796875
'243,'Text 2508 - Part of List 82,"'Otherwise, if the root datum is equal to the value, the tree contains the element.",'3659,'97.41210938
'243,'Text 2509 - Part of List 82,"'If the value is less than the root element, it must be in the left subtree if it is in the tree, SO we repeat the search on the left subtree.",'3660,'97.50976563
'243,'Text 2510 - Part of List 82,"'Otherwise, the value is greater than the root element, SO it is in the right subtree if it is in the tree at all. Thus, we repeat the search on the right subtree.",'3661,'96.43554688
'243,'Text 2511,"'The first two cases above are base cases, since they directly compute an answer. The latter two are recursive cases, and we take the recursive leap of faith that the recursive calls will compute the correct result on the subtrees.",'3662,'95.36132813
'243,'Text 2512,"'The algorithm leads to the following implementation on our tree representation:",'3663,'85.20507813
'243,'Text 2513,"'// REQUIRES: node represents a valid binary search tree // EFFECTS: Returns whether or not the given value is in the tree // represented by node. bool contains (const Node *node, int value) { if (!node) { // empty tree return false; } else if (node->datum == value) { // non-empty tree, equal to root return true; } else if (value < node->datum) { // less than root return contains (node->left, value); } else { // greater than root return contains (node->right, value) } }",'3664,'44.65332031
'243,'Page number 242,"'238",'3665,'90.03906250
'244,'Header 228,"'Programming and Data Structures, Release 0.3",'3666,'59.71679688
'244,'Text 2514,"'This implementation is linear recursive, since at most one recursive call is made by each invocation of contains (). Furthermore, every recursive call is a tail call, SO the implementation is tail recursive. This example illustrates that the body of a linear- or tail-recursive function may contain more than one recursive call, as long as at most one of those calls is actually made.",'3667,'97.50976563
'244,'Text 2515,"'Let us consider another algorithm, that of finding the maximum element of a BST, which requires there to be at least one element in the tree. If there is only one element, then the lone, root element is the maximum. The root is also the maximum element when the right subtree is empty; everything in the left subtree is smaller than the root, making the root the largest item. On the other hand, when the right tree is not empty, every element in that subtree is larger than the root and everything in the left subtree. Then the largest element in the whole tree is the same as the largest element in the right subtree.",'3668,'96.48437500
'244,'Text 2516,"'Summarizing this, we have the following algorithm:",'3669,'87.40234375
'244,'List 83,"",'3670,'93.84765625
'244,'Text 2517 - Part of List 83,"'If the right subtree is empty, then the root is the maximum.",'3671,'97.46093750
'244,'Text 2518 - Part of List 83,"'Otherwise, the maximum item is the maximum element in the right subtree.",'3672,'97.85156250
'244,'Text 2519,"'We implement the algorithm as follows:",'3673,'80.32226563
'244,'Text 2520,"'// REQUIRES: node represents a valid non-empty binary search tree // EFFECTS: Returns the maximum element in the tree represented by // node. int tree_max (const Node *node) { if (!node->right) { // base case return node->datum; } else { // recursive case return tree_max(node->right) } }",'3674,'64.06250000
'244,'Text 2521,"'As with contains(), tree_max() is tail recursive, and it runs in time proportional to the height of the tree.",'3675,'93.21289063
'244,'Section header 169,"'33.1 The BinarySearchTree Interface",'3676,'86.13281250
'244,'Text 2522,"'In the full linked-list definition we saw in Linked Lists, we defined a separate IntList class to act as the interface for the list, defining Node as a member of that class. We then generalized the element type, resulting in a List class template. We follow the same strategy here by defining a BinarySearchTree class template as the interface for a BST.",'3677,'97.16796875
'244,'Figure 96,"",'3678,'51.56250000
'244,'Text 2523,"'template <typename T> class BinarySearchTree { public:",'3679,'33.93554688
'244,'Text 2524,"'// EFFECTS: Constructs an empty BST. BinarySearchTree();",'3680,'77.19726563
'244,'List 84,"",'3681,'50.58593750
'244,'Text 2525 - Part of List 84,"'// EFFECTS: Constructs a copy of the given tree. BinarySearchTree(const BinarySearchTree &other);",'3682,'85.44921875
'244,'Text 2526 - Part of List 84,"'// EFFECTS: Replaces the contents of this tree with a copy of the // given tree. BinarySearchTree & operator=(const BinarySearchTree &other)",'3683,'86.37695313
'244,'Text 2527 - Part of List 84,"'// EFFECTS: Destructs this tree.",'3684,'82.76367188
'244,'Text 2528,"'(continues on next page)",'3685,'72.94921875
'244,'Footer 166,"'33.1. The BinarySearchTree Interface",'3686,'83.00781250
'244,'Page number 243,"'239",'3687,'83.88671875
'245,'Header 229,"'Programming and Data Structures, Release 0.3",'3688,'47.65625000
'245,'Text 2529,"'(continued from previous page)",'3689,'68.26171875
'245,'Text 2530,"'~BinarySearchTree()",'3690,'59.91210938
'245,'Key value 41,"",'3691,'46.97265625
'245,'Text 2531,"'};",'3692,'57.51196289
'245,'Text 2532,"'As with a list, we define Node as a nested class of BinarySearchTree to encapsulate it within the latter ADT. Since it is an implementation detail and not part of the BST interface, we define Node as a private member.",'3693,'94.33593750
'245,'Text 2533,"'The contains() member function differs from the one we defined before; the member function just takes in a data item, while our previous definition operates on a node as well. We define the latter as a private helper function and call it with the root node:",'3694,'95.26367188
'245,'Table 75,"",'3695,'30.02929688
'245,'Footer 167,"'33.1. The BinarySearchTree Interface",'3696,'75.92773438
'245,'Page number 244,"'240",'3697,'80.51757813
'246,'Header 230,"'Programming and Data Structures, Release 0.3",'3698,'74.46289063
'246,'Text 2534,"'(continued from previous page)",'3699,'50.68359375
'246,'Text 2535,"'return contains_imp] (node->left, value) ; } else { return contains_impl (node->right, value). ; } } Node *root; };",'3700,'76.85546875
'246,'Text 2536,"'Observe that contains_impl () does not refer to a BinarySearchTree or any of its members. Thus, there is no need for it to have a this pointer to a BinarySearchTree object. We can declare the function as a static member function to eliminate the this pointer.",'3701,'97.60742188
'246,'Text 2537,"'template <typename T> class BinarySearchTree { public: bool contains (const T &value) const { return contains_impl(root, value) } private: static bool contains_impl (const Node *node, const T &value) { if (!node) { return false; } else if (node->datum == value) { return true; } else if (value < node->datum) { return contains_impl(node->left, value) ; } else { return contains_impl (node->right, value) ; } } Node *root; };",'3702,'43.87207031
'246,'Text 2538,"'Just like a static member variable is associated with a class rather than an individual object, a static member function is also not associated with an individual object, and it cannot refer to non-static member variables.",'3703,'95.16601563
'246,'Text 2539,"'A public static member function can be called from outside the class using the scope-resolution operator, the same syntax for referring to a static member variable:",'3704,'95.84960938
'246,'Text 2540,"'BinarySearchTree<int> : : contains impl (nullptr, -1); // compile error because contains_impl is not public",'3705,'73.77929688
'246,'Footer 168,"'33.1. The BinarySearchTree Interface",'3706,'69.28710938
'246,'Page number 245,"'241",'3707,'88.13476563
'247,'Header 231,"'Programming and Data Structures, Release 0.3",'3708,'67.04101563
'247,'Title 61,"'33.2 BST-Based Set",'3709,'46.67968750
'247,'Text 2541,"'Previously, we have seen array-based set implementations, one that used an unsorted array and another a sorted array. We can also implement a set using a binary search tree to store the data:",'3710,'95.94726563
'247,'Text 2542,"'template <typename T> class BSTSet { public: // EFFECTS: Inserts the given value into this set, if it is not // already in the set. void insert (const T &value) { if (!elts. contains (value)) { elts. insert (value) ; } } // EFFECTS: Returns whether value is in this set. bool contains (const T &value) const { return elts. contains(value) ; } // EFFECTS: Returns the size of this set. int size() const { return elts.size() ; } private: BinarySearchTree<TX elts; };",'3711,'35.49804688
'247,'Text 2543,"'If the underlying BST is balanced, meaning that each subtree within the BST has close to the same number of elements in its left and right child, then the height of the tree is in O(log n), where n is the size of the tree. Thus, the contains () and insert () operations take logarithmic time, rather than the linear time they would take on an unsorted set.",'3712,'84.96093750
'247,'Text 2544,"'Unfortunately, our BST implementation does not guarantee that it will be balanced. In fact, inserting items in increasing order results in a maximally unbalanced tree as in Figure 33.3, resembling a list rather than a tree structure.",'3713,'82.17773438
'247,'Text 2545,"'There are more complicated binary-search-tree implementations that do guarantee balance, but they are beyond the scope of this course.",'3714,'82.95898438
'247,'Footer 169,"'33.2. BST-Based Set",'3715,'71.87500000
'247,'Page number 246,"'242",'3716,'82.08007813
'248,'Header 232,"'Programming and Data Structures, Release 0.3",'3717,'84.17968750
'248,'Figure 97,"",'3718,'96.72851563
'248,'Text 2546,"'Figure 33.3: Inserting elements into a non-balancing binary search tree in order results in a linear structure, with height equal to the number of elements.",'3719,'94.14062500
'248,'Footer 170,"'33.2. BST-Based Set",'3720,'89.59960938
'248,'Page number 247,"'243",'3721,'82.91015625
'249,'Text 2547,"'CHAPTER",'3722,'35.93750000
'249,'Text 2548,"'THIRTYFOUR",'3723,'31.78710938
'249,'Title 62,"'MAPS AND PAIRS",'3724,'48.82812500
'249,'Text 2549,"'A map is a data structure that maps keys to values. It is thus an associative data structure, since it associates a value with each key. As an example, we may want to associate exam scores with individual test takers:",'3725,'97.31445313
'249,'Table 76,"",'3726,'92.43164063
'249,'Text 2550,"'We can store these data in a standard-library map:",'3727,'96.38671875
'249,'Text 2551,"'std: :map<std::string, int> scores; scores [""aliceywu""] = 100; scores [""akamil""] = 23; scores [""taligoro""] = 100; scores [""jjuett""] = 73; cout << scores [""akamil""] << endl; // prints 23 cout << scores [""aliceywu""] << endl; // prints 100",'3728,'92.13867188
'249,'Text 2552,"'The map class template has two required template parameters, the first for the key type and the second for the value type. We are mapping string IDs to integer scores, SO we use a map<string, int>. We can then use the subscript operator with a key to insert a key-value pair into the map, or to look up the value associated with a key.",'3729,'97.16796875
'249,'Text 2553,"'A key feature of the standard-library map is that it is not erroneous to look up a non-existent key. Instead, the map inserts and returns a value-initialized datum for the key. For primitive types, value initialization produces the zero value for the type. (This is distinct from default initialization, which produces an undefined value.)",'3730,'97.02148438
'249,'Text 2554,"'cout << scores [""gmatute""] << endl; // prints 0",'3731,'58.05664063
'249,'Text 2555,"'A map is similar to a set in that the keys in the map are unique; each key is associated with at most one value. However, the values themselves are not unique. The map above has two keys that are associated with the value 100.",'3732,'96.48437500
'249,'Text 2556,"'Given the similarity with a set, we can also implement a map using a binary search tree. However, rather than using the key-value pair for ordering and uniqueness, we need to use just the key, and the value merely tags along for the ride, as shown in Figure 34.1.",'3733,'96.58203125
'249,'Text 2557,"'To make this work, we need a heterogeneous data type for the datum member of a node, SO that it can store separate key and value items. We can define our own struct or class, or we can use the pair template in the standard <utility> library.",'3734,'96.28906250
'249,'Text 2558,"'p1.first -= 5;",'3735,'58.20312500
'249,'Text 2559,"'std: : :pair<int, bool> p1; // default constructor value initializes both items // first now has value -5",'3736,'54.78515625
'249,'Text 2560,"'(continues on next page)",'3737,'49.51171875
'249,'Page number 248,"'244",'3738,'82.27539063
'250,'Header 233,"'Programming and Data Structures, Release 0.3",'3739,'53.61328125
'250,'Figure 98,"",'3740,'98.58398438
'250,'Text 2561,"'Figure 34.1: A map represented as a binary search tree.",'3741,'74.31640625
'250,'Text 2562,"'(continued from previous page)",'3742,'92.82226563
'250,'Text 2563,"'p1. second = false;",'3743,'71.48437500
'250,'Key value 42,"",'3744,'61.32812500
'250,'Text 2564,"'A pair stores a first and second item, which can be of different types. The pair template is parameterized by the types of these items.",'3745,'97.55859375
'250,'Text 2565,"'We can use a pair and a BST to implement a map:",'3746,'89.01367188
'250,'Key value 43,"",'3747,'37.57324219
'250,'Text 2566,"'(continues on next page)",'3748,'77.68554688
'250,'Page number 249,"'245",'3749,'93.21289063
'251,'Header 234,"'Programming and Data Structures, Release 0.3",'3750,'59.71679688
'251,'Text 2567,"'(continued from previous page)",'3751,'73.19335938
'251,'Text 2568,"'private:",'3752,'44.06738281
'251,'List 85,"",'3753,'81.29882813
'251,'Text 2569 - Part of List 85,"'// Type alias for a key-value pair. using Pair_type = std::pair<Key_type, - Value_type>;",'3754,'90.03906250
'251,'Text 2570 - Part of List 85,"'// Comparator that compares pairs by their key components. class PairLess { public: bool operator () ( ..) const; }; // Data representation. BinarySearchTree<Pair_type, PairLess> entries; };",'3755,'27.51464844
'251,'Text 2571,"'For this to work, we need a BinarySearchTree that can take a custom comparator, to compare key-value pairs by just the value component. This comparator can be defaulted to std: : less, which compares elements according to the < operator:",'3756,'94.58007813
'251,'Text 2572,"'template <typename T, typename Compare=std: less<T>> class BinarySearchTree { };",'3757,'84.86328125
'251,'Text 2573,"'All comparisons within the tree now must use an object of the Compare type. We leave the details as an exercise for the reader.",'3758,'95.55664063
'251,'Page number 250,"'246",'3759,'85.10742188
'252,'Text 2574,"'Part V Odds and Ends",'3760,'34.25292969
'252,'Page number 251,"'247",'3761,'87.01171875
'253,'Header 235,"'CHAPTER",'3762,'41.01562500
'253,'Header 236,"'THIRTYFIVE",'3763,'52.34375000
'253,'Title 63,"'ERROR HANDLING AND EXCEPTIONS",'3764,'89.79492188
'253,'Text 2575,"'Thus far, we have largely ignored the problem of handling errors in a program. We have included REQUIRES clauses in many of our functions, specifying that the behavior is undefined when the requirements are violated. However, for functions that interact with data external to the program such as user input, files, or other forms of I/O, it is unrealistic to assume that the data will always be available and valid. Instead, we need to specify well-defined behavior for what happens when the requirements for such a function are violated.",'3765,'97.99804688
'253,'Text 2576,"'In writing a complex program, we subdivide it into individual functions for each task. Each function only knows how to handle its own job, and it returns results to its caller. As a result, it generally is not the case that the function that detects an error is equipped to handle it. Consider the following example:",'3766,'95.26367188
'253,'Text 2577,"'// EFFECTS: Opens the file with the given filename and returns the // contents as a string. string read_file_contents (const string &filename) { ifstream fin(filename) if (!fin.is_open()) { ??? // file did not open; now what? } }",'3767,'88.18359375
'253,'Text 2578,"'The job of read_file_contents is to read data from a file. It doesn't know anything further about the program, SO it isn't in a position to determine what should be done in case of an error. Depending on the program, the right course of action may be to just print an error message and quit, prompt the user for a new filename, ignore the given file and keep going, and SO on. Furthermore, the read_file_contents () function may actually be used in several different contexts, each of which requires a different form of error recovery. The only thing that read_file_contents() should be responsible for is detecting and conveying that an error occurred, and a different function further up in the call stack should do what is required to handle the error.",'3768,'96.72851563
'253,'Text 2579,"'Thus, we need a mechanism that separates error detection from error handling, as well as a means for notifying a caller that an error occurred. We will look at several different strategies for doing SO.",'3769,'77.88085938
'253,'Section header 170,"'35.1 Global Error Codes",'3770,'90.47851563
'253,'Text 2580,"'A common strategy in the C language is to set the value of a global variable to an error code, which provides information about the type of error that occurred. For example, many implementations of C and C++ functions use the errno global variable to signal errors. The following is an example that calls the strtod() standard-library function to read a double from a C-style string:",'3771,'97.60742188
'253,'Text 2581,"'#include <cerrno> #include <cstdlib>",'3772,'46.38671875
'253,'Text 2582,"'(continues on next page)",'3773,'71.63085938
'253,'Page number 252,"'248",'3774,'82.86132813
'254,'Header 237,"'Programming and Data Structures, Release 0.3",'3775,'73.09570313
'254,'Text 2583,"'(continued from previous page)",'3776,'62.06054688
'254,'Section header 171,"'#include <iostream>",'3777,'41.40625000
'254,'Text 2584,"'using std: cout; using std: : endl; int main(int argc, char **argv) { char *end; errno = O; // reset errno before call double number = std::strtod(argv [1], &end) ; if (errno == ERANGE) { // check errno after call cout << ""range error"" << endl; } else cout << number << endl; } }",'3778,'31.90917969
'254,'Text 2585,"'When given the representation of a number that is out of range of the double type, strtod() sets errno to ERANGE:",'3779,'84.13085938
'254,'Text 2586,"'$ /main.exe 1e1000 range error",'3780,'85.88867188
'254,'Text 2587,"'The strategy of setting a global error code can be (pardon the pun) error-prone. For example, errno must be set to zero before calling a standard-library function that uses it, and the caller must also remember to check its value after the function call returns. Otherwise, it may get overwritten by some other error down the line, masking the original error.",'3781,'95.89843750
'254,'Section header 172,"'35.2 Object Error States",'3782,'90.38085938
'254,'Text 2588,"'Another strategy used by C++ code is to set an error state on an object. This avoids the negatives of a global variable, since each object has its own error state rather than sharing the same global variable. C++ streams use this strategy:",'3783,'96.63085938
'254,'Text 2589,"'int main(int argc, char **argv) { std::ifstream input(argv[1]); if (!input) { cout << ""error opening file"" << endl; } }",'3784,'94.58007813
'254,'Text 2590,"'As with a global variable, the user must remember to check the error state after performing an operation that may set it.",'3785,'94.23828125
'254,'Section header 173,"'35.3 Return Error Codes",'3786,'90.72265625
'254,'Text 2591,"'Return error codes are another strategy used in C and C++ code to signal the occurrence of an error. In this pattern, a value from a function's return type is reserved to indicate that the function encountered an error. The following is an example of a factorial () function that uses this strategy:",'3787,'95.21484375
'254,'List 86,"",'3788,'35.44921875
'254,'Text 2592 - Part of List 86,"'// EFFECTS: Computes the factorial of the given number. Returns -1",'3789,'58.15429688
'254,'Text 2593 - Part of List 86,"'// if n negative.",'3790,'32.47070313
'254,'Text 2594 - Part of List 86,"'int factorial (int n) {",'3791,'49.90234375
'254,'Text 2595,"'(continues on next page)",'3792,'58.98437500
'254,'Footer 171,"'35.2. Object Error States",'3793,'74.21875000
'254,'Page number 253,"'249",'3794,'85.15625000
'255,'Header 238,"'Programming and Data Structures, Release 0.3",'3795,'84.91210938
'255,'Text 2596,"'(continued from previous page)",'3796,'50.97656250
'255,'Header 239,"'if (n ( 0) { return -1; } else if (n == 0) { return 1; } else { return n * factorial( (n - 1); } }",'3797,'37.57324219
'255,'Text 2597,"'// error",'3798,'34.86328125
'255,'Text 2598,"'As with a global error code or an object state, it is the responsibility of the caller to check the code to determine whether an error occurred. Furthermore, a return error code only works if there is a value that can be reserved to indicate an error. For a function such as atoi (), which converts a C-style string to an int, there is no such value. In fact, atoi () returns 0 for both the string ""O"" and ""hello"", and the caller cannot tell whether or not the input was erroneous.",'3799,'82.56835938
'255,'Section header 174,"'35.4 Exceptions",'3800,'51.75781250
'255,'Text 2599,"'All three strategies above have the problem that the caller of a function must remember to check for an error; neither the compiler nor the runtime detect when the caller fails to do SO. Another common issue is that error checking is interleaved with the regular control flow of the caller, as in the following:",'3801,'94.58007813
'255,'Text 2600,"'int main(int argc, char **argv) { double number = std::stod(argv[1]) ; string input; cin >> input if (!input) { cout << ""couldn't read input"" << endl; } else if (input == ""sqrt"") { cout << std: sqrt (number) << endl; } else if (input == ""log"") { cout << std: :log(number) << endl; } }",'3802,'67.33398438
'255,'Text 2601,"'The control flow for the error case is mixed in with that of non-error cases, making the code less readable and harder to maintain. Furthermore, the code above fails to check for errors in sqrt () or log(), which is not immediately clear due to the interleaving of control flow.",'3803,'96.97265625
'255,'Text 2602,"'What we want is a mechanism for error handling that:",'3804,'92.62695313
'255,'List 87,"",'3805,'92.23632813
'255,'Text 2603 - Part of List 87,"'Separates error detection from error handling, providing a general means for signaling that an error occurred.",'3806,'97.90039063
'255,'Text 2604 - Part of List 87,"'Separates the control flow for error handling from that of non-erroneous cases.",'3807,'97.21679688
'255,'Text 2605 - Part of List 87,"'Detects when an error is not handled, which by default should cause the program to exit with a meaningful message.",'3808,'97.36328125
'255,'Text 2606,"'The mechanism provided by C++ and other modern languages is exceptions.",'3809,'94.72656250
'255,'Text 2607,"'The following is an example of code that uses exceptions:",'3810,'91.89453125
'255,'Text 2608,"'// Represents an exception in computing a factorial. class FactorialError {} ;",'3811,'41.40625000
'255,'Text 2609,"'(continues on next page)",'3812,'72.94921875
'255,'Footer 172,"'35.4. Exceptions",'3813,'58.39843750
'255,'Page number 254,"'250",'3814,'67.38281250
'256,'Header 240,"'Programming and Data Structures, Release 0.3",'3815,'52.53906250
'256,'Text 2610,"'(continued from previous page)",'3816,'75.83007813
'256,'Figure 99,"",'3817,'25.56152344
'256,'Text 2611,"'// EFFECTS: Computes the factorial of the given number. Throws a // FactorialError if n is negative. int factorial (int n) { if (n < 0) { // error case throw FactorialError () ; // throw an exception } if (n == 0) { // non-error case return 1; } else { return n * factorial( - 1); } } int main(int argc, char **argv) { try { int n = std::stoi(argv[1]); int result = factorial(n) cout << n <<""!!"" "" "" "" "" "" "" result << endl; } catch (const std::invalid_argument &error) { cout ""Error converting "" << argv[1] << to an int: "" error.what() << endl; } catch (const FactorialError &error) { cout << ""Error: cannot compute factorial on negative number"" << endl; } }",'3818,'45.14160156
'256,'Text 2612,"'The individual components of the exception mechanism used above are:",'3819,'78.07617188
'256,'List 88,"",'3820,'93.65234375
'256,'Text 2613 - Part of List 88,"'The FactorialError class is an exception type, and objects of that type are used to signal an error.",'3821,'97.26562500
'256,'Text 2614 - Part of List 88,"'When the factorial () function detects an error, it throws an exception object using the throw keyword. In the example above, the function throws a default-constructed FactorialError. The standard-library stoi () function throws a std: : invalid_argument object when given a string that does not represent an integer.",'3822,'97.85156250
'256,'Text 2615 - Part of List 88,"'The compiler arranges for the exception to propagate outward until it is handled by a try/catch block. In the example above, the first catch block is executed when a td::invalid_argument is thrown, while the second is run when a FactorialError is thrown.",'3823,'97.70507813
'256,'Text 2616,"'When an exception is thrown, execution pauses and can only resume at a catch block. The code that is between the throw and the catch that handles the exception is entirely skipped. This is a good thing; if the rest of the code in factorial () were to run, the function would try to compute the factorial of a negative number, which would recurse indefinitely (or at least until either the program runs out of stack space, or n reaches the most negative int, at which point the subtraction n - 1 would produce undefined behavior).",'3824,'97.26562500
'256,'Text 2617,"'The result of running this program on different inputs is as follows:",'3825,'90.38085938
'256,'List 89,"",'3826,'51.95312500
'256,'Text 2618 - Part of List 89,"'$ /main.exe 3",'3827,'36.25488281
'256,'Text 2619 - Part of List 89,"'3! = 6 $ /main.exe -1 Error: cannot compute factorial on negative number",'3828,'28.80859375
'256,'Text 2620 - Part of List 89,"'$ /main.exe hello Error converting hello to an int: stoi: no conversion",'3829,'27.51464844
'256,'Text 2621,"'The error message in the last example, specifically the part returned by error. what (), is implementation-dependent.",'3830,'88.23242188
'256,'Footer 173,"'35.4. Exceptions",'3831,'55.17578125
'256,'Page number 255,"'251",'3832,'87.74414063
'257,'Header 241,"'Programming and Data Structures, Release 0.3",'3833,'47.55859375
'257,'Section header 175,"'35.4.1 Exception Objects",'3834,'62.59765625
'257,'Text 2622,"'C++ allows an object of any type to be thrown as an exception. However, a proper exception carries information about what caused the error, and using exceptions of different types allows a program to distinguish between different kinds of errors. More specifically, the example above illustrates that a program can perform different actions in response to each exception type.",'3835,'97.90039063
'257,'Text 2623,"'There are several exceptions defined by the standard library, such as invalid argument or out_of_range. The standard-library exceptions all derive from std: : exception, and it is common for user-defined exceptions to do SO as well:",'3836,'93.55468750
'257,'Text 2624,"'class EmailError : public std: exception { public: EmailError (const string &msg_in) : msg(msg_in) {} const char * what () const override { return msg. c_str(); } private: string msg; };",'3837,'34.08203125
'257,'Text 2625,"'A user-defined exception is a class type, SO it can carry any information necessary to pass between the function that detects an error and the one that handles it. For EmailError above, the constructor takes a string and stores it as a member variable, allowing any message to be specified when creating an EmailError object:",'3838,'93.45703125
'257,'Section header 176,"'throw EmailError (""Error sending email to : "" + address)",'3839,'55.56640625
'257,'Text 2626,"'The what () member function is a virtual function defined by std: exception, and EmailError overrides it to return the message passed to the constructor. We can call it when catching an exception to obtain the message:",'3840,'95.94726563
'257,'Section header 177,"'try {",'3841,'27.51464844
'257,'Text 2627,"'} catch (const EmailError &error) { cout << error.what endl; }",'3842,'95.16601563
'257,'Text 2628,"'Exception types are often defined in an inheritance hierarchy, with a derived class representing a more specific kind of error. Deriving from std: : exception is an example of this, but we can also define exception types that derive from EmailError:",'3843,'95.41015625
'257,'Text 2629,"'class InvalidAddressError : public EmailError { }; class SendFailedError : public EmailError { };",'3844,'87.30468750
'257,'Text 2630,"'We will shortly see how exception hierarchies interact with try/catch blocks.",'3845,'90.67382813
'257,'Footer 174,"'35.4. Exceptions",'3846,'67.23632813
'257,'Page number 256,"'252",'3847,'66.11328125
'258,'Header 242,"'Programming and Data Structures, Release 0.3",'3848,'85.79101563
'258,'Title 64,"'35.4.2 Try/Catch Blocks",'3849,'50.97656250
'258,'Text 2631,"'A try/catch block consists of a try block followed by one or more catch blocks:",'3850,'90.38085938
'258,'Text 2632,"'try { int n = std: : stoi (argv[1]) int result = factorial(r ; cout ""! = "" "" result << endl; } catch (const std::invalid_argument &error) { cout << ""Error converting "" << argv [1] << to an int: "" error.what << endl } catch (const FactorialError &error) { cout << ""Error: cannot compute factorial on negative number"" << endl }",'3851,'91.25976563
'258,'Text 2633,"'The try/catch can only handle exceptions that occur within the try part of the block, including in functions called by code in the try. When a thrown exception propagates to a try block, the compiler checks the corresponding catch blocks in order to see if any of them can handle an exception of the type thrown. Execution is immediately transferred to the first applicable catch block:",'3852,'96.48437500
'258,'List 90,"",'3853,'96.58203125
'258,'Text 2634 - Part of List 90,"'The catch parameter is initialized from the exception object. Declaring the parameter as a reference to const avoids making a copy.",'3854,'98.09570313
'258,'Text 2635 - Part of List 90,"'The body of the catch block is run.",'3855,'97.99804688
'258,'Text 2636 - Part of List 90,"'Assuming the catch block completes normally, execution proceeds past the entire try/catch. The remaining code in the try or in the other catch blocks is skipped.",'3856,'98.14453125
'258,'Text 2637,"'In matching an exception object to a catch block, C++ takes into account subtype polymorphism - if the dynamic type of the object is derived from the type of a catch parameter, the catch is able handle that object, SO the program uses that catch block for the exception. The following is an example:",'3857,'97.65625000
'258,'Text 2638,"'void grade_submissions() vector<string> students = load_roster(); for (const string &name : students) { try { auto sub = load_submission(name) double result = grade(sub); email_student (name, result) } catch (const FileError &error) { cout << ""Can't grade "" << name << endl; } catch (const EmailError &error) { cout << ""Error emailing: << name << endl; } } }",'3858,'71.53320313
'258,'Text 2639,"'The first catch block above handles objects of any type derived from FileError, while the second handles objects of any type derived from EmailError.",'3859,'96.87500000
'258,'Text 2640,"'C++ also has a ""catch-all"" that can handle any exception type:",'3860,'95.55664063
'258,'Text 2641,"'try { // some code here } catch (...) {",'3861,'96.19140625
'258,'Text 2642,"'(continues on next page)",'3862,'83.20312500
'258,'Footer 175,"'35.4. Exceptions",'3863,'54.29687500
'258,'Page number 257,"'253",'3864,'80.61523438
'259,'Title 65,"'Programming and Data Structures, Release 0.3",'3865,'40.91796875
'259,'Text 2643,"'(continued from previous page)",'3866,'88.42773438
'259,'Text 2644,"'cout << ""Caught an unknown error"" << endl;",'3867,'68.06640625
'259,'Text 2645,"'}",'3868,'97.13735962
'259,'Text 2646,"'The as a catch parameter enables the catch block to handle any type of object. However, this should in general be avoided - instead, a particular try/catch should only catch the specific kinds of errors that it is able to recover from. For instance, consider the following implementation of the load_roster() function:",'3869,'97.21679688
'259,'Text 2647,"'vector<string> load_roster() try { csvstream csvin(""280roster.csv""); // may throw an exception // Use the stream to load the roster } catch (const csvstream_exception &e) { cout << e. what << endl; // return ??? } }",'3870,'91.74804688
'259,'Text 2648,"'The code uses the csvstream library to read a spreadsheet in CSV format. The library may throw a csvstream_exception object when opening the file, such as if the file doesn't exist. However, the load_roster() function is not the best place to handle this exception; as discussed previously, the appropriate error recovery depends on the application, and it is the caller of load_roster() that knows what to do in case of an error. Thus, load_roster() should avoid catching the exception, letting it propagate to its caller.",'3871,'95.89843750
'259,'Section header 178,"'35.4.3 Exception Propagation",'3872,'89.94140625
'259,'Text 2649,"'When an exception is thrown, if the current function is not within a try block, the exception propagates to the function's caller. Similarly, if the current function is within a try block but there is no associated catch block that can handle an object of the exception's type, the exception also propagates to the caller.",'3873,'86.42578125
'259,'Text 2650,"'To handle an exception, the program immediately pauses execution, then looks for an exception handler as follows. The process starts at the statement that throws the exception:",'3874,'72.02148438
'259,'List 91,"",'3875,'95.16601563
'259,'Text 2651 - Part of List 91,"'Determine if the current statement is within the try part of a try/catch block in the current function. If not, the function call is terminated, and the process repeats in the caller.",'3876,'97.41210938
'259,'Text 2652 - Part of List 91,"'If the execution is within a try, examine the catch blocks in order to find the first one that can handle an exception of the given type. If no matching catch is found, the function call is terminated, and the process repeats in the caller.",'3877,'97.75390625
'259,'Text 2653 - Part of List 91,"'If a matching catch block is found, the catch parameter is initialized with the exception object, and the body of the catch immediately runs. Assuming it completes successfully, execution proceeds past the entire try/catch.",'3878,'96.24023438
'259,'Text 2654,"'As described above, if the code is not within a try block that can handle the exception object, execution returns imme- diately to the caller, and the program looks for a handler there. The exception propagates outward until a viable handler is found.",'3879,'96.48437500
'259,'Text 2655,"'If the exception proceeds outward past main(), the default behavior is to terminate the program. This ensures that either the exception is handled, or the program crashes, informing the user that an error occurred.",'3880,'95.41015625
'259,'Footer 176,"'35.4. Exceptions",'3881,'81.44531250
'259,'Page number 258,"'254",'3882,'80.07812500
'260,'Header 243,"'Programming and Data Structures, Release 0.3",'3883,'73.04687500
'260,'Title 66,"'35.4.4 Exception Examples",'3884,'48.04687500
'260,'Text 2656,"'The following is a DriveThru class that keeps track of menu items and their prices:",'3885,'81.88476563
'260,'Text 2657,"'class InvalidOrderException : public std: : exception {};",'3886,'28.66210938
'260,'Text 2658,"'class DriveThru { public: // EFFECTS: Adds the given item to the menu. void add_item(const string &item, double price) { menu[item] = price; } // EFFECTS: Returns the price for the given item. If the item // doesn't exist, throws an InvalidOrderException. double get_price(const. string &item) const { auto it = menu.find(item) ; if (it != menu.end()) { return it->second; } throw InvalidOrderException() } private: // A map from item names to corresponding prices map<string, double> menu; };",'3887,'56.49414063
'260,'Text 2659,"'The get_price() member function looks up the price of an item, returning it if it is on the menu. If not, it throws an exception of type InvalidOrderException. We use the find() member function of map to avoid inserting a value-initialized price into the map when an item does not exist.",'3888,'90.96679688
'260,'Text 2660,"'The following is a program that reads order items from standard input, computing the total price:",'3889,'83.34960938
'260,'Text 2661,"'int main() { DriveThru eats280; // add items to eats280 double total = 0; string item; while (cin >> item && item != ""done"") { try { total += eats280.get_price(item). } catch (const InvalidOrderException &e) { cout << ""Sorry, we don't have: "" item << endl; } } cout << ""Your total cost is: total << endl; }",'3890,'83.74023438
'260,'Text 2662,"'The program ignores items that aren't on the menu, printing a message indicating that it is not available. In such a case, get_price throws an InvalidOrderException. Since the throw statement is not within a try in get_price(), the exception propagates outward to main (). The call to get_price() is within a try, and there is an associated catch that matches the type of the exception. Execution proceeds to that catch, which prints an error message. Then execution continues after the full try/catch, ending an iteration of the loop and reading in a new item to start the next iteration",'3891,'96.67968750
'260,'Footer 177,"'35.4. Exceptions",'3892,'65.03906250
'260,'Page number 259,"'255",'3893,'79.88281250
'261,'Header 244,"'Programming and Data Structures, Release 0.3",'3894,'71.77734375
'261,'Text 2663,"'As another example, we write a subset of a program that loads and grades student submissions for an assignment. We use the following classes:",'3895,'98.29101563
'261,'List 92,"",'3896,'43.21289063
'261,'Text 2664 - Part of List 92,"'// An exception signifying an error when reading a file. class FileError : std: : exception { };",'3897,'61.86523438
'261,'Text 2665 - Part of List 92,"'// An exception signifying an error when sending an email. class EmailError : std: :exception",'3898,'32.86132813
'261,'Text 2666 - Part of List 92,"'};",'3899,'94.47905731
'261,'Text 2667 - Part of List 92,"'// A student submission. class Submission { public: // EFFECTS: Grades this submission and returns the result. double grade () ; };",'3900,'34.69238281
'261,'Text 2668,"'FileError and EmailError are exceptions that the program will use. We saw the definition of EmailError previ- ously, and FileError is similarly defined. A Submission object represents a student submission, and we elide the definition here.",'3901,'91.11328125
'261,'Text 2669,"'The following functions perform individual tasks in the grading program:",'3902,'77.68554688
'261,'Text 2670,"'// EFFECTS: Emails the given student the given grade. Throws // EmailError if sending the email fails. void email_student (const string &name, double grade); // EFFECTS: Loads the roster from 280roster.csv. Throws // csvstream_exception if the file cannot be read. vector<string> load_roster() { csvstream csvin(""280roster.csv"") ; // may throw an exception vector<string> roster; // Use the stream to load the roster. return roster; } // EFFECTS: Loads the submission for the given student. Throws // FileError if the submission cannot be loaded. Submission load_submission(const string &name) { std::ifstream input (name) if (!input) { throw FileError(): } return Submission(input); }",'3903,'44.55566406
'261,'Text 2671,"'All three functions throw exceptions when they are unable to perform their task. The email_student() func-",'3904,'87.45117188
'261,'Footer 178,"'35.4. Exceptions",'3905,'85.74218750
'261,'Page number 260,"'256",'3906,'89.16015625
'262,'Header 245,"'Programming and Data Structures, Release 0.3",'3907,'64.06250000
'262,'Text 2672,"'tion throws an EmailError if sending fails. The load_roster() function throws a csvstream_exception if reading the roster file fails; in actuality, the exception will be thrown by the csvstream constructor, but since load_roster() allows the exception to propagate outward, it documents that such an exception may be thrown. Fi- nally, load_submissions () throws a FileError if a submission file fails to open.",'3908,'99.21875000
'262,'Text 2673,"'The function that directs the grading process is as follows:",'3909,'93.60351563
'262,'List 93,"",'3910,'27.31933594
'262,'Text 2674 - Part of List 93,"'// EFFECTS: Loads and grades all submissions, sending email to each // student with their result. Throws csvstream_exception // if the roster cannot be loaded. void grade_submissions() { vector<string> students = load_roster(); for (const string &name : students) { try { auto sub = load_submission(name) double result = sub.grade(); email_student (name, result) } catch (const FileError &e) { cout << ""Can't grade "" endl; } catch (const EmailError &e) { cout e.what () endl; } } }",'3911,'73.33984375
'262,'Text 2675,"'This function handles FileError and EmailError exceptions by just printing a message to standard out. The try/catch is within the for loop SO that failure for one student does not prevent grading of other students. If a csvstream_exception is thrown by load_roster(), it gets propagated to the caller of grade_submissions ().",'3912,'95.21484375
'262,'Text 2676,"'Lastly, we have the main () function:",'3913,'74.70703125
'262,'Text 2677,"'int main() { try { grade_submissions (); cout << ""Grading done!"" << endl; } catch (const csvstream_exception &e) { cout << ""Grading failed! << endl; cout << e.what << endl; return EXIT_FAILURE; } }",'3914,'96.82617188
'262,'Text 2678,"'This function handles a csvstream_exception by printing a message to standard out and then returning with a nonzero exit code, indicating a failure.",'3915,'96.58203125
'262,'Text 2679,"'We consider a few more small examples to better understand how exceptions are propagated and handled. The examples use the following exception types:",'3916,'96.28906250
'262,'Text 2680,"'class GoodbyeError {}; class HelloError {}; class Error { public: Error(const string &s) : msg(s) {}",'3917,'58.49609375
'262,'Text 2681,"'(continues on next page)",'3918,'78.22265625
'262,'Footer 179,"'35.4. Exceptions",'3919,'60.40039063
'262,'Page number 261,"'257",'3920,'81.83593750
'263,'Header 246,"'Programming and Data Structures, Release 0.3",'3921,'82.76367188
'263,'Header 247,"'(continued from previous page)",'3922,'37.93945313
'263,'Text 2682,"'const string & get_msg () { return msg; } private: string msg; };",'3923,'27.85644531
'263,'Text 2683,"'Objects of GoodbyeError will generally be thrown by a goodbye() function, while HelloError objects will be thrown by hello().",'3924,'93.50585938
'263,'Text 2684,"'The first example is as follows:",'3925,'58.05664063
'263,'Text 2685,"'void goodbye () { cout << ""goodbye called"" << endl; throw GoodbyeError() cout << ""goodbye returns"" << endl; } void hello() { cout << ""hello called"" << endl; goodbye(); cout << ""hello returns"" << endl; } int main() { try { hello(); cout << ""done"" << endl; } catch (const HelloError &he) { cout << ""caught hello"" endl; } catch (const GoodbyeError &ge) { cout << ""caught goodbye"" endl; } cout << ""main returns"" << endl; }",'3926,'27.27050781
'263,'Text 2686,"'In this example, hello () is called from within a try in main(). So if an exception is thrown and propagates to main (), the associated catch blocks will attempt to handle the exception. Within hello(), the message hello called is printed, followed by a call to goodbye(). The latter prints out goodbye called and then throws a GoodbyeError object. Execution immediately pauses, and the program checks if it is within a try in goodbye(). It is not, SO it then checks the caller to see if it is currently in a try there. There isn't one in hello(), SO the program then checks for a try in main (). The execution state is indeed within a try in main(), SO the program checks the catch blocks, in order, to see if there is one that can handle a GoodbyeError. The second catch can do so, and its code is run, printing caught goodbye. Execution then proceeds past the try/catch, SO the print of main returns executes.",'3927,'96.09375000
'263,'Text 2687,"'Observe that the remaining code in goodbye(), hello(), and the try block in main() were skipped when handling the exception. The full output is as follows:",'3928,'88.62304688
'263,'Text 2688,"'hello called goodbye called caught goodbye main returns",'3929,'94.97070313
'263,'Footer 180,"'35.4. Exceptions",'3930,'46.67968750
'263,'Page number 262,"'258",'3931,'79.19921875
'264,'Header 248,"'Programming and Data Structures, Release 0.3",'3932,'50.97656250
'264,'Text 2689,"'Consider another example:",'3933,'39.18457031
'264,'Text 2690,"'void goodbye () { cout << ""goodbye called"" << endl; throw GoodbyeError() ; cout ""goodbye returns"" << endl; } void hello() { cout << ""hello called"" << endl; try { goodbye () ; } catch (const GoodbyeError &ge) { throw HelloError(): } catch (const HelloError &he) { cout << ""caught hello"" << endl; } cout << ""hello returns"" << endl; } int main() { try { hello() cout << ""done"" << endl; } catch (const HelloError &he) { cout << ""caught hello"" << endl; } catch (const GoodbyeError &ge) { cout << ""caught goodbye"" endl; } cout << ""main returns"" << endl; }",'3934,'27.95410156
'264,'Text 2691,"'This is the same as the first example, except now the call to goodbye is within a try in hello(). When the GoodbyeError object is thrown, the program determines that it is not within a try in goodbye (), SO it checks whether it is in a try in hello (). It is, SO the program checks whether there is a catch block that can handle a GoodbyeError The first catch block can do so, SO its code is run. This throws a HelloError, SO the program checks whether execution is within a try in hello(). It is not - execution is within a catch block, not within a try. So the program proceeds to the caller, checking whether execution is in a try in main(). The call to hello () is indeed within a try, SO the program examines the catch blocks. The first one handles a HelloError, SO its body is executed, printing caught hello. Then execution proceeds past the try/catch to the print of main returns.",'3935,'96.04492188
'264,'Text 2692,"'Observe that a try/catch can only handle exceptions that are thrown within the try block; it does not deal with exceptions that are thrown from one of its catch blocks, SO an outer try/catch must handle such exceptions instead.",'3936,'86.96289063
'264,'Text 2693,"'hello called goodbye called caught hello main returns",'3937,'94.43359375
'264,'Text 2694,"'The following example uses the Error class defined above, which has a constructor that takes a string:",'3938,'93.94531250
'264,'Text 2695,"'void goodbye () { cout << ""goodbye called"" << endl; throw Error(""bye"") ;",'3939,'91.16210938
'264,'Text 2696,"'(continues on next page)",'3940,'64.59960938
'264,'Section header 179,"'35.4. Exceptions",'3941,'49.60937500
'264,'Page number 263,"'259",'3942,'75.48828125
'265,'Header 249,"'Programming and Data Structures, Release 0.3",'3943,'77.88085938
'265,'Text 2697,"'(continued from previous page)",'3944,'73.48632813
'265,'Text 2698,"'cout << ""goodbye returns"" << endl;",'3945,'39.33105469
'265,'Text 2699,"'}",'3946,'31.37207031
'265,'Text 2700,"'void hello() { cout << ""hello called"" << endl; try goodbye () ; } catch (const Error &e) { throw Error(""hey"") ; } cout << ""hello returns"" << endl; }",'3947,'49.51171875
'265,'Text 2701,"'int main() { try { hello() cout << ""done"" << endl; } catch (const Error &e) { cout << e.get_msg() endl; } catch (...) { cout << ""unknown error"" << endl; } cout << ""main returns"" << endl; }",'3948,'49.90234375
'265,'Text 2702,"'The throw statement in goodbye() throws an Error object constructed with the string ""bye"". There is no try in goodbye (), SO the program checks whether it is currently within a try in hello(). Execution is indeed within the try there, and the catch block can handle the Error object. The catch block throws a different Error object, initialized with the string ""hey"". As with the previous example, this throw statement is not within a try in hello(), SO the program checks for a try in main(). Both catch blocks can handle the Error object; the second is a catch-all that can handle any exception. However, the program considers the catch blocks in order, SO it is the first one that runs. Its body retrieves the message from the Error object, printing out hey. Then execution proceeds past the try/catch. The full output is below:",'3949,'97.02148438
'265,'Text 2703,"'hello called goodbye called hey main returns",'3950,'96.28906250
'265,'Section header 180,"'One more example is the following:",'3951,'74.31640625
'265,'Text 2704,"'void goodbye { cout << ""goodbye called"" << endl; throw GoodbyeError() cout ""goodbye returns"" << endl; }",'3952,'96.67968750
'265,'Text 2705,"'void hello() { cout << ""hello called"" << endl; try goodbye () } catch (const Error &e) {",'3953,'94.67773438
'265,'Text 2706,"'(continues on next page)",'3954,'79.58984375
'265,'Footer 181,"'35.4. Exceptions",'3955,'44.16503906
'265,'Page number 264,"'260",'3956,'72.85156250
'266,'Header 250,"'Programming and Data Structures, Release 0.3",'3957,'70.99609375
'266,'Text 2707,"'(continued from previous page)",'3958,'70.99609375
'266,'Text 2708,"'throw Error (""hey""); } cout << ""hello returns"" << endl; } int main() { try { hello() cout << ""done"" << endl; } catch (const Error &e) { cout e.get_msg() ; cout << endl; } catch (...) { cout << ""unknown error"" << endl; } cout << ""main returns"" << endl; }",'3959,'33.05664063
'266,'Text 2709,"'Here, the goodbye () function throws a GoodbyeError, and the throw is not within a try in goodbye( (), SO the program looks for a try in hello(). Execution is within a try there, SO the program examines the catch blocks to see whether one can handle a GoodbyeError. The lone catch block cannot, SO the program propagates the exception to the caller and looks for a try in main(). The code is within a try in main(), SO the program examines the catch blocks in order. The first cannot handle a GoodbyeError, but the second can, SO the latter runs and prints unknown error. Execution continues after the try/catch, printing main returns. The full result is the following:",'3960,'95.99609375
'266,'Text 2710,"'hello called goodbye called unknown error main returns",'3961,'92.18750000
'266,'Section header 181,"'35.5 Error Handling VS. Undefined Behavior",'3962,'85.30273438
'266,'Text 2711,"'The error-detection mechanisms we discussed provide well-defined behavior in case of an error. As such, a function that uses one of these mechanisms should document it, describing when and what kind of error can be generated:",'3963,'97.46093750
'266,'Text 2712,"'// EFFECTS: Computes the factorial of the given number. Returns 0 if // n is negative. int factorial (int n) ; // EFFECTS: Emails the given student the given grade. Throws // EmailError if sending the email fails. void email_student (const string &name, double grade)",'3964,'95.31250000
'266,'Text 2713,"'These functions do not have REQUIRES clauses that restrict the input; violating a REQUIRES clause results in unde- fined behavior, whereas these function produce well-defined behavior for erroneous input.",'3965,'93.75000000
'266,'Text 2714,"'On the other hand, when code does produce undefined behavior, it cannot be detected through any of the error-handling mechanisms above. For example, dereferencing a null or uninitialized pointer does not necessarily throw an exception, set a global error code, or provide any other form of error detection. It is the programmer's responsibility to avoid undefined behavior, and there are no constraints on what a C++ implementation can do if a program results in undefined behavior.",'3966,'97.26562500
'266,'Footer 182,"'35.5. Error Handling vs. Undefined Behavior",'3967,'73.77929688
'266,'Page number 265,"'261",'3968,'86.91406250
'267,'Text 2715,"'Part VI Supplemental Material",'3969,'31.86035156
'267,'Page number 266,"'262",'3970,'86.66992188
'268,'Text 2716,"'CHAPTER",'3971,'42.06542969
'268,'Header 251,"'THIRTYSIX",'3972,'41.01562500
'268,'Title 67,"'INTRODUCTION TO C++",'3973,'64.50195313
'268,'Text 2717,"'This courses uses C++ as the language in which we explore fundamental concepts in programming. Here, we provide a basic overview of C++ for students who are familiar with other languages such as Python or Java.",'3974,'94.77539063
'268,'Section header 182,"'36.1 A Simple Program",'3975,'85.79101563
'268,'Text 2718,"'Let's start with a simple program that prints Hello world! to the screen:",'3976,'94.92187500
'268,'Section header 183,"'#include <iostream>",'3977,'72.50976563
'268,'Text 2719,"'int main() { std::cout << ""Hello world!"" << std: endl; return 0; }",'3978,'95.99609375
'268,'Text 2720,"'The entry point of a C++ program is the main() function, which is a top-level (global) function that has a signature of the form int main() or int main(int argc, char *argv[]). A function signature consists of a return type, the name of the function, and a list of parameters. The parameters are what the function takes as input, and the return type is the kind of value that the function returns. For main(), it can either have no parameters, or it can have parameters that allow it to take command-line arguments, which are specified when the program is run. For simplicity, we start with a main( that does not have parameters.",'3979,'95.60546875
'268,'Text 2721,"'Following the signature of the function, we have the function body, which is the code that gets executed when the function is called. The body itself is comprised of statements, which are executed in order from top to bottom. In our program above, the body of main() has two statements: one that prints to the screen, and a second that exits the function with a return value of 0.",'3980,'95.60546875
'268,'Text 2722,"'Examining the first statement more closely, we see that it is composed of expressions and operators. An expression is a fragment of code that evaluates to some value. The simplest expressions are literals, which hardcode a specific value in the program. For instance, ""Hello world!"" is a string literal that denotes the sequence of characters H, e, and SO on. A name is also an expression, and what it evaluates to depends on what the name is bound to in the environment in which the name is evaluated. In the program above, std: : cout is bound to an object representing the standard output stream (stdout), which allows printing to the console (also referred to as shell or terminal) in which the program is run. Similarly, std: : endl is bound to an object that causes a newline to be printed when inserted to an output stream. Finally, these expressions are connected via the binary operator; in this context, we refer to this as the stream-insertion operator. The code is inserting the string ""Hello world!"" into the standard output stream, followed by inserting std: : endl to obtain a newline.",'3981,'96.77734375
'268,'Text 2723,"'Both std: : cout and std: endl are defined in the iostream library header. The first line of the program (#include <iostream>) instructs the C++ compiler to include the contents of the iostream library header, which makes std: : cout and std: : endl available for us to use.",'3982,'92.52929688
'268,'Page number 267,"'263",'3983,'83.05664063
'269,'Header 252,"'Programming and Data Structures, Release 0.3",'3984,'44.45800781
'269,'Text 2724,"'A name such as std: : cout is called a qualified name - it consists of the std qualifier, followed by the : scope- resolution operator, followed by the cout name. The std qualifier refers to the std namespace, which is a scope in which most standard-library entities are defined. Thus, the qualified name std: : cout refers to the cout that is defined within the std namespace, as opposed to some other cout that might be defined in a different scope. Often, we place a directive in our program to be able to use an entity such as cout without qualifying it with std: :. The following does SO for both cout and endl:",'3985,'98.58398438
'269,'Text 2725,"'using std: : cout; // we can now use cout without qualification using std: : endl; // we can now use endl without qualification",'3986,'34.10644531
'269,'Text 2726,"'The following does SO for every entity defined in the std namespace:",'3987,'84.22851563
'269,'Text 2727,"'using namespace std; // we can now use anything in std without qualification",'3988,'86.52343750
'269,'Text 2728,"'Use this with caution, however - there are lots of names defined in the std namespace, SO this makes it much more likely for our names to conflict with those from the standard library. (In particular, a using namespace directive should never be used in a header file.)",'3989,'96.19140625
'269,'Text 2729,"'The last statement in our program is return 0; This returns the value 0 from the main() function, which conven- tionally indicates that the program completed successfully. We would use a nonzero value instead to indicate an error if something went wrong.",'3990,'94.77539063
'269,'Text 2730,"'In the specific case of returning from main(), a return statement is actually optional. (This is not the case for returning from other functions, unless they have a void return type.) If we don't have a return statement in main (), the compiler implicitly adds a return O; for us. Thus, the program above could be written equivalently as:",'3991,'94.67773438
'269,'Section header 184,"'#include <iostream>",'3992,'45.33691406
'269,'Text 2731,"'using std::cout; // we can now use cout without qualification using std::endl; // we can now use endl without qualification int main() { cout << ""Hello world!"" << endl; } // implicit return 0; added by the compiler",'3993,'41.57714844
'269,'Text 2732,"'Now that we have examined all the pieces of our simple program, let's compile and run it in a shell. Assuming the code is in the file hello. cpp, we can compile and run it as follows:",'3994,'92.67578125
'269,'Text 2733,"'$ g++ -std=c++17 -o hello. exe hello.cpp $ ./hello.exe Hello world!",'3995,'83.64257813
'269,'Text 2734,"'Here, we use the $ symbol to denote the shell prompt, which is displayed by the shell to indicate that it is waiting for our commands. (On most machines, the prompt is more complicated, but we simplify it to just a dollar sign.) We then type the compilation command g++ -std=c++17 -0 hello.e: hello. cpp, which invokes the g++ compiler. The std=c++17 tells the compiler to use the C++17 version of the language. The -0 hello. exe tells the compiler to use hello. exe as the name of the resulting executable file. Finally, hello. cpp is the filename of our C++ program. When the compiler has finished, we type /hello. exe to run the resulting executable, and we see the message Hello world! printed to the screen.",'3996,'96.63085938
'269,'Text 2735,"'In this course, we encourage using both the shell as well as an integrated development environment (IDE). Refer to this tutorial for how to set up and become familiar with using a shell and IDE on your machine.",'3997,'90.03906250
'269,'Footer 183,"'36.1. A Simple Program",'3998,'78.41796875
'269,'Page number 268,"'264",'3999,'85.00976563
'270,'Header 253,"'Programming and Data Structures, Release 0.3",'4000,'75.78125000
'270,'Title 68,"'36.2 Static Typing",'4001,'42.16308594
'270,'Text 2736,"'We saw above that the signature of the main () function includes the return type, which is int in the case of main(). The reason the return type is included is that C++ is a statically typed language, meaning that every value's type must be known at compile time. To do so, the compiler generally requires us to specify the type of a variable, as well as the parameter types and return type of a function. For instance, the following introduces a local variable X with type int and initial value 3:",'4002,'97.60742188
'270,'Text 2737,"'int X = 3;",'4003,'86.47460938
'270,'Text 2738,"'The syntax for defining a variable begins with the type of the variable, followed by the name, followed by an optional initialization. (If no initialization is provided, the variable undergoes default initialization. For primitive types such as int, that means the initial value of the variable is undefined.) The int type is a primitive type, which is a category consisting of the simplest types provided by a language. Common primitive types in C++ include:",'4004,'94.77539063
'270,'List 94,"",'4005,'93.06640625
'270,'Text 2739 - Part of List 94,"'int: signed (positive, negative, or zero) integer values in some finite range, typically -231,231 - 1] = = -2147483648, 2147483647 on most machines",'4006,'96.09375000
'270,'Text 2740 - Part of List 94,"'std::size_t unsigned (positive or zero only) integer values in some finite range, typically [0,264 - 1]",'4007,'95.55664063
'270,'Text 2741 - Part of List 94,"'double: double-precision floating-point values, typically using a 64-bit representation",'4008,'96.77734375
'270,'Text 2742 - Part of List 94,"'bool: a boolean value, either true or false",'4009,'96.63085938
'270,'Text 2743 - Part of List 94,"'char: a character value, generally representing at least the 128 values in the ASCII standard",'4010,'97.46093750
'270,'Text 2744 - Part of List 94,"'void: used as the return type of a function to indicate that it does not return a value",'4011,'96.19140625
'270,'Text 2745,"'As another example, let's define a square function that computes the square of a number. We'll write it to take a double value as input and return a double value as the result:",'4012,'95.45898438
'270,'Section header 185,"'double square(double x)",'4013,'43.77441406
'270,'Text 2746,"'double result = X return result; }",'4014,'56.49414063
'270,'Text 2747,"'As with main (), the signature for square starts with the return type, which is double. Then we have the name of the function, followed by the parameter list. We take in a single double value as input, SO we have a single parameter, which we are calling X. In the body of the function, we define a new variable result that is initialized with the value of X * X, and we then return the value of the variable.",'4015,'96.48437500
'270,'Text 2748,"'Since we only use the variable once, we can simplify our function by eliminating it and using the expression X * X directly where we need it:",'4016,'83.74023438
'270,'Text 2749,"'double square (double x) { return X * x; }",'4017,'60.20507813
'270,'Text 2750,"'Since an expression evaluates to a value, it has a type corresponding to that value. In the case of X * X, its type is double since it is the product of two double values. Thus, the return statement returns a double value, matching the declared return type of the function.",'4018,'96.38671875
'270,'Text 2751,"'We can now invoke square () as follows:",'4019,'88.81835938
'270,'Text 2752,"'#include <iostream>",'4020,'69.33593750
'270,'Text 2753,"'double square (double { return X * x;",'4021,'83.64257813
'270,'Text 2754,"'(continues on next page)",'4022,'83.10546875
'270,'Footer 184,"'36.2. Static Typing",'4023,'56.20117188
'270,'Page number 269,"'265",'4024,'63.76953125
'271,'Header 254,"'Programming and Data Structures, Release 0.3",'4025,'71.77734375
'271,'Text 2755,"'(continued from previous page)",'4026,'62.50000000
'271,'Text 2756,"'}",'4027,'80.90820313
'271,'Text 2757,"'int main() { std: cout << square(3.14) << std: endl; double = square (4); std::cout << square(x) << std: endl; }",'4028,'63.62304688
'271,'Text 2758,"'The square () function must be declared above where we use it in main() - in C++, the scope of a global function or variable is from the point of its declaration until the end of the file. (The scope of an entity is the region of code where it may be used.) We can then invoke the function in main ().",'4029,'95.60546875
'271,'Text 2759,"'Observe that in the definition",'4030,'84.47265625
'271,'Text 2760,"'double X = square(4",'4031,'52.34375000
'271,'Text 2761,"'we invoke square on the literal 4, which actually has type int rather than the declared double type of the parameter of the square () function. In most cases, C++ automatically converts between int and double, SO that we can use a value of one of these types where the other is expected. On the other hand, a call such as square (std: : cout) as erroneous, since there is no conversion between the type of std: : cout (which happens to be std: : ostream) and the required double type.",'4032,'97.11914063
'271,'Section header 186,"'36.3 Compound Data",'4033,'87.89062500
'271,'Text 2762,"'In addition to primitive types, C++ has data types that represent more complex objects. For instance, the std: : ostream type (defined in the iostream header) represents an output stream, and it is the type of std: : cout. The std: : string type is another common data type that represents string objects, and it is defined in the string header:",'4034,'97.31445313
'271,'Text 2763,"'#include <iostream> #include <string>",'4035,'46.77734375
'271,'Text 2764,"'int main() { std: string = ""Hello world!""; std::cout S std::endl; }",'4036,'91.94335938
'271,'Text 2765,"'Often, we want to keep track of a collection of objects of the same type, such as an arbitrary number of integer values. We can use a std: : vector to do so, which is an example of a template that is parameterized by some other type. For instance, std: : vector<int> is a collection of int values, while std: : vector<std: : string> is a collection of std: : string values. The following demonstrates how to use a vector:",'4037,'97.11914063
'271,'Text 2766,"'#include <iostream> #include <vector> int main() { std: vector<int> scores 84, 91, 77, 95, 83 }; for (std::size_t i = 0; i< scores.size( ++i) { std: cout << ""Score "" = << scores [i] << std: : endl; } }",'4038,'51.17187500
'271,'Footer 185,"'36.3. Compound Data",'4039,'59.17968750
'271,'Page number 270,"'266",'4040,'82.37304688
'272,'Header 255,"'Programming and Data Structures, Release 0.3",'4041,'64.06250000
'272,'Text 2767,"'In this code, we define a scores variable of type std: vector<int>, and we provide an initial set of values as a comma-separated list enclosed by curly braces. We then iterate over the indices of the vector, which start at 0 and end at one less than the size of the vector, which we obtain via the expression scores size( We access an element of the vector using square brackets, with the vector object on the left-hand side and the index between the brackets (scores[i]). Using this syntax, we have to be careful not to go past the end of the vector, which would result in undefined behavior, meaning that anything could happen - e.g. crashing the program, overwriting some other piece of data, stealing your files, or even nothing at all. Alternatively, we can do scores. at (i), which checks whether the index is in range and guarantees an error if it is not - the program crashes, but we get some useful information, and it definitely won't steal our files.",'4042,'99.07226563
'272,'Text 2768,"'We can also add elements to a vector after it has been created:",'4043,'93.26171875
'272,'Text 2769,"'scores.push_back(42)",'4044,'87.64648438
'272,'Text 2770,"'This appends the element 42 at the end of the vector. Similarly, the expression scores.pop_back() removes the element at the end of the scores vector (assuming there is at least one element in the vector; otherwise we get the dreaded undefined behavior).",'4045,'96.48437500
'272,'Text 2771,"'Vectors are useful for ordered collections of data that all have the same type. However, sometimes we want to keep track of multiple pieces of data that have individual meanings, and that might even have different types. For instance, a complex number has a real part and an imaginary part; while both might be represented as doubles, we want to keep track of which part is which through a name rather than maintaining an ordering between them. A struct gives us this ability to introduce a compound object, comprised of multiple pieces each with individual names. The following is an example of defining a new Complex type:",'4046,'96.92382813
'272,'Text 2772,"'struct Complex { double real; double imaginary; };",'4047,'92.04101563
'272,'Text 2773,"'We start with the struct keyword, followed by the name of the type we are defining, followed by an open curly brace. We then specify the components of the struct, using syntax similar to variable declarations. These components are called member variables in C++2. The struct definition is terminated by a closing curly brace and a semicolon. Once we have this definition, we can write a function to print out a Complex value:",'4048,'97.75390625
'272,'Section header 187,"'void Complex_print (Complex number) {",'4049,'27.24609375
'272,'Text 2774,"'std: cout << number.re if (number. imaginary >= 0) std::cout << '+'; } std: cout << number. .imaginary std: endl; }",'4050,'96.72851563
'272,'Text 2775,"'As shown above, we can access a member variable using the dot operator. The expression number. real accesses the real component of the number object, and number. imaginary refers to the imaginary component. The function prints the + character to separate the two components if the imaginary part is nonnegative - otherwise, the imaginary part would have a minus sign, SO we wouldn't want a + between the two components.",'4051,'96.82617188
'272,'Text 2776,"'We can create objects of Complex type and print them as follows:",'4052,'85.20507813
'272,'Text 2777,"'Complex c1 = { 3.14, -1.7 }; Complex c2; c2. real = 2.72;",'4053,'87.40234375
'272,'Text 2778,"'(continues on next page)",'4054,'84.66796875
'272,'Text 2779,"'1 In other languages the term class is used instead. In C++, the struct and class keywords are closely related, and we will see the details later. 2 Other languages uses the terms fields or attributes to refer to these components.",'4055,'54.78515625
'272,'Footer 186,"'36.3. Compound Data",'4056,'49.21875000
'272,'Page number 271,"'267",'4057,'68.99414063
'273,'Header 256,"'Programming and Data Structures, Release 0.3",'4058,'66.45507813
'273,'Text 2780,"'(continued from previous page)",'4059,'70.75195313
'273,'Text 2781,"'c2. imaginary = -4; Complex_print(c1) Complex_print(c2)",'4060,'62.25585938
'273,'Text 2782,"'As the code demonstrates, we can use curly braces to initialize a Complex variable, which initializes the components in order: c1. real gets initialized to 3. 14, and c1. .imaginary gets initialized to -1.7. Alternatively, we can rely on default initialization as is the case for c2. However, this ends up initializing the two components to undefined values, SO we need to replace their values before we can proceed to use them.",'4061,'97.60742188
'273,'Text 2783,"'As another example, we define a struct to keep track of a person's exam score. We need to keep track of the person's name, as well as the score value itself:",'4062,'91.65039063
'273,'Section header 188,"'struct Grade {",'4063,'54.78515625
'273,'Text 2784,"'std::string name; int score; };",'4064,'92.48046875
'273,'Text 2785,"'We can now use the Grade type as follows:",'4065,'91.35742188
'273,'Text 2786,"'Grade g1{""Sofia"",99 }; Grade g2; g2. name = ""Amir""; g2. score = 23; std: cout << gl.name << "" "" earned a << g1. score << std: : endl ; std::cout << g2. .name << "" earned a << g2. score << std: endl;",'4066,'45.04394531
'273,'Section header 189,"'36.4 Value Semantics",'4067,'93.94531250
'273,'Text 2787,"'One of the distinguishing features of a programming language is the relationship between variables and objects, which are pieces of data in memory. In some languages, a variable is directly associated with an object, SO that using the variable always accesses the same object (as long as the variable is in scope). We say that the language has value semantics if this is the case. In other languages, a variable is an indirect reference to an object, and the variable may be modified to refer to a different object. This scheme is known as reference semantics.",'4068,'98.19335938
'273,'Text 2788,"'C++ has value semantics, unlike other languages such as Java³ or Python that primarily have reference semantics. We can illustrate the difference between these semantic choices using the Complex type we defined previously. Consider the following code:",'4069,'97.16796875
'273,'Section header 190,"'#include <iostream>",'4070,'51.26953125
'273,'Text 2789,"'struct Complex { double real; double imaginary; }; void Complex_print(Complex number) { std: cout << number.real if (number.imaginary >: 0) { std::cout << '+'; }",'4071,'82.03125000
'273,'Text 2790,"'(continues on next page)",'4072,'75.97656250
'273,'Text 2791,"'3 Java actually has value semantics for primitive types and reference semantics for class types.",'4073,'71.87500000
'273,'Footer 187,"'36.4. Value Semantics",'4074,'54.39453125
'273,'Page number 272,"'268",'4075,'71.53320313
'274,'Header 257,"'Programming and Data Structures, Release 0.3",'4076,'77.24609375
'274,'Text 2792,"'(continued from previous page)",'4077,'68.70117188
'274,'Text 2793,"'std: cout << number.imaginary << std::endl;",'4078,'60.30273438
'274,'Text 2794,"'}",'4079,'30.93261719
'274,'Text 2795,"'int main() { Complex c1 ={ 3.14,-1.7}; Complex c2 = c1; c2.real = 2.72; Complex_print (c1); ; Complex_print (c2) ;",'4080,'65.03906250
'274,'Text 2796,"'}",'4081,'26.58691406
'274,'Text 2797,"'In this code, we define a variable c1 of type Complex and give it an initial value. We then copy it to a c2 variable. If we modify c2, the change does not affect c1, since the two variables each have their own object with which they are associated. In memory, this looks something like the picture in Figure 36.1.",'4082,'90.57617188
'274,'Figure 100,"",'4083,'50.00000000
'274,'Text 2798,"'Figure 36.1: Two variables corresponding to separate Complex objects in memory.",'4084,'89.64843750
'274,'Text 2799,"'Compiling and running the program produces:",'4085,'63.18359375
'274,'Text 2800,"'$ g++ -std=c++17 -o complex.exe complex.cpp",'4086,'73.92578125
'274,'Text 2801,"'$ ./complex.exe 3.14-1.7 2.72-1.7",'4087,'30.93261719
'274,'Text 2802,"'We see that as expected, the modification to c2 does not affect c1. Compare this to a similar Python program:",'4088,'89.64843750
'274,'Text 2803,"'class Complex: def__init__(self, real, imaginary) self.real = real self.imaginary = imaginary",'4089,'84.13085938
'274,'Text 2804,"'def Complex_print (number) : print (number.real, end='') if number. imaginary >=0: print ('+', end=') print (number. imaginary)",'4090,'72.80273438
'274,'Text 2805,"'(continues on next page)",'4091,'87.79296875
'274,'Footer 188,"'36.4. Value Semantics",'4092,'54.39453125
'274,'Page number 273,"'269",'4093,'77.53906250
'275,'Header 258,"'Programming and Data Structures, Release 0.3",'4094,'65.33203125
'275,'Text 2806,"'(continued from previous page)",'4095,'75.63476563
'275,'Text 2807,"'c1 = Complex(3.14, -1.7) c2 = c1 c2. real = 2.72 Complex_print(c1) Complex_print(c2)",'4096,'42.52929688
'275,'Text 2808,"'In memory, the variables look like the diagram in Figure 36.2.",'4097,'67.57812500
'275,'Figure 101,"",'4098,'31.86035156
'275,'Text 2809,"'Figure 36.2: Two variables indirectly referring to the same Complex object.",'4099,'92.48046875
'275,'Text 2810,"'Running the program produces the following:",'4100,'52.14843750
'275,'Text 2811,"'$ python3 complex.py 2.72-1.7 2.72-1.7",'4101,'93.60351563
'275,'Text 2812,"'This confirms that c1 and c2 refer to the same object, since the modification to c2. real also affected c1.",'4102,'91.74804688
'275,'Text 2813,"'We can also observe C++'s value semantics when we call a function. Suppose we want a function that modifies a Complex object to be its conjugate, flipping the sign of the imaginary component of the complex number. The following is an attempt to write this function:",'4103,'96.58203125
'275,'Text 2814,"'void Complex_conjugate(Complex number) { number. imaginary = -number. imaginary; }",'4104,'48.53515625
'275,'Text 2815,"'Suppose we insert the following statement prior to the print statements in our program above:",'4105,'95.99609375
'275,'Text 2816,"'Complex_conjugate(c1);",'4106,'91.30859375
'275,'Text 2817,"'Compiling and running the code, we get:",'4107,'95.65429688
'275,'Text 2818,"'$ g++ -std=c++17 -0 - complex.exe complex.cpp $ ./complex.exe 3.14-1.7 2.72-1.7",'4108,'91.01562500
'275,'Text 2819,"'Nothing changes! This is because the number parameter of the Complex_conjugate() function is its own ob- ject, and it receives a copy of c1's value. The diagram in Figure 36.3 illustrates this in memory at the end of the Complex_conjugate call.",'4109,'94.33593750
'275,'Text 2820,"'The copy within the Complex_conjugate() function does have its imaginary component modified, but not the object within the main() function. This behavior is called pass by value, since the value of c1 (the argument of the function call) is copied into the number parameter object.",'4110,'94.48242188
'275,'Footer 189,"'36.4. Value Semantics",'4111,'60.49804688
'275,'Page number 274,"'270",'4112,'77.68554688
'276,'Header 259,"'Programming and Data Structures, Release 0.3",'4113,'58.98437500
'276,'Text 2821,"'Complex_conjugate",'4114,'71.77734375
'276,'Table 77,"",'4115,'45.80078125
'276,'Title 69,"'main",'4116,'43.96972656
'276,'Table 78,"",'4117,'31.20117188
'276,'Text 2822,"'Figure 36.3: A function that received a copy of an argument object.",'4118,'82.22656250
'276,'Text 2823,"'C++ also supports another mechanism for passing arguments: pass by reference. In this scheme, the parameter is an alias of the object passed in as an argument rather than being its own object. We specify that a parameter should use pass by reference by placing the ampersand (&) symbol to the left of the parameter name:",'4119,'96.87500000
'276,'Text 2824,"'void omplex_conjugate(Complex &number) { number. imaginary = -number. imaginary; }",'4120,'63.86718750
'276,'Text 2825,"'Compiling and running the code with this modified definition, gives us:",'4121,'92.08984375
'276,'Text 2826,"'$ g++ -std=c++17 -o complex.exe complex.cpp $ /complex.exe 3.14+1.7 2.72-1.7",'4122,'46.09375000
'276,'Text 2827,"'We see that c1 has indeed been conjugated. The memory diagram in Figure 36.4 depicts what the code looks like in memory at the end of the call to Complex_conjugate(). In the figure, we denote an alias with a dashed line, and we do not include a box next to the number name to reflect the fact that it is not associated with a new object.",'4123,'96.28906250
'276,'Footer 190,"'36.4. Value Semantics",'4124,'52.83203125
'276,'Page number 275,"'271",'4125,'80.66406250
'277,'Header 260,"'Programming and Data Structures, Release 0.3",'4126,'70.16601563
'277,'Figure 102,"",'4127,'70.06835938
'277,'Text 2828,"'Figure 36.4: A function that received an alias to an existing argument object.",'4128,'83.69140625
'277,'Section header 191,"'36.5 Example: Stickman",'4129,'85.64453125
'277,'Text 2829,"'Having seen the basics of C++, let us proceed to write a larger C++ program that implements a stickman game (also called hangman), which involves guessing the letters in a word or phrase. First, let's sketch out how we want the game to run. If the puzzle is the word hello, an unsuccessful game may play out like the following:",'4130,'96.82617188
'277,'Text 2830,"'$ /stickman.exe hello",'4131,'80.76171875
'277,'Text 2831,"'Enter a lowercase letter to guess: a o",'4132,'56.39648438
'277,'Text 2832,"'Enter a lowercase letter to guess: b o I",'4133,'77.92968750
'277,'Text 2833,"'Enter a lowercase letter to guess: C",'4134,'82.86132813
'277,'Text 2834,"'(continues on next page)",'4135,'85.49804688
'277,'Footer 191,"'36.5. Example: Stickman",'4136,'65.38085938
'277,'Page number 276,"'272",'4137,'82.27539063
'278,'Header 261,"'Programming and Data Structures, Release 0.3",'4138,'49.02343750
'278,'Text 2835,"'(continued from previous page)",'4139,'61.76757813
'278,'Text 2836,"'o",'4140,'53.41796875
'278,'Text 2837,"'/I",'4141,'82.32421875
'278,'Text 2838,"'Enter a lowercase letter to guess: d o /I\",'4142,'38.72070313
'278,'Text 2839,"'Enter a lowercase letter to guess: e /I\ e Enter a lowercase letter to guess: f o /I\ / Enter a lowercase letter to guess: g o /I\ e Better luck next time!",'4143,'28.58886719
'278,'Text 2840,"'We want to print out underscores corresponding to the letters in the puzzle, with a space between each of them. We prompt the player for a guess, reading from the standard input stream corresponding to input from the console. If the player guesses a letter that is not in the puzzle, we reveal a portion of a stick figure. If the player guesses a letter that is in the puzzle, we reveal all occurrences of that letter and do not add to the stick figure. If the player guesses incorrectly six times, the full stick figure is revealed, and the player loses.",'4144,'92.57812500
'278,'Text 2841,"'The following is a successful run of the game (loosely following the frequency distribution of English letters):",'4145,'69.58007813
'278,'Text 2842,"'$ ./stickman. exe hello Enter a lowercase letter to guess: e",'4146,'39.94140625
'278,'Text 2843,"'(continues on next page)",'4147,'71.63085938
'278,'Footer 192,"'36.5. Example: Stickman",'4148,'58.49609375
'278,'Page number 277,"'273",'4149,'73.38867188
'279,'Header 262,"'Programming and Data Structures, Release 0.3",'4150,'63.33007813
'279,'Text 2844,"'(continued from previous page)",'4151,'57.37304688
'279,'Text 2845,"'e",'4152,'42.43164063
'279,'Text 2846,"'Enter a lowercase letter to guess:",'4153,'54.88281250
'279,'Text 2847,"'t",'4154,'42.43164063
'279,'Text 2848,"'o",'4155,'82.61718750
'279,'Text 2849,"'e",'4156,'59.27734375
'279,'Text 2850,"'Enter a lowercase letter to guess: S",'4157,'81.64062500
'279,'Text 2851,"'o",'4158,'66.69921875
'279,'Text 2852,"'I e",'4159,'27.44140625
'279,'Text 2853,"'Enter a lowercase letter to guess:",'4160,'58.15429688
'279,'Text 2854,"'a",'4161,'47.75390625
'279,'Text 2855,"'o",'4162,'55.37109375
'279,'Text 2856,"'/ - e -",'4163,'44.45800781
'279,'Text 2857,"'Enter a lowercase letter to guess: i",'4164,'43.77441406
'279,'Text 2858,"'o /I\ e",'4165,'56.00585938
'279,'Text 2859,"'Enter a lowercase letter to guess: o o /I\ - e o Enter a lowercase letter to guess: h o /i\ h e o - - Enter a lowercase letter to guess: r o /I\ / h e - - o Enter a lowercase letter to guess:",'4166,'28.14941406
'279,'Text 2860,"'(continues on next page)",'4167,'74.56054688
'279,'Footer 193,"'36.5. Example: Stickman",'4168,'85.10742188
'279,'Page number 278,"'274",'4169,'74.56054688
'280,'Header 263,"'Programming and Data Structures, Release 0.3",'4170,'80.27343750
'280,'Text 2861,"'(continued from previous page)",'4171,'52.83203125
'280,'Header 264,"'o /I\ / hello Congratulations",'4172,'34.59472656
'280,'Text 2862,"'1",'4173,'42.52929688
'280,'Title 70,"'36.5.1 Program Constants",'4174,'50.00000000
'280,'Text 2863,"'Now that we have a general sense of how the program should behave, we can go ahead and start on our design for its structure. First, let's define some constants corresponding to the stick figure. The full figure is as follows:",'4175,'96.04492188
'280,'Text 2864,"'/|\ / \",'4176,'87.45117188
'280,'Text 2865,"'This spans three lines. Unfortunately, a string literal in C++ cannot directly include a newline (line break) character. However, we can use the escape sequence \n to tell the compiler we want a newline character. For instance, the following prints Hello on one line, followed by world! on the next line4:",'4177,'96.38671875
'280,'Text 2866,"'std: cout << ""Hello\nworld!"" << std: endl",'4178,'52.24609375
'280,'Text 2867,"'Escape sequences in general start with a backslash in C++. If we actually want a backslash character itself, it too needs to be escaped: 11. Thus, the stick figure can be represented with the following string:",'4179,'96.72851563
'280,'Text 2868,"'"" o\n//\\\n/ """"""",'4180,'68.01757813
'280,'Text 2869,"'The string starts with a space to center the head of the stick figure, then the newline escape sequence \n to end the line, then the right arm and torso, followed by the \\ escape sequence for a backslash to represent the left arm, followed by another \n newline, then the right leg, a space, and finally the escaped left leg.",'4181,'97.26562500
'280,'Text 2870,"'We can now work our way backwards to obtain partially revealed stick figures. There are two things we need to ensure SO that the figures line up in the output:",'4182,'95.94726563
'280,'List 95,"",'4183,'87.98828125
'280,'Text 2871 - Part of List 95,"'Each figure has exactly two newline characters.",'4184,'98.09570313
'280,'Text 2872 - Part of List 95,"'Each figure has exactly three characters on the third line.",'4185,'97.94921875
'280,'Text 2873,"'We can use a std: : vector<std: string> to store the figures in order:",'4186,'96.24023438
'280,'Text 2874,"'const std: : vector<std: string> STICK_FIGURES = { ""\n\n "" o\n\n o\n "" o\n/l\n "" o\n//\\\n "" 0\n//\\\n/ "" 0\n//\\\n/ };",'4187,'47.55859375
'280,'Text 2875,"'4 Note that std: : endl is not the same as the newline character. It has the effect of printing the newline character to the target stream, but it also flushes the stream, which immediately transfers the inserted data into the underlying output. In the absence of a flush, the stream is allowed to buffer the data in memory, which generally allows for better performance than writing characters immediately.",'4188,'91.89453125
'280,'Footer 194,"'36.5. Example: Stickman",'4189,'56.88476563
'280,'Page number 279,"'275",'4190,'83.54492188
'281,'Header 265,"'Programming and Data Structures, Release 0.3",'4191,'66.79687500
'281,'Text 2876,"'We prefix the type with the const qualifier to denote that this is a constant, and the compiler will prevent us from modifying it. By convention, we name the constant using all capital letters, with underscores between words. We'll also use a constant for the maximum number of wrong guesses:",'4192,'94.97070313
'281,'Text 2877,"'const int MAX_MISSES = 6;",'4193,'42.06542969
'281,'Section header 192,"'36.5.2 The Game Struct",'4194,'80.90820313
'281,'Text 2878,"'Next, we consider what data we need to represent the state of a game. We have to keep track of both the answer to the puzzle, as well as what pieces have been guessed by the player and what pieces remain. We also need to track the number of missed guesses. We will additionally keep a count of the number of letters remaining - this isn't strictly necessary, as we can recompute it when we need it, but it will make our job easier to keep track of it separately.",'4195,'87.89062500
'281,'Text 2879,"'Before we define a struct, we also need to determine what underlying data types are appropriate to represent each member variable. The counts can be represented by the int type, and the answer by the std: : string type. We can also represent what the player has and hasn't guessed with a std: : string - letters that have not been guessed will be replaced with an underscore, while those that have been revealed will have the same values as in the answer. We can now define the struct:",'4196,'85.44921875
'281,'List 96,"",'4197,'49.51171875
'281,'Text 2880 - Part of List 96,"'// A struct to represent the state of a game of stickman.",'4198,'36.66992188
'281,'Text 2881 - Part of List 96,"'struct Game {",'4199,'99.80069733
'281,'Text 2882 - Part of List 96,"'// The number of wrong guesses made so far. int miss_count;",'4200,'31.03027344
'281,'Text 2883 - Part of List 96,"'// The number of remaining unguessed positions in the puzzle. int remaining_letters;",'4201,'33.25195313
'281,'Text 2884 - Part of List 96,"'// The current state of the puzzle, with underscores representing // unguessed letters. std: : string puzzle; // The answer to the puzzle. std: string answer; };",'4202,'25.90332031
'281,'Text 2885,"'Here, we have documented each component with a comment above it that describes its purpose.",'4203,'71.24023438
'281,'Section header 193,"'36.5.3 Task Decomposition",'4204,'81.88476563
'281,'Text 2886,"'Let's now think about the functions we need in our program. We should break down each discrete task in the program to its own function, SO that each function has a small job, and SO we can test each piece individually. The following are some tasks that our program needs to do:",'4205,'91.89453125
'281,'List 97,"",'4206,'83.30078125
'281,'Text 2887 - Part of List 97,"'Construct a Game object from a std: : string answer, with the appropriate initial values for each member vari- able.",'4207,'94.53125000
'281,'Text 2888 - Part of List 97,"'Print the a Game object, showing the player the current state of the game.",'4208,'89.30664063
'281,'Text 2889 - Part of List 97,"'Obtain a letter guess from the player, checking whether or not the guess is a valid letter.",'4209,'90.18554688
'281,'Text 2890 - Part of List 97,"'Update the Game based on a guessed letter.",'4210,'87.15820313
'281,'Text 2891 - Part of List 97,"'Perform the top-level game loop until the game ends.",'4211,'89.79492188
'281,'Footer 195,"'36.5. Example: Stickman",'4212,'80.90820313
'281,'Page number 280,"'276",'4213,'82.27539063
'282,'Header 266,"'Programming and Data Structures, Release 0.3",'4214,'81.98242188
'282,'Text 2892,"'Let's write function signatures corresponding to each of these tasks. We will write them in the form of a declaration5, which excludes the body of a function, replacing it with a semicolon.",'4215,'98.38867188
'282,'List 98,"",'4216,'93.01757813
'282,'Text 2893 - Part of List 98,"'The function that constructs a Game takes a std: : string as an argument and returns a Game:",'4217,'95.06835938
'282,'Text 2894 - Part of List 98,"'Game make_game (std : string answer)",'4218,'96.58203125
'282,'Text 2895 - Part of List 98,"'The function that prints a Game takes a Game object and does not return anything.",'4219,'96.67968750
'282,'Text 2896 - Part of List 98,"'void print_game (Game game) ;",'4220,'96.28906250
'282,'Text 2897 - Part of List 98,"'We actually don't need a copy of the Game object, SO we can specify pass by reference instead to obtain an alias to the existing object:",'4221,'96.77734375
'282,'Text 2898 - Part of List 98,"'void print_game (Game &game) ;",'4222,'96.53320313
'282,'Text 2899 - Part of List 98,"'The function that obtains a guess from the player doesn't take any arguments, and it returns a character value:",'4223,'93.21289063
'282,'Text 2900 - Part of List 98,"'char get_guess()",'4224,'92.04101563
'282,'Text 2901 - Part of List 98,"'The function that updates the game must take the Game object via pass by reference, SO that we don't get a copy of the Game. It also takes in the guessed letter:",'4225,'95.36132813
'282,'Text 2902 - Part of List 98,"'void update_game (Game &game, char guess)",'4226,'94.77539063
'282,'Text 2903 - Part of List 98,"'The top-level function takes the answer as a string and does not return anything:",'4227,'96.43554688
'282,'Text 2904 - Part of List 98,"'void play_game (std: string answer)",'4228,'93.11523438
'282,'Section header 194,"'36.5.4 Implementation",'4229,'89.84375000
'282,'Text 2905,"'We can now proceed to implement these functions, starting with make_game(). The function needs to define a Game object and set its member variables:",'4230,'96.97265625
'282,'Text 2906,"'Game game = { 0, 0, , answer, answer };",'4231,'75.68359375
'282,'Text 2907,"'We've initialized the puzzle member variable to be a copy of the answer parameter to start, but we need to replace each letter with an underscore. Let's assume that we only hide lowercase letters, and that other characters are shown to the player without needing to be guessed. This allows our puzzle to contain spaces and other punctuation. We can write a separate function to determine whether or not a character is a lowercase letter:",'4232,'97.46093750
'282,'Text 2908,"'bool is_lowercase (char value) { return value >= 'a' && value <= 'z' ; }",'4233,'76.36718750
'282,'Text 2909,"'This logic takes advantage of the fact that in the ASCII standard (and most other character standards), the lowercase letters are adjacent and in order. Thus, a lowercase letter must be both greater than or equal to the character 'a' and no more than the character 'z'.",'4234,'88.96484375
'282,'Text 2910,"'We can now loop over the puzzle member variable, replacing each lowercase character with an underscore:",'4235,'51.46484375
'282,'Text 2911,"'5 Technically, a definition is also a declaration. A declaration that is not also a definition is more precisely called an incomplete or forward declaration.",'4236,'77.19726563
'282,'Footer 196,"'36.5. Example: Stickman",'4237,'86.47460938
'282,'Page number 281,"'277",'4238,'71.92382813
'283,'Header 267,"'Programming and Data Structures, Release 0.3",'4239,'58.05664063
'283,'Text 2912,"'for (std: : size_t i=0;i< game.puzzle.size(); { if (is_lowercase(game.puzzle[i])) { game.puzzle[i] = '_'; ++game.remaining_letters; } }",'4240,'94.72656250
'283,'Text 2913,"'Iterating over a string works the same way as iterating over a vector. We use a for loop from 0 up to the size of the string, and we use square brackets to index into the string to obtain the character at that position. Unlike in some other languages, C++ strings are mutable, meaning that they can be modified, and we do SO here by replacing each lowercase letter with an underscore character. We also increment the number of remaining letters each time we encounter a lowercase letter.",'4241,'98.19335938
'283,'Text 2914,"'Putting this all together, the following defines our make_game( function:",'4242,'90.18554688
'283,'Text 2915,"'Game make_game(std::string answer) { Game game e={0,O,answer, answer }; for (std: size_t i=0;i < game.puzzle.size() ++i) if owercase(game.puzzle[i])) { game.puzzle[i]='_'; ++game.remaining_letters; } } return game; }",'4243,'94.43359375
'283,'Text 2916,"'To print a game, we print out the stick figure corresponding to the current number of incorrect guesses:",'4244,'94.62890625
'283,'Text 2917,"'std: : cout << STICK_FIGURES[game.miss_count] <<"" "" "";",'4245,'53.61328125
'283,'Figure 103,"",'4246,'26.70898438
'283,'Figure 104,"",'4247,'34.64355469
'283,'Text 2918,"'We add a bit of space between the figure and the puzzle. We then print out each of the characters in the puzzle, separated by spaces:",'4248,'96.48437500
'283,'Text 2919,"'for (std::size_t i=o;i < game.puzzle.size() ++i) { std:: cout << "" << game.puzzle[i]; }",'4249,'93.16406250
'283,'Text 2920,"'In addition, we add extra newlines to visually separate the turns from each other. The full function definition is as follows:",'4250,'96.48437500
'283,'Text 2921,"'void print_game (Game &game) { std: : cout << endl; std: : cout << STICK_FIGURES [game.miss_count] <<""""; for (std: :size_t i=0; < game.puzzle.size(); ++i) std: cout << "" << game.puzzle[i]; } std::cout << ""\n"" << endl; }",'4251,'93.60351563
'283,'Text 2922,"'Next, we implement the get_guess() function to obtain a guess from the player. At a high level, this function needs to do the following:",'4252,'94.14062500
'283,'List 99,"",'4253,'86.86523438
'283,'Text 2923 - Part of List 99,"'Obtain a string from the standard input stream.",'4254,'95.75195313
'283,'Text 2924 - Part of List 99,"'Check whether the string is a valid guess - it must be a single letter, and the letter must be lowercase.",'4255,'96.14257813
'283,'Footer 197,"'36.5. Example: Stickman",'4256,'74.21875000
'283,'Page number 282,"'278",'4257,'84.42382813
'284,'Header 268,"'Programming and Data Structures, Release 0.3",'4258,'64.06250000
'284,'List 100,"",'4259,'97.60742188
'284,'Text 2925 - Part of List 100,"'If the guess is invalid, repeat the process.",'4260,'98.63281250
'284,'Text 2926 - Part of List 100,"'If the guess is valid, return the guessed letter.",'4261,'98.43750000
'284,'Text 2927,"'There's one more case we need to handle - what happens if we reach the end of the stream, when no more input is available? (On most systems, a user can manually end the standard input stream with the Ctrl-d keyboard input. We will also see later that input can be redirected from a file, in which case the input stream ends when it reaches the end of the file.) In such a case, we will return immediately with an error value that is different from any valid guess:",'4262,'98.63281250
'284,'Text 2928,"'const char ERROR_CHAR = '\0'; // special ""null"" character",'4263,'53.80859375
'284,'Text 2929,"'The following is a definition of get_guess():",'4264,'80.76171875
'284,'Text 2930,"'char get_guess() std::cout << ""Enter a lowercase letter to guess:"" << std: endl std: :string input; while (std::cin >> input) { if (input.size() != { cout << ""Error: guess must be exactly one letter"" Ed::endl; } else if (!is_lowercase(input[0])) { cout << ""Error: guess must be between a and z"" << } else { return input [0]; } } return ERROR_CHAR; }",'4265,'96.04492188
'284,'Text 2931,"'The std: cin object represents the standard input stream, similar to how std: : cout is the standard output stream. We extract from an input stream using the >> operator, which is called the stream-extraction operator in this context. To extract a string, we use a std: string object as the right-hand side of the operator. It is common practice to perform this extraction in the condition of a loop. If the extraction succeeds, the condition has a true value, and the body of the loop runs. If the extraction fails (e.g. in the case of the end of the stream), the loop condition is false, and the loop exits. In this function, we return ERROR_CHAR when the extraction fails.",'4266,'97.31445313
'284,'Text 2932,"'The function starts by prompting the player to enter a guess. It then reads input in a loop, checking whether or not the input is a valid guess. If the guess is invalid, a message describing the problem is printed, and the loop moves on to the next iteration, reading another input. If the guess is valid, the lone character in the input string is returned.",'4267,'97.11914063
'284,'Text 2933,"'We now go ahead and implement the update_game () function. The function needs to iterate over the characters in the answer to check if any are the same as the guess. If so, we additionally need to check whether the letter has already been guessed. If it has not been guessed, the corresponding position in the puzzle string has an underscore. In this case, we replace the underscore with the actual letter and decrement the count of remaining letters:",'4268,'97.85156250
'284,'Text 2934,"'for (std::size_ i = 0; i < answer size ++i) { if (game. answer[i] == guess && game.puzzle[i] == , '_) { game.puzzle[i] = guess; // replace the - with the actual letter -game.remaining_letters; } }",'4269,'97.16796875
'284,'Text 2935,"'The function also needs to update the miss_count member variable depending on whether the guess was a correct one or not. We can't know this until we have traversed the entire puzzle, and we use a separate boolean to track this. The full function definition below demonstrates this logic:",'4270,'96.72851563
'284,'Footer 198,"'36.5. Example: Stickman",'4271,'77.58789063
'284,'Page number 283,"'279",'4272,'89.50195313
'285,'Header 269,"'Programming and Data Structures, Release 0.3",'4273,'54.58984375
'285,'Text 2936,"'void update_game(Game &game, char guess) { bool correct_guess = false; for (std::size_t i = o;i < game.answer.size(); ++i) if (game.answer[i] == guess && game.puzzle[i]=='_"") { game.puzzle[i] = guess; // replace the with the actual letter -game.remaining_letters; correct_guess = true; } } if (! correct_guess) { ++game.miss_count; } }",'4274,'96.82617188
'285,'Text 2937,"'Lastly, we can write the top-level function that plays a game. It starts by creating a Game object via make_game(). It then has a loop that:",'4275,'97.02148438
'285,'List 101,"",'4276,'93.40820313
'285,'Text 2938 - Part of List 101,"'Prints the game using print_game ().",'4277,'97.41210938
'285,'Text 2939 - Part of List 101,"'Obtains a guess from the player via get_guess(). If ERROR_CHAR is returned, the game immediately exits.",'4278,'98.43750000
'285,'Text 2940 - Part of List 101,"'Updates the game using update_game().",'4279,'98.43750000
'285,'Text 2941,"'Other than the ERROR_CHAR condition, the game terminates either when all letters have been guessed, or the player has made the maximum number of incorrect guesses. Thus, the following is the main loop:",'4280,'96.97265625
'285,'Text 2942,"'while (game.remaining_letters > 0 && game.miss_count < MAX_MISSES) { print_game(game) char letter = get_guess () ; if (letter == ERROR_CHAR) { cout << ""Quitting."" << endl; return; // quit the game } update_game(game, letter); }",'4281,'31.44531250
'285,'Text 2943,"'After the game is over, we print the game once more to show its final state. We then print a message to the player depending on whether or not they won, as shown in the full function definition below:",'4282,'96.82617188
'285,'Text 2944,"'void play_game(std::string answer) { Game game = make_game(answer); while (game.remaining_letters > 0 && game.miss_count < MAX_MISSES) { print_game(game) char letter = get_guess() ; if (letter == ERROR_CHAR) { std::cout << ""Quitting."" << std::endl; return; // quit the game } update_game(game,letter); } print_game(game) ; if (game.remaining_letters == 0) { std: << ""Congratulations ! "" << std::endl: } else { std::cout << ""Better luck next time!' << std::endl;",'4283,'59.08203125
'285,'Text 2945,"'(continues on next page)",'4284,'65.82031250
'285,'Footer 199,"'36.5. Example: Stickman",'4285,'62.59765625
'285,'Page number 284,"'280",'4286,'85.79101563
'286,'Header 270,"'Programming and Data Structures, Release 0.3",'4287,'78.85742188
'286,'Text 2946,"'}",'4288,'32.00683594
'286,'Text 2947,"'(continued from previous page)",'4289,'48.63281250
'286,'Header 271,"'}",'4290,'25.02441406
'286,'Section header 195,"'36.5.5 Testing and File Organization",'4291,'42.91992188
'286,'Text 2948,"'Before we write a main () function that plays the game, we might want to write some code that tests individual functions in our program. For example, the following code does a basic test of the make_game function:",'4292,'95.75195313
'286,'Section header 196,"'#include <cassert> #include <string>",'4293,'40.45410156
'286,'Text 2949,"'void test_make_game() { std: :string answer = ""hello world!""; Game game = make_game (answer); assert (game.miss_count 0); assert (game.remaining_letters 10); assert (game.puzzle == !""); assert (game. answer == answer); } int main() { test_make_game( }",'4294,'38.03710938
'286,'Text 2950,"'The test_make_game function creates a Game object from the ""hello world!"" answer string. It then asserts that each of the member variables of the Game object has the expected value. The assert() construct is defined in the cassert library header, which we have included at the top.",'4295,'93.26171875
'286,'Text 2951,"'Observe that the test code has its own main function, SO it needs to be in a separate cpp source file than the main() function that actually plays a game of stickman. Let's assume that the function definitions above are placed in stickman. cpp, and our test code is in test. cpp. The compiler will process these two files individually, even if they are both provided in a single compilation command. How can we make the compiler aware of the functions defined in stickman. cpp when it is compiling test. cpp?",'4296,'95.84960938
'286,'Text 2952,"'The compiler actually only needs access to the declarations of the functions we use, not the definitions. It does need access to the definition of the Game struct, since it needs to know what member variables the struct has. Thus, common practice is to place struct definitions, function declarations, and constants in a separate header file, conventionally with a file extension such as hpp. The following code can be placed in stickman.hpp:",'4297,'94.67773438
'286,'Text 2953,"'#include <string> #include <vector>",'4298,'43.67675781
'286,'Text 2954,"'// Stick figures corresponding to each possible number of misses. const std::vector<std::string> STICK_FIGURES = { ""\n\n 'o\n\n "" 0\n//\n "" o\n//\\\n "" o\n//\\\n/ "" o\n//\\\n/ };",'4299,'31.66503906
'286,'Text 2955,"'(continues on next page)",'4300,'63.76953125
'286,'Footer 200,"'36.5. Example: Stickman",'4301,'39.99023438
'286,'Page number 285,"'281",'4302,'83.93554688
'287,'Header 272,"'Programming and Data Structures, Release 0.3",'4303,'67.82226563
'287,'Header 273,"'(continued from previous page)",'4304,'40.91796875
'287,'List 102,"",'4305,'55.90820313
'287,'Text 2956 - Part of List 102,"'// Maximum number of missed guesses. const int MAX_MISSES = 6;",'4306,'78.27148438
'287,'Text 2957 - Part of List 102,"'// Used to indicate an error when reading user input. const char ERROR_CHAR = ""\O' ; // special ""null"" character",'4307,'66.11328125
'287,'Text 2958 - Part of List 102,"'// A struct to represent the state of a game of stickman. struct Game {",'4308,'48.43750000
'287,'Text 2959 - Part of List 102,"'// The number of wrong guesses made so far. int miss_count;",'4309,'49.21875000
'287,'Text 2960 - Part of List 102,"'// The number of remaining unguessed positions in the puzzle. int remaining_letters;",'4310,'46.67968750
'287,'Text 2961 - Part of List 102,"'// The current state of the puzzle, with underscores representing // unguessed letters. std: : string puzzle;",'4311,'35.13183594
'287,'Text 2962 - Part of List 102,"'// The answer to the puzzle. std: string answer;",'4312,'29.37011719
'287,'Text 2963 - Part of List 102,"'};",'4313,'46.74871826
'287,'Text 2964 - Part of List 102,"'// EFFECTS: Returns a properly initialized Game object corresponding // to the given answer phrase. Game make game (std: : string answer);",'4314,'31.83593750
'287,'Text 2965 - Part of List 102,"'// REQUIRES: game.miss_count <= MAX MISSES",'4315,'99.89457703
'287,'Text 2966 - Part of List 102,"'// MODIFIES: cout",'4316,'99.87777710
'287,'Text 2967 - Part of List 102,"'// EFFECTS: Prints the state of the game to standard output.",'4317,'99.97901154
'287,'Text 2968 - Part of List 102,"'void print_game(Game &game);",'4318,'99.43594360
'287,'Text 2969 - Part of List 102,"'// MODIFIES: cout, cin",'4319,'99.05245972
'287,'Text 2970 - Part of List 102,"'// EFFECTS: Repeatedly prompts the user for a guess consisting of a",'4320,'99.91418457
'287,'Text 2971 - Part of List 102,"'//",'4321,'99.27851105
'287,'Text 2972 - Part of List 102,"'single lowercase letter until a valid guess is provided,",'4322,'99.88790131
'287,'Text 2973 - Part of List 102,"'//",'4323,'99.87458038
'287,'Text 2974 - Part of List 102,"'or the end of stream is reached. Returns the guess in",'4324,'99.94832611
'287,'Text 2975 - Part of List 102,"'//",'4325,'97.51988983
'287,'Text 2976 - Part of List 102,"'the first case, or ERROR_CHAR in the second.",'4326,'99.91888428
'287,'Text 2977 - Part of List 102,"'char get_guess()",'4327,'99.89249420
'287,'Text 2978 - Part of List 102,"'// MODIFIES: game",'4328,'99.75945282
'287,'Text 2979 - Part of List 102,"'// EFFECTS: Updates the game's puzzle and miss count according to",'4329,'99.84921265
'287,'Text 2980 - Part of List 102,"'//",'4330,'99.57073975
'287,'Text 2981 - Part of List 102,"'whether the guess is a letter in the answer and has not",'4331,'99.82401276
'287,'Text 2982 - Part of List 102,"'//",'4332,'99.58074188
'287,'Text 2983 - Part of List 102,"'been previously guessed.",'4333,'99.97631836
'287,'Text 2984 - Part of List 102,"'void update_ game (Game &game, char guess);",'4334,'99.84313965
'287,'Text 2985 - Part of List 102,"'// MODIFIES: cout, cin",'4335,'99.26998901
'287,'Text 2986 - Part of List 102,"'// EFFECTS: Plays a game of stickman with the given answer, reading",'4336,'99.89281464
'287,'Text 2987 - Part of List 102,"'//",'4337,'99.78373718
'287,'Text 2988 - Part of List 102,"'guesses from standard in and writing game details to",'4338,'99.96278381
'287,'Text 2989 - Part of List 102,"'//",'4339,'99.79866791
'287,'Text 2990 - Part of List 102,"'standard out. The game ends if the end of standard input",'4340,'99.89178467
'287,'Text 2991 - Part of List 102,"'//",'4341,'99.83499146
'287,'Text 2992 - Part of List 102,"'is reached, the player exhausts the maximum number of",'4342,'99.95652771
'287,'Text 2993 - Part of List 102,"'//",'4343,'99.58846283
'287,'Text 2994 - Part of List 102,"'incorrect guesses, or the player correctly guesses all",'4344,'99.91120911
'287,'Text 2995 - Part of List 102,"'//",'4345,'99.85944366
'287,'Text 2996 - Part of List 102,"'letters.",'4346,'99.92175293
'287,'Text 2997,"'(continues on next page)",'4347,'42.91992188
'287,'Footer 201,"'36.5. Example: Stickman",'4348,'66.11328125
'287,'Page number 286,"'282",'4349,'90.47851563
'288,'Header 274,"'Programming and Data Structures, Release 0.3",'4350,'66.21093750
'288,'Text 2998,"'(continued from previous page)",'4351,'38.81835938
'288,'Text 2999,"'void play_game(std::string answer);",'4352,'53.71093750
'288,'Text 3000,"'We start by including the string and vector standard libraries, since the code in stickman. hpp uses both strings and vectors. We then have our constant definitions, followed by the definition of the Game struct. Lastly, we have function definitions for each task in the game. We have included documentation in the form of RMEs (requires, modifies, and effects):",'4353,'97.80273438
'288,'List 103,"",'4354,'95.21484375
'288,'Text 3001 - Part of List 103,"'The requires clause specifies what is required to be true prior to calling the function. These are also called preconditions. All bets are off if these conditions are violated: we get the dreaded undefined behavior. The function's implementation is allowed to assume that these conditions are met - it is not required to check them in any way.",'4355,'97.21679688
'288,'Text 3002 - Part of List 103,"'The modifies clause lists the objects outside the function that might modified by a call to the function. We generally include cout if the standard output stream is written to, and cin if input is read from the standard input stream. Pass-by-reference parameters are included if their contents might be modified.",'4356,'97.36328125
'288,'Text 3003 - Part of List 103,"'The effects clause tells us what the function actually does, i.e. what the return value means and how any objects in the modifies clause are actually modified. The effects are sometimes also called postconditions. This clause only specifies the ""what"", not the ""how""; we will come back to this later.",'4357,'97.65625000
'288,'Text 3004,"'Now that we have this code in stickman.hpp, we can include it in both test. cpp and stickman. cpp. The contents of test. cpp are as follows:",'4358,'96.04492188
'288,'Text 3005,"'#include <cassert> #include ""stickman. hpp""",'4359,'80.37109375
'288,'Text 3006,"'void test_make_game() { std: :string answer = ""hello world!""; Game game = make_game (answer); assert (game.miss_count == 0) ; assert (game.remaining_letters == 10); assert (game .puzzle == "" !""); assert (game answer == answer); } int main() { test_make_game () ; }",'4360,'74.21875000
'288,'Text 3007,"'The #include ""stickman.hpp' directive pulls in the code from stickman.hpp into the current file. We use quotes around the filename rather than the angle brackets we use with a library header. Observe that we no longer need the #include <string> directive, since stickman. hpp already contains that.",'4361,'93.84765625
'288,'Text 3008,"'The full contents of stickman. cpp are as follows:",'4362,'51.95312500
'288,'Table 79,"",'4363,'31.66503906
'288,'Footer 202,"'36.5. Example: Stickman",'4364,'55.56640625
'288,'Page number 287,"'283",'4365,'81.68945313
'289,'Header 275,"'Programming and Data Structures, Release 0.3",'4366,'61.23046875
'289,'Text 3009,"'(continued from previous page)",'4367,'75.63476563
'289,'Text 3010,"'return value >= 'a' && value <= 'z'; } Game make_game(string answer) { Game game={0,0,answer,answer }; for (size_t i = O; i < game.puzzle.size() ; ++i) { if (is_lowercase(game.puzzle[i])) { game.puzzle[i] = '_' ++game.remaining_letters } } return game; }",'4368,'72.70507813
'289,'Text 3011,"'void print_game(Game & &game) { cout << endl; cout STICK_FIGURES[game.miss_count] << "" ""; for (size_t i=0; i < game.puzzle.size() ++i) { cout << "" "" << game.puzzle[i]; } cout ""\n"" << endl; }",'4369,'89.50195313
'289,'Text 3012,"'char get_guess() { cout << ""Enter a lowercase letter to guess:"" << endl ; string input; while (cin >> input) { if (input.size() != 1) { cout << ""Error: guess must be exactly one letter"" << endl; } else if (!is_lowercase(input[0])) { cout << ""Error: guest must be between a and z"" << endl; } else { return input [0] ; } } return ERROR_CHAR; }",'4370,'89.30664063
'289,'Text 3013,"'void update_game (Game &game, char guess) { bool correct_guess = false; for (size_t i = 0; i < game.answer.size(); ++i) { if (game.answer[i] == guess && game.puzzle[i] == __) { game.puzzle[i] = guess; // replace the - with the actual letter game.remaining_letters; correct_guess = true; } } if !correct_guess) { ++game.miss_count; } }",'4371,'83.59375000
'289,'Text 3014,"'(continues on next page)",'4372,'93.45703125
'289,'Footer 203,"'36.5. Example: Stickman",'4373,'66.35742188
'289,'Page number 288,"'284",'4374,'86.76757813
'290,'Header 276,"'Programming and Data Structures, Release 0.3",'4375,'78.32031250
'290,'Text 3015,"'(continued from previous page)",'4376,'81.93359375
'290,'Text 3016,"'void play_game (string answer) { Game game = make_game(answer) ; while (game.remaining_letters 0 && game.miss_count < MAX_MISSES) { print_game (game) ; char letter = get_guess () ; if (letter == ERROR_CHAR) { cout << ""Quitting."" endl; return; // quit the game } update_game(game, letter); } print_game(game) if (game.remaining_letters == cout << ""Congratulations!"" << endl; } else { cout << ""Better luck next time!"" << endl; } }",'4377,'63.96484375
'290,'Text 3017,"'We include iostream, since that is not included by stickman. hpp. We don't have struct or constant definitions, since those are defined in the stickman. hpp header. Instead, we just have the definitions for each function.",'4378,'94.72656250
'290,'Text 3018,"'We made a few minor changes from before:",'4379,'88.76953125
'290,'List 104,"",'4380,'96.28906250
'290,'Text 3019 - Part of List 104,"'We added using directives SO that we can use specific standard-library entities without the std: qualification.",'4381,'97.85156250
'290,'Text 3020 - Part of List 104,"'We preceded the definition of is_lowercase with the static keyword. This is common practice for a helper function, and it prevents the function from conflicting with a function of the same name defined in some other source file.",'4382,'98.38867188
'290,'Text 3021,"'We can now compile and run the test code. We provide both . cpp source files to the compilation command, but not the hpp file - its contents are pulled directly into the . cpp files via the #include ""stickman.hpp' directive:",'4383,'96.87500000
'290,'Text 3022,"'$ g++ -std=c++17 -o test.exe test.cp stickman. cpp $ ./test.exe",'4384,'88.81835938
'290,'Text 3023,"'The assertions all succeed, SO we don't see any output.",'4385,'95.06835938
'290,'Text 3024,"'Lastly, we can write a separate play cpp file that has a main() function to play the game. The following are the contents of the file:",'4386,'96.72851563
'290,'Text 3025,"'#include <iostream> #include ""stickman.hpp"" int main(int argc, char *argv[]) { if (argc < 2) { std::cout << ""Usage: argv[0] "" <answer> "" << std::endl return 1; } play_game(argv[1]) }",'4387,'37.47558594
'290,'Text 3026,"'We use an alternate signature for main () that gives us access to the command-line arguments given to the program. The first argument is always the name of the program executable. We take the game answer as the second argument, SO we start by checking whether there are at least two arguments. If not, we print an error message and return with a nonzero value. If an answer is provided, we invoke the top-level play_game function with the answer.",'4388,'95.26367188
'290,'Footer 204,"'36.5. Example: Stickman",'4389,'58.39843750
'290,'Page number 289,"'285",'4390,'78.12500000
'291,'Header 277,"'Programming and Data Structures, Release 0.3",'4391,'50.09765625
'291,'Text 3027,"'We compile and run the program as follows:",'4392,'50.87890625
'291,'Table 80,"",'4393,'32.47070313
'291,'Text 3028,"'(continues on next page)",'4394,'55.17578125
'291,'Footer 205,"'36.5. Example: Stickman",'4395,'74.46289063
'291,'Page number 290,"'286",'4396,'59.91210938
'292,'Header 278,"'Programming and Data Structures, Release 0.3",'4397,'51.75781250
'292,'Text 3029,"'(continued from previous page)",'4398,'61.23046875
'292,'Text 3030,"'ii o o r 1 ! - - Enter a lowercase letter to guess: d o /I\ /i\ orld! - Enter a lowercase letter to guess: W o /I\ world! Congratulations",'4399,'50.78125000
'292,'Footer 206,"'36.5. Example: Stickman",'4400,'88.42773438
'292,'Page number 291,"'287",'4401,'73.09570313
'293,'Text 3031,"'CHAPTER",'4402,'47.36328125
'293,'Header 279,"'THIRTYSEVEN",'4403,'43.96972656
'293,'Title 71,"'SOLVING PROBLEMS WITH RECURSION",'4404,'84.27734375
'293,'Text 3032,"'To conclude our discussion of recursion, we take a look at several complex problems and how to approach them from a recursive standpoint. Our strategy will be to:",'4405,'97.75390625
'293,'List 105,"",'4406,'84.27734375
'293,'Text 3033 - Part of List 105,"'Identify the cases we can solve directly. These are base cases.",'4407,'97.60742188
'293,'Text 3034 - Part of List 105,"'Determine how to express a general case in terms of smaller subproblems. This is the recursive case.",'4408,'97.70507813
'293,'Text 3035,"'For the latter, the first step is to identify appropriate subproblems, and the second is to figure out how to express the solution for the whole problem in terms of the solutions to the subproblems. This leads to a recurrence relation, which we can then implement in code.",'4409,'97.70507813
'293,'Section header 197,"'37.1 Pancake Sort",'4410,'92.48046875
'293,'Text 3036,"'Suppose you want to sort a stack of irregular pancakes such that they are in order, with the smallest at the top and the largest at the bottom. So as not to contaminate the pancakes, you would like to do SO just by repeatedly flipping a subset of the pancakes with a spatula, which reverses the set of pancakes above the spatula, as shown in Figure 37.1. The goal is to come up with a generalized algorithm for sorting the pancakes just by flipping substacks from any point in the stack to the top.",'4411,'96.67968750
'293,'Figure 105,"",'4412,'92.28515625
'293,'Text 3037,"'Allowed Move",'4413,'42.82226563
'293,'Text 3038,"'Figure 37.1: The pancake problem is to sort a stack of pancakes, where the only allowed move is to flip a subset of the stack from a point in the middle to the top.",'4414,'95.99609375
'293,'Text 3039,"'We start by identifying cases we can solve directly. An empty stack or one with just a single pancake are trivially sorted, SO these are the base cases.",'4415,'96.24023438
'293,'Text 3040,"'We then need to identify a subproblem. For a stack of n pancakes, a natural subproblem is to sort a stack of n - 1 pancakes. So we now have to figure out how to reduce the problem of sorting n pancakes to that of sorting n - 1",'4416,'94.58007813
'293,'Page number 292,"'288",'4417,'82.32421875
'294,'Header 280,"'Programming and Data Structures, Release 0.3",'4418,'71.77734375
'294,'Text 3041,"'pancakes - we just need the largest pancake on the bottom, and then the substack above that has n - 1 pancakes that need sorting.",'4419,'98.63281250
'294,'Text 3042,"'The final step is to come up with a way of getting the largest pancake to the bottom. We know that if that pancake is at the top, we can flip the whole stack to get it to the bottom. So now the problem is how to get the largest pancake to the top. Placing the spatula under that pancake and flipping the stack above does the trick.",'4420,'98.14453125
'294,'Text 3043,"'Thus, we have identified our recurrence:",'4421,'94.33593750
'294,'List 106,"",'4422,'96.09375000
'294,'Text 3044 - Part of List 106,"'Nothing need be done for a stack of zero or one.",'4423,'97.90039063
'294,'Text 3045 - Part of List 106,"'For n pancakes where n > 1, we place the spatula under the largest pancake and flip, moving it to the top. We then flip the whole stack, moving the largest pancake to the bottom. We then repeat the process on the n - 1 pancakes above the largest.",'4424,'98.09570313
'294,'Text 3046,"'Figure 37.2 illustrates this recurrence.",'4425,'88.03710938
'294,'Figure 106,"",'4426,'96.43554688
'294,'Text 3047,"'Figure 37.2: The pancake-sort algorithm flips the largest pancake to the top, then the whole stack, then recurses on a smaller stack.",'4427,'96.48437500
'294,'Text 3048,"'We can implement this algorithm in code to sort an array of integers, considering the top of the stack to be at the beginning of the array and the bottom at the end. We make use of the reverse () function we wrote previously to flip a subset of the stack.",'4428,'97.46093750
'294,'Text 3049,"'void pancake_sort (int *stack, int size) { if (size > 1) { // find position of largest element int *largest = std: :max_element (stack, stack + size) // flip the stack from the top to the largest element reverse (stack, largest) // flip the whole stack reverse (stack, stack + size - 1); // recurse on a smaller stack pancake_sort(stack, size - 1); } }",'4429,'50.58593750
'294,'Text 3050,"'Here, we use std: :max_element from the <algorithm> library to find the largest item in the stack.",'4430,'91.89453125
'294,'Footer 207,"'37.1. Pancake Sort",'4431,'84.17968750
'294,'Page number 293,"'289",'4432,'87.64648438
'295,'Header 281,"'Programming and Data Structures, Release 0.3",'4433,'54.29687500
'295,'Section header 198,"'37.2 Tower of Hanoi",'4434,'70.01953125
'295,'Text 3051,"'The Tower of Hanoi puzzle consists of three rods with n disks of varying size arranged in sorted order on the first rod, as shown in Figure 37.3. The objective is to move the entire stack of disks to another rod, while obeying the following constraints:",'4435,'97.75390625
'295,'List 107,"",'4436,'94.77539063
'295,'Text 3052 - Part of List 107,"'Only one disk can be moved at a time.",'4437,'97.60742188
'295,'Text 3053 - Part of List 107,"'Only the top disk at a rod can be moved.",'4438,'97.26562500
'295,'Text 3054 - Part of List 107,"'A larger disk may never be placed on top of a smaller one.",'4439,'97.99804688
'295,'Figure 107,"",'4440,'95.16601563
'295,'Figure 108,"",'4441,'65.77148438
'295,'Figure 109,"",'4442,'85.83984375
'295,'Text 3055,"'Figure 37.3: The Tower of Hanoi problem moves a stack of disks from an initial rod to a target rod.",'4443,'95.99609375
'295,'Text 3056,"'To come up with an algorithm to solve this puzzle, we first identify the base cases that can be solved directly. For n = 1, the lone disk can be moved directly without violating the constraints, constituting our base case.",'4444,'94.58007813
'295,'Text 3057,"'For n > 1, the subproblem is moving n - 1 disks between rods. Then our task is to determine how to express the solution for moving n disks in terms of the solution to moving n - 1 disks. We observe that we can completely ignore the largest disk when moving the n - 1 smaller disks; since any of the latter can be placed on the largest disk, the rod with the largest disk acts just like an empty rod. Thus, we can move the n - 1 smaller disks as a stack of their own, from the start rod to the middle rod. We can then move the largest disk directly to the empty target rod. Then all that is left is to move the stack of n - 1 smaller disks to the target rod.",'4445,'96.97265625
'295,'Text 3058,"'Figure 37.4 illustrates this algorithm. We take the recursive leap of faith, assuming that we can move the smaller n 1 stack as a whole using recursion, without worrying about the details of how it is done. As long as the subproblem is closer to the base case than the original problem, we get to make the assumption that the subproblem will be solved correctly.",'4446,'95.55664063
'295,'Figure 110,"",'4447,'94.28710938
'295,'Text 3059,"'Figure 37.4: An algorithm for the Tower of Hanoi is to use recursion to move a smaller stack and move the largest disk on its own.",'4448,'89.64843750
'295,'Text 3060,"'The following code implements the algorithm, printing out the moves required to move n disks from a start to end rod:",'4449,'87.84179688
'295,'List 108,"",'4450,'25.04882813
'295,'Text 3061 - Part of List 108,"'// MODIFIES cout // EFFECTS Prints a move of disk n from start to end. void move (int n, int start, int end) { std: : cout << ""Move disk n from rod 11 << start << to rod "" end << std: : endl ;",'4451,'40.60058594
'295,'Text 3062 - Part of List 108,"'(continues on next page)",'4452,'99.38961792
'295,'Footer 208,"'37.2. Tower of Hanoi",'4453,'69.28710938
'295,'Page number 294,"'290",'4454,'87.69531250
'296,'Title 72,"'Programming and Data Structures, Release 0.3",'4455,'65.33203125
'296,'Text 3063,"'(continued from previous page)",'4456,'78.41796875
'296,'Text 3064,"'}",'4457,'93.70117188
'296,'Text 3065,"'// REQUIRES: n >= 1 // MODIFIES: cout // EFFECTS: Prints the sequence of moves required to move n disks // from start to end, using temp as the temporary rod. void hanoi (int n, int start, int temp, int end) { if (n == 1) { move (n, start, end) } else { hanoi (n - 1, start, end, temp) ; move (n, start, end) ; hanoi (n - 1, temp, start, end); } }",'4458,'88.13476563
'296,'Text 3066,"'The result of hanoi (5, 1, 2, 3) is as follows:",'4459,'66.01562500
'296,'Table 81,"",'4460,'36.10839844
'296,'Footer 209,"'37.2. Tower of Hanoi",'4461,'39.59960938
'296,'Page number 295,"'291",'4462,'87.35351563
'297,'Header 282,"'Programming and Data Structures, Release 0.3",'4463,'67.04101563
'297,'Section header 199,"'37.3 Counting Change",'4464,'41.40625000
'297,'Text 3067,"'As a final example, let us consider the number of ways we can change a dollar into coins, using any quantity of half dollars (50c), quarters (25c), dimes (10c), nickels (5c), and pennies (1c). The following are three possible ways:",'4465,'97.21679688
'297,'List 109,"",'4466,'91.16210938
'297,'Text 3068 - Part of List 109,"'$1 = 1 half dollar, 1 quarter, 2 dimes, 1 nickel",'4467,'97.99804688
'297,'Text 3069 - Part of List 109,"'$1 = 2 quarters, 2 dimes, 30 pennies",'4468,'97.70507813
'297,'Text 3070 - Part of List 109,"'$1 = 100 pennies",'4469,'97.50976563
'297,'Text 3071,"'There are too many ways to enumerate them all manually. Instead, let's take a look at a smaller example of the same problem: the number of ways to make change for 11c using dimes, nickels, and pennies. There are exactly four:",'4470,'96.63085938
'297,'List 110,"",'4471,'91.94335938
'297,'Text 3072 - Part of List 110,"'11c = 1 dime, 1 penny",'4472,'97.60742188
'297,'Text 3073 - Part of List 110,"'11c = 2 nickels, 1 penny",'4473,'97.36328125
'297,'Text 3074 - Part of List 110,"'11c = 1 nickel, 6 pennies",'4474,'97.36328125
'297,'Text 3075 - Part of List 110,"'11c = 11 pennies",'4475,'95.94726563
'297,'Text 3076,"'We can categorize these solutions according to which coins they use, as shown in Figure 37.5.",'4476,'89.69726563
'297,'Figure 111,"",'4477,'84.91210938
'297,'Text 3077,"'Figure 37.5: The ways to count change can be subdivided into those that use a particular coin and those that don't.",'4478,'89.64843750
'297,'Text 3078,"'If we decide to use a particular coin, we are left with the subproblem of making a smaller amount of change using the same set of coins. For example, if we choose to use a dime, we need only make 1c using dimes, nickels, and pennies. On the other hand, if we choose not to use a particular coin, we must make the full amount of change with a smaller set of coins. In our example, if we decide not to use a dime, we must make the full 11c with only nickels and pennies. If we then use a nickel, we are left with making 6c with only nickels and pennies.",'4479,'95.45898438
'297,'Text 3079,"'Figure 37.6 illustrates a decision tree for how to make change. At any point in time, we have a target amount and a set of available coins. We then decide whether to use the largest of our available coins. Either decision leads to a subproblem:",'4480,'92.13867188
'297,'List 111,"",'4481,'83.49609375
'297,'Text 3080 - Part of List 111,"'Making a smaller amount of change with the same set of available coins.",'4482,'97.80273438
'297,'Text 3081 - Part of List 111,"'Making the same amount of change with a smaller set of available coins.",'4483,'96.97265625
'297,'Text 3082,"'Thus, we have a recurrence that expresses the solution for a full problem in terms of two subproblems.",'4484,'92.67578125
'297,'Text 3083,"'We also need to identify base cases that we can solve directly:",'4485,'90.28320313
'297,'List 112,"",'4486,'85.40039063
'297,'Text 3084 - Part of List 112,"'If the change amount is zero, there is only one way to do that: use no coins.",'4487,'96.58203125
'297,'Text 3085 - Part of List 112,"'If the change amount is negative, there is no way to do that, since we do not have negative coins.",'4488,'96.58203125
'297,'Footer 210,"'37.3. Counting Change",'4489,'86.66992188
'297,'Page number 296,"'292",'4490,'80.37109375
'298,'Header 283,"'Programming and Data Structures, Release 0.3",'4491,'86.08398438
'298,'Figure 112,"",'4492,'94.77539063
'298,'Text 3086,"'Make 11c using 1, 5",'4493,'88.91601563
'298,'Text 3087,"'Figure 37.6: The decision tree for which coin to use consists of a subtree that uses a particular coin and another that doesn't.",'4494,'95.01953125
'298,'Footer 211,"'37.3. Counting Change",'4495,'83.59375000
'298,'Page number 297,"'293",'4496,'75.04882813
'299,'Header 284,"'Programming and Data Structures, Release 0.3",'4497,'50.29296875
'299,'Text 3088,"'If the change amount is positive but we have no coins available, we cannot make that change.",'4498,'98.53515625
'299,'Text 3089,"'The following implements the resulting algorithm in code:",'4499,'89.69726563
'299,'Text 3090,"'// EFFECTS: Returns the number of ways to make amount in change // using only the coin denominations in kinds. int count_change (int amount, const int kinds [], int num_kinds) { if (amount == 0) { // one way to make nothing: use no coins return 1; } else if (amount < 0 1 num_kinds < 1) { // cannot make negative amount, or anything with no coins return 0; } else { return // use the largest coin, reducing the amount of change to make count_change (amount - kinds [num_kinds - 1], kinds, num_kinds) + // don't use the largest coin, reducing the available coins count_change (amount, kinds, num_kinds - 1); } }",'4500,'88.47656250
'299,'Text 3091,"'This tree-recursive implementation is very inefficient, repeating the same computations many times. Techniques such as memoization and dynamic programming can drastically improve the efficiency, but they are beyond the scope of this course. (With such a technique in place, the result is 292 for the number of ways to make change for a dollar.)",'4501,'92.18750000
'299,'Footer 212,"'37.3. Counting Change",'4502,'36.03515625
'299,'Page number 298,"'294",'4503,'86.71875000
'300,'Text 3092,"'CHAPTER",'4504,'41.57714844
'300,'Header 285,"'THIRTYEIGHT",'4505,'43.77441406
'300,'Title 73,"'CONTAINERS OF POINTERS",'4506,'59.47265625
'300,'Text 3093,"'Recall the linked-list class template we defined previously:",'4507,'96.24023438
'300,'Table 82,"",'4508,'41.96777344
'300,'Text 3094,"'We declared the parameters of push front O and push_back() to be passed by reference, avoiding making a copy of the argument value. However, a Node stores a value of type T, SO a copy is made when a node is created:",'4509,'91.30859375
'300,'Text 3095,"'template <typename T>",'4510,'33.59375000
'300,'Figure 113,"",'4511,'41.30859375
'300,'Text 3096,"'void List<T> : : push_back (const T &datum) { Node *node = new Node{ datum, last, nullptr }; }",'4512,'85.74218750
'300,'Page number 299,"'295",'4513,'84.96093750
'301,'Title 74,"'Programming and Data Structures, Release 0.3",'4514,'54.19921875
'301,'Text 3097,"'With this in mind, consider the following example that inserts local objects into a list:",'4515,'96.28906250
'301,'Text 3098,"'int main () { Llama paul (""Paul"") ; Llama carl (""Carl"") ; List<Llama> todo; odo.push_back(paul) todo.push_back(carl); for (auto &llama : todo) { 11ama.feed(); } }",'4516,'39.03808594
'301,'Text 3099,"'The code creates two local Llama objects and inserts them into a list. It then iterates over the list to feed each llama. However, as shown in Figure 38.1, the llamas in the list are copies of the local objects, SO feeding them does not affect the original llamas, which go hungry.",'4517,'87.10937500
'301,'Figure 114,"",'4518,'82.95898438
'301,'Text 3100,"'Stack",'4519,'51.07421875
'301,'Text 3101,"'Figure 38.1: Inserting objects into a container creates copies of those objects.",'4520,'87.89062500
'301,'Text 3102,"'We can use indirection to avoid making a copy, storing pointers to llamas in a list rather than llamas themselves:",'4521,'94.67773438
'301,'Text 3103,"'int main( () { Llama paul (""Paul"") ; Llama carl (""Carl"")",'4522,'59.71679688
'301,'Text 3104,"'List<Llama *> todo; todo.push_back(&paul) ; todo.push_back(&carl);",'4523,'75.63476563
'301,'Text 3105,"'for (auto lptr : todo) { lptr->feed();",'4524,'53.41796875
'301,'Text 3106,"'(continues on next page)",'4525,'81.59179688
'301,'Page number 300,"'296",'4526,'84.17968750
'302,'Header 286,"'Programming and Data Structures, Release 0.3",'4527,'52.53906250
'302,'Text 3107,"'}",'4528,'31.83593750
'302,'Text 3108,"'(continued from previous page)",'4529,'63.62304688
'302,'Figure 115,"",'4530,'25.63476563
'302,'Text 3109,"'The code iterates over the list by value rather than by reference; however, the values are pointers, SO they still indirectly refer to the appropriate Llama objects when they are copied. Figure 38.2 illustrates the result in memory. Our llamas are properly fed and no longer go hungry.",'4531,'95.75195313
'302,'Figure 116,"",'4532,'92.52929688
'302,'Text 3110,"'Figure 38.2: Storing pointers in a container.",'4533,'95.31250000
'302,'Text 3111,"'By storing pointers in a container, we avoid making copies of the underlying objects.",'4534,'91.69921875
'302,'Text 3112,"'Containers of pointers are also useful for keeping track of multiple orderings of the same objects. For instance, we may want to store our llamas both in order of age as well as alphabetically by name. The following code creates Llama objects in dynamic memory and stores pointers to them in two different lists:",'4535,'96.38671875
'302,'Text 3113,"'int main() {",'4536,'32.51953125
'302,'Text 3114,"'List<Llama by_age; by_age.push_back(new Llama(""Paul"")); by_age.push_back(new Llama(""Carl"")): List<Llama *> by_name; by_name.push_back(by_age.back()); by_name.push_back(by_age.front( }",'4537,'51.17187500
'302,'Section header 200,"'Figure 38.3 shows the resulting storage.",'4538,'39.99023438
'302,'Text 3115,"'The code above, however, has a memory leak; the destructors for the lists only free the memory for the Node objects, SO the Llama objects do not get deleted. We need to manually delete them before the lists that we are using to track them go away:",'4539,'95.75195313
'302,'Page number 301,"'297",'4540,'90.67382813
'303,'Header 287,"'Programming and Data Structures, Release 0.3",'4541,'82.03125000
'303,'Figure 117,"",'4542,'98.29101563
'303,'Text 3116,"'Stack",'4543,'49.02343750
'303,'Text 3117,"'Figure 38.3: Two containers that store pointers to the same objects.",'4544,'89.16015625
'303,'Text 3118,"'int main() { List<Llama by_age; by_age.push_back(new Llama(""Paul""); by_age.push_back(new Llama(""Carl"")) List<Llama *> by_name; by_name.push_back(by_age.back()); by_name.push_back(by_age.front()). for (auto llama : by_age) { delete llama; } for (auto llama : by_name) { delete llama; // UNDEFINED BEHAVIOR } }",'4545,'70.99609375
'303,'Text 3119,"'This code is erroneous: it deletes each Llama object twice, resulting in undefined behavior. We need to be careful to avoid memory errors when we have multiple containers referring to the same dynamic objects. What we should do is designate one container as the canonical ""owner"" of the objects, only deleting them when that container is about to die:",'4546,'96.82617188
'303,'Text 3120,"'int main() { List<Llama *> by_age; by_age.push_back(new LIama(""Paul"")); by_age.push_back(new Llama(""Carl""));",'4547,'67.33398438
'303,'Figure 118,"",'4548,'30.49316406
'303,'Text 3121,"'List<Llama *> by_name; by_name.push_back(by_age.back()); by_name.push_back(by_age.front())",'4549,'85.79101563
'303,'Text 3122,"'// ""owner"" of llama objects",'4550,'60.49804688
'303,'Text 3123,"'for (auto llama : by_age) { // delete llamas when by_age is dying delete llama; }",'4551,'88.03710938
'303,'Text 3124,"'}",'4552,'45.43457031
'303,'Page number 302,"'298",'4553,'90.96679688
'304,'Header 288,"'Programming and Data Structures, Release 0.3",'4554,'52.63671875
'304,'Text 3125,"'Alternatively, we can store the objects directly in the container that ""owns"" them, SO that the destructor for the container does the work of reclaiming those objects:",'4555,'98.73046875
'304,'Text 3126,"'int main() {",'4556,'60.83984375
'304,'Text 3127,"'List<Llama> by_age; // ""owner"" of llama objects by_age.push_back(Llama(""Paul"")); by_age.push_back(Llama(""Carl"")); List<Llama *> by_name; by_name.push_back(&by_age.back()) by_name.push_back(&by_age.front()) // llamas die automatically when by_age dies",'4557,'83.83789063
'304,'Text 3128,"'}",'4558,'77.97737122
'304,'Text 3129,"'Here, we construct the Llama objects as temporaries when passing them to push_back(). Standard-library containers have emplace_back() functions that avoid creating temporaries, and we pass the constructor arguments directly to that function:",'4559,'96.14257813
'304,'Text 3130,"'int main() { List<Llama> by_age; // ""owner"" of llama objects y_age.emplace_back(""Paul"") by_age.emplace_back(""Carl"") List<Llama *> by_name; by_name.push_back(&by_age.back()); by_name.push_back(&by_age.front()); } // llamas die automatically when by_age dies",'4560,'72.50976563
'304,'Text 3131,"'The result in memory is shown in Figure 38.4.",'4561,'81.10351563
'304,'Figure 119,"",'4562,'95.89843750
'304,'Text 3132,"'Figure 38.4: Storing pointers to elements of a different container.",'4563,'92.82226563
'304,'Text 3133,"'The llamas die automatically when the container in which they reside dies, at the end of main () in the code above.",'4564,'95.99609375
'304,'Page number 303,"'299",'4565,'90.77148438
'305,'Header 289,"'Programming and Data Structures, Release 0.3",'4566,'81.15234375
'305,'Title 75,"'38.1 Sorting Containers of Pointers",'4567,'64.89257813
'305,'Text 3134,"'The following code stores pointers to llamas in a container and then sorts them:",'4568,'95.26367188
'305,'Section header 201,"'int main() {",'4569,'27.12402344
'305,'Text 3135,"'vector<Llama *> llamas = { new Llama (""Paul""), new Llama (""Carl"") }; std: : sort (11amas.begin (), llamas.end() }",'4570,'95.99609375
'305,'Text 3136,"'While this code compiles, it sorts the pointers in the container by the address values they store, not by some property of the Llama objects. This is because std: : sort () uses the < operator by default, which for pointers just compares the addresses they contain. The result depends on where the two Llama objects were placed in memory, which is implementation-dependent.",'4571,'94.58007813
'305,'Text 3137,"'Instead, we need to supply our own comparator to std: : sort(), and the comparator can use whatever property we choose of the underlying Llama objects:",'4572,'92.67578125
'305,'Text 3138,"'class LlamaPointerNameLess { public: bool operator() (const Llama *11, const Llama *12) const { return 11->get_name(] < 12->get_name(); } };",'4573,'96.14257813
'305,'Text 3139,"'Here, we have chosen to sort llamas by name. The comparator operates on pointers to Llamas, since that is what the container stores. We then call std: : sort( as follows:",'4574,'95.55664063
'305,'Text 3140,"'std: : sort(llamas.begin(), llamas.end(), LlamaPointerNameLess());",'4575,'94.28710938
'305,'Text 3141,"'The third argument is a default-constructed, temporary LlamaPointerNameLess object. Now std: : sort( will use that to compare the Llama * elements, resulting in them being ordered by the names of the respective llamas.",'4576,'95.65429688
'305,'Text 3142,"'We can use different comparators to maintain different orderings of the same objects:",'4577,'84.71679688
'305,'Text 3143,"'vector<Llama> llamas = { Llama(""Paul""), Llama (""Carl"") }; vector<Llama *> by_age; for (auto &llama : llamas) { by_age.push_back(&llama) } std: (by_age.begin(), by_age.end(), LlamaPointerAgeLess()); vector<Llama *> by_name = by_age; std: : sort(by_name.begin(), by_name.end(), LlamaPointerNameLess());",'4578,'28.34472656
'305,'Footer 213,"'38.1. Sorting Containers of Pointers",'4579,'81.29882813
'305,'Page number 304,"'300",'4580,'78.27148438
'306,'Header 290,"'Programming and Data Structures, Release 0.3",'4581,'66.89453125
'306,'Title 76,"'38.2 Containers of Polymorphic Objects",'4582,'53.61328125
'306,'Text 3144,"'Keeping track of polymorphic objects, meaning objects of different derived classes of the same base class, requires indirection as we saw previously. Containers of pointers enable this indirection:",'4583,'97.90039063
'306,'Text 3145,"'int main() {",'4584,'26.53808594
'306,'Figure 120,"",'4585,'27.95410156
'306,'Figure 121,"",'4586,'31.44531250
'306,'Text 3146,"'vector<Animal * zoo; zoo.push_back(new Gorilla(""Colo"")) zoo. .push_back(new Llama (""Paul"")) zoo.push_back (new Panda (""Po""))",'4587,'62.98828125
'306,'Figure 122,"",'4588,'25.24414063
'306,'Text 3147,"'for (auto animal_ptr : zoo) { animal_ptr->talk(); // prints different messages for each animal }",'4589,'79.73632813
'306,'Text 3148,"'}",'4590,'99.47283936
'306,'Text 3149,"'As long as the talk () function is virtual, dynamic binding will be used, and each animal will print its own sound. When we are done with the objects, we need to delete them ourselves, since they are in dynamic memory:",'4591,'93.06640625
'306,'Text 3150,"'for (auto animal_ptr : zoo) delete animal_ptr; }",'4592,'83.39843750
'306,'Text 3151,"'As we saw previously, this requires the Animal destructor to be declared as virtual SO that dynamic binding is used to call the appropriate destructor for each object.",'4593,'95.55664063
'306,'Footer 214,"'38.2. Containers of Polymorphic Objects",'4594,'53.90625000
'306,'Page number 305,"'301",'4595,'87.25585938
'307,'Text 3152,"'CHAPTER",'4596,'44.55566406
'307,'Text 3153,"'THIRTYNINE",'4597,'37.89062500
'307,'Text 3154,"'C AND C++ STRINGS",'4598,'63.62304688
'307,'Text 3155,"'A string is a sequence of characters, and it represents text data. C++ has two string abstractions, which we refer to as C-style strings and C++ strings.",'4599,'94.82421875
'307,'Section header 202,"'39.1 C-Style Strings",'4600,'84.66796875
'307,'Text 3156,"'In the original C language, strings are represented as just an array of characters, which have the type char. The following initializes a string representing the characters in the word hello:",'4601,'94.67773438
'307,'Key value 44,"",'4602,'48.24218750
'307,'Table 83,"",'4603,'79.68750000
'307,'Text 3157,"'Figure 39.1: Array representation of a string.",'4604,'94.48242188
'307,'Text 3158,"'Character literals are enclosed in single quotes. For example 'h' is the character literal corresponding to the lower-case letter h. The representation of the string in memory is shown in Figure 39.1.",'4605,'96.09375000
'307,'Text 3159,"'A C-style string has a sentinel value at its end, the special null character, denoted by '\0'. This is not the same as a null pointer, which is denoted by nullptr, nor the character '0', which denotes the digit 0. The null character signals the end of the string, and algorithms on C-style strings rely on its presence to determine where the string ends.",'4606,'97.07031250
'307,'Text 3160,"'A character array can also be initialized with a string literal:",'4607,'87.45117188
'307,'Text 3161,"'char str2[6] = ""hello""; char str3[ = ""hello"";",'4608,'67.13867188
'307,'Text 3162,"'If the size of the array is specified, it must have sufficient space for the null terminator. In the second case above, the size of the array is inferred as 6 from the string literal that is used to initialize it. A string literal implicitly contains the null terminator at its end, SO both str2 and str3 are initialized to end with a null terminator.",'4609,'97.02148438
'307,'Page number 306,"'302",'4610,'73.73046875
'308,'Header 291,"'Programming and Data Structures, Release 0.3",'4611,'72.31445313
'308,'Text 3163,"'The char type is an atomic type that is represented by numerical values. The ASCII standard specifies the numerical values used to represent each character. For instance, the null character '\0' is represented by the ASCII value 0, the digit , 'O' , is represented by the ASCII value 48, and the letter 'h' is represented by the ASCII value 104. Figure 39.2 illustrates the ASCII values that represent the string ""hello"".",'4612,'98.53515625
'308,'Table 84,"",'4613,'90.86914063
'308,'Text 3164,"'Figure 39.2: ASCII values of the characters in a string.",'4614,'89.50195313
'308,'Text 3165,"'An important feature of the ASCII standard is that the digits 0-9 are represented by consecutive values, the capital letters A-Z are also represented by consecutive values, and the lower-case letters a-z as well. The following function determines whether a character is a letter:",'4615,'97.65625000
'308,'Key value 45,"",'4616,'53.61328125
'308,'Text 3166,"'In C++, atomic objects with value 0 are considered to have false truth values, while atomic objects with nonzero values are considered to be true. Thus, the null terminator is the only character that has a false truth value. We will make use of that when implementing algorithms on C-style strings.",'4617,'97.36328125
'308,'Text 3167,"'Since C-style strings are just arrays, the pitfalls that apply to arrays also apply to C-style strings. For instance, a char array turns into a pointer to char when its value is required. Thus, comparisons and assignments on C-style strings cannot be done with the built-in operators:",'4618,'97.41210938
'308,'Table 85,"",'4619,'29.98046875
'308,'Text 3168,"'When initializing a variable from a string literal, the variable can be an array, in which case the individual characters are initialized from those in the string literal:",'4620,'93.11523438
'308,'Text 3169,"'char str1[6] = ""hello"";",'4621,'36.98730469
'308,'Footer 215,"'39.1. C-Style Strings",'4622,'73.48632813
'308,'Page number 307,"'303",'4623,'87.25585938
'309,'Header 292,"'Programming and Data Structures, Release 0.3",'4624,'75.58593750
'309,'Text 3170,"'The variable can also be a pointer, in which case it just points to the first character in the string literal itself. String literals are stored in memory; however, the C++ standard prohibits us from modifying the memory used to store a string literal. Thus, we must use the const keyword when specifying the element type of the pointer:",'4625,'98.87695313
'309,'Text 3171,"'const char *ptr = ""hello"";",'4626,'54.19921875
'309,'Section header 203,"'39.1.1 String Traversal and Functions",'4627,'51.75781250
'309,'Text 3172,"'The conventional pattern for iterating over a C-style string is to use traversal by pointer: walk a pointer across the elements until the end is reached. However, unlike the traversal pattern we saw previously where we already knew the length, we don't know the end of a C-style string until we reach the null terminator. Thus, we iterate until we reach that sentinel value:",'4628,'97.80273438
'309,'Text 3173,"'// REQUIRES: str points to a valid, null-terminated string // EFFECTS: Returns the length of str, not including the null // terminator. int strlen(const char *str) { const char *ptr = str; while (*ptr '\0') ++ptr; } return ptr - str; }",'4629,'69.67773438
'309,'Text 3174,"'Here, we compute the length of a string by creating a new pointer that points to the first character. We then increment that pointer¹ until reaching the null terminator. Then the distance between that pointer and the original is equal to the number of non-null characters in the string.",'4630,'97.11914063
'309,'Text 3175,"'We can also use the truth value of the null character in the test of the while loop:",'4631,'95.65429688
'309,'Text 3176,"'int strlen(const char *str) { const char *ptr = str; while (*ptr) { ++ptr; } return ptr - str; }",'4632,'96.92382813
'309,'Text 3177,"'We can also use a for loop, with an empty initialization and body:",'4633,'95.06835938
'309,'Text 3178,"'int strlen(const char *str) { const char *ptr = str; for (; *ptr; ++ptr); return ptr - str; }",'4634,'95.60546875
'309,'Text 3179,"'The built-in <cstring> header contains a definition for strlen().",'4635,'91.55273438
'309,'Text 3180,"'We saw previously that we cannot copy C-style strings with the assignment operator. Instead, we need to use a function:",'4636,'96.19140625
'309,'Text 3181,"'1 The type const char * denotes a pointer that is pointing at a constant character. This means that the pointed-to character cannot be modified through the pointer. However, the pointer itself can be modified to point to a different character, which is what happens when we increment the pointer.",'4637,'95.80078125
'309,'Footer 216,"'39.1. C-Style Strings",'4638,'54.10156250
'309,'Page number 308,"'304",'4639,'69.33593750
'310,'Title 77,"'Programming and Data Structures, Release 0.3",'4640,'40.16113281
'310,'Text 3182,"'// REQUIRES: src points to a valid, null-terminated string; // dst points to an array with >= strlen(src) + 1 elements // MODIFIES: *dst // EFFECTS: Copies the characters from src into dst, including the // null terminator. void strcpy (char *dst, const char *src) { while (*src) { *dst = *src; ++src; ++dst; } *dst = *src; // null terminator",'4641,'34.47265625
'310,'Text 3183,"'}",'4642,'28.93066406
'310,'Text 3184,"'The function takes in a destination pointer; the pointed-to type must be non-const, since the function will modify the elements. The function does not need to modify the source string, SO the corresponding parameter is a pointer to const char. Then each non-null character from src is copied into dst. The last line also copies the null terminator into dst.",'4643,'93.01757813
'310,'Text 3185,"'The strcpy () function can be written more succinctly by relying on the behavior of the postfix increment operator. There are two versions of the increment operator, and their evaluation process is visualized in Figure 39.3:",'4644,'83.64257813
'310,'Figure 123,"",'4645,'25.63476563
'310,'Text 3186,"'Figure 39.3: Evaluation process for prefix and postfix increment.",'4646,'94.48242188
'310,'Text 3187,"'The prefix increment operator, when applied to an atomic object, increments the object and evaluates to the object itself, which now contains the new value:",'4647,'94.18945313
'310,'Text 3188,"'int x = 3; cout << ++x; // prints 4 cout << x; // prints 4",'4648,'73.73046875
'310,'Text 3189,"'The postfix increment operator, when applied to an atomic object, increments the object but evaluates to the old value:",'4649,'93.16406250
'310,'Footer 217,"'39.1. C-Style Strings",'4650,'79.24804688
'310,'Page number 309,"'305",'4651,'84.76562500
'311,'Title 78,"'Programming and Data Structures, Release 0.3",'4652,'43.77441406
'311,'Text 3190,"'int x = 3; cout << X++; // prints 3 cout << X; // prints 4",'4653,'56.59179688
'311,'Text 3191,"'There are also both prefix and postfix versions of the decrement operator (--).",'4654,'94.62890625
'311,'Text 3192,"'A word of caution when writing expressions that have side effects, such as increment: in C++, the order in which subexpressions are evaluated within a larger expression is for the most part unspecified. Thus, the following results in implementation-dependent behavior:",'4655,'97.31445313
'311,'Text 3193,"'int x = 3; cout ++X << "" , << x; // can print 4,4 or 4,3",'4656,'74.60937500
'311,'Text 3194,"'If the second X in the print statement is evaluated before ++X, then a 3 will be printed out for its value. On the other hand, if the second X is evaluated after ++x, a 4 will be printed out for its value. Code like this, where a single statement contains two subexpressions that use the same variable but at least one modifies it, should be avoided.",'4657,'95.31250000
'311,'Text 3195,"'Another feature that our shorter version of strcpy () will rely on is that an assignment evaluates back to the left-hand- side object:",'4658,'91.16210938
'311,'Text 3196,"'int X = 3; int y = -4; ++(x = y); // copies -4 into X, then increments X cout << x; // prints -3 cout (y = x) // prints -3",'4659,'49.12109375
'311,'Text 3197,"'The succinct version of strcpy is as follows:",'4660,'55.17578125
'311,'Text 3198,"'void strcpy (char *dst, const char *src) { while (*dst++ = *src++); }",'4661,'95.60546875
'311,'Text 3199,"'The test increments both pointers, but since it is using postfix increment, the expressions themselves evaluate to the old values. Thus, in the first iteration, dst++ and src++ evaluate to the addresses of the first character in each string. The rest of the test expression dereferences the pointers and copies the source value to the destination. The assignment then evaluates to the left-hand-side object, SO the test checks the truth value of that object's value. As long as the character that was copied was not the null terminator, it will be true, and the loop will continue on to the next character. When the null terminator is reached, the assignment copies it to the destination but then produces a false value, SO the loop terminates immediately after copying over the null terminator.",'4662,'97.85156250
'311,'Text 3200,"'The <cstring> library also contains a version of strcpy().",'4663,'92.23632813
'311,'Section header 204,"'39.1.2 Printing C-Style Arrays",'4664,'91.16210938
'311,'Text 3201,"'Previously, we say that printing out an array prints out the address of its first character, since the array turns into a pointer. Printing out a pointer just prints out the address value contained in the pointer.",'4665,'94.92187500
'311,'Text 3202,"'On the other hand, C++ output streams have special treatment of pointers to char. If a pointer to char is passed to cout, it will assume that the pointer is pointing into a C-style string and print out every character until it reaches a null terminator:",'4666,'92.96875000
'311,'Text 3203,"'char str[] = ""hello""; char *ptr = str; cout << ptr; // prints out hello cout << str; // str turns into a pointer; prints out hello",'4667,'38.52539063
'311,'Footer 218,"'39.1. C-Style Strings",'4668,'56.29882813
'311,'Page number 310,"'306",'4669,'86.18164063
'312,'Header 293,"'Programming and Data Structures, Release 0.3",'4670,'69.58007813
'312,'Text 3204,"'This means that we must ensure that a char * is actually pointing to a null-terminated string before passing it to cout. The following results in undefined behavior:",'4671,'98.29101563
'312,'Key value 46,"",'4672,'61.62109375
'312,'Text 3205,"'To print out the address value of a char *, we must convert it into a void *, which is a pointer that can point to any kind of object:",'4673,'95.26367188
'312,'Text 3206,"'cout static_cast<void *>(&ch) ; // prints address of ch",'4674,'64.35546875
'312,'Section header 205,"'39.2 C++ Strings",'4675,'83.20312500
'312,'Text 3207,"'C++ strings are class-type objects represented by the string type2. They are not arrays, though the implementation may use arrays under the hood. Thus, C++ strings are to C-style strings as vectors are to built-in arrays.",'4676,'97.75390625
'312,'Text 3208,"'The following table compares C-style and C++ strings:",'4677,'93.84765625
'312,'Table 86,"",'4678,'93.55468750
'312,'Text 3209,"'A C++ string can be converted into a C-style string by calling c_str() on it:",'4679,'97.75390625
'312,'Text 3210,"'const char *cstr = str.c_str();",'4680,'79.44335938
'312,'Text 3211,"'A C-style string can be converted into a C++ string by explicitly or implicitly calling the string constructor:",'4681,'97.26562500
'312,'Text 3212,"'string str1 = string(cstr) // explicit call string str = cstr; // implicit call",'4682,'53.61328125
'312,'Text 3213,"'C++ strings can be compared with the built-in comparison operators, which compare them lexicographically: the ASCII values of elements are compared one by one, and if the two strings differ in a character, then the string whose character has a lower ASCII value is considered less than the other. If one string is a prefix of the other, then the shorter one is less than the longer (which results from comparing the ASCII value of the null terminator to a non-null character).",'4683,'97.36328125
'312,'Text 3214,"'C-style strings cannot be compared with the built-in operators - these would just do pointer comparisons. Instead, the strcmp () function can be used, and strcmp(str1, str2) returns:",'4684,'92.08984375
'312,'List 113,"",'4685,'88.67187500
'312,'Text 3215 - Part of List 113,"'a negative value if str1 is lexicographically less than str2",'4686,'97.75390625
'312,'Text 3216 - Part of List 113,"'a positive value if str1 is lexicographically greater than str2",'4687,'97.41210938
'312,'Text 3217 - Part of List 113,"'0 if the two strings have equal values",'4688,'96.67968750
'312,'Text 3218,"'2 Technically, string is an alias for basic_string<char>, SO you may see the latter in compiler errors.",'4689,'77.53906250
'312,'Footer 219,"'39.2. C++ Strings",'4690,'86.37695313
'312,'Page number 311,"'307",'4691,'75.14648438
'313,'Header 294,"'Programming and Data Structures, Release 0.3",'4692,'51.85546875
'313,'Text 3219,"'The expression ! strcmp (strl, str2) is often used to check for equality - if the two strings are equal, strcmp() returns 0, which has truth value false.",'4693,'38.72070313
'313,'Footer 220,"'39.2. C++ Strings",'4694,'84.42382813
'313,'Page number 312,"'308",'4695,'62.15820313
'314,'Text 3220,"'CHAPTER",'4696,'76.41601563
'314,'Text 3221,"'FORTY",'4697,'64.06250000
'314,'Text 3222,"'ABOUT",'4698,'90.72265625
'314,'Text 3223,"'These notes were written by Amir Kamil in Winter 2019 for EECS 280. They are based on the lecture slides by James Juett and Amir Kamil, which were themselves based on slides by Andrew DeOrio and many others.",'4699,'46.87500000
'314,'Text 3224,"'This text is licensed under the Creative Commons Attribution-ShareAlike 4.0 International license.",'4700,'40.35644531
'314,'Page number 313,"'309",'4701,'63.08593750
